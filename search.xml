<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习笔记·多项式专题（二）]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%93%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一片文章讲的呢，都是一些板子。 多项式的求导与不定积分$\frac{\mathrm{d}}{\mathrm{d}x}x^n=nx^{n-1},\int x^n=\frac{x^{n+1}}{n+1}\mathrm{d}x$，所以直接套公式即可。12345678910111213141516inline void deriv(ll fd,ll *f,ll *res)&#123; for(register int i=1;i&lt;fd;++i) &#123; res[i-1]=(li)f[i]*i%MOD; &#125; res[fd-1]=0;&#125;inline void integ(ll fd,ll *f,ll *res)&#123; for(register int i=1;i&lt;fd;++i) &#123; res[i]=(li)f[i-1]*qpow(i,MOD-2)%MOD; &#125; res[0]=0;&#125; 多项式乘法略 多项式求逆如果$F(x)$只有一项，那么答案是它的逆元。 剩下的情况考虑递归做，假设已经求出了$\bmod{x^{\lceil\frac{n}{2}\rceil}}$意义下的答案$H(x)$，考虑推出$\bmod{x^n}$意义下的答案$G(x)$，于是有： F(x)H(x)\equiv 1\pmod{x^{\lceil\frac{n}{2}\rceil}}F(x)G(x)\equiv 1\pmod{x^n}\therefore F(x)(G(x)-H(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\therefore G(x)-H(x)\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\therefore G(x)^2-2G(x)H(x)+H(x)^2\equiv 0\pmod{x^n}\therefore G(x)\equiv 2H(x)-F(x)H(x)^2\pmod{x^n}于是可以快活地上板子啦qwq123456789101112131415161718192021222324252627282930inline void inv(ll fd,ll *f,ll *res)&#123; static ll tmp[MAXN]; if(fd==1) &#123; res[0]=qpow(f[0],MOD-2); return; &#125; inv((fd+1)&gt;&gt;1,f,res); ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;++i) &#123; tmp[i]=i&lt;fd?f[i]:0; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp,cnt,1),NTT(res,cnt,1); for(register int i=0;i&lt;cnt;++i) &#123; res[i]=(li)(2-(li)tmp[i]*res[i]%MOD+MOD)%MOD*res[i]%MOD; &#125; NTT(res,cnt,-1); for(register int i=fd;i&lt;cnt;++i) &#123; res[i]=0; &#125;&#125; 多项式对数函数大力推一波公式： G(x)=\ln F(x)\therefore G^\prime(x)=(\ln F(x))^\prime根据链式求导法则$\frac{\mathrm{d}y}{\mathrm{d}x}=\frac{\mathrm{d}y}{\mathrm{d}u}\frac{\mathrm{d}u}{\mathrm{d}x}$和基本公式$\frac{\mathrm{d}}{\mathrm{d}x}\ln x=\frac{1}{x}$，有 \frac{\mathrm{d}}{\mathrm{d}x}G(x)=$frac{F^\prime(x)}{F(x)}$ 再积分回来 $$\therefore G(x)=]]></content>
      <tags>
        <tag>数论，数学</tag>
        <tag>多项式</tag>
        <tag>NTT</tag>
        <tag>FFT</tag>
        <tag>微积分初步</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4213」【模板】杜教筛（Sum）]]></title>
    <url>%2F2019%2F03%2F10%2F%E3%80%8CLuogu-P4213%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9D%9C%E6%95%99%E7%AD%9B%EF%BC%88Sum%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一共有$T$组数据，对于每组数据，求$\sum\limits_{i=1}^{n}\varphi(i)$和$\sum\limits_{i=1}^{n}\mu(i)$ $\texttt{Data Range:}T\leq 10,n\leq 2^{31}-1$ 链接前置知识积性函数对于一个数论函数$f$，如果对于任意的互质整数$i,j$，使得$f(ij)=f(i)f(j)$，那么说$f$是一个积性函数。 如果对于任意的整数$i,j$，使得$f(ij)=f(i)f(j)$，那么说$f$是一个完全积性函数。 常见的积性函数：$\varphi,\mu,\sigma,d$ 常见的完全积性函数：$\epsilon,id,I$ 这里解释一下完全积性函数下的三个函数。 $\epsilon(n)=[n=1],I(n)=1,id(n)=n$ 狄利克雷卷积对于两个数论函数$f,g$，它们的狄利克雷卷积是$\sum\limits_{d\vert n}f(d)g(\frac{n}{d})$，记作$(f\ast g)(n)$]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>洛谷</tag>
        <tag>数论，数学</tag>
        <tag>筛法</tag>
        <tag>线性筛</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4726」【模板】多项式指数函数]]></title>
    <url>%2F2019%2F02%2F18%2F%E3%80%8CLuogu-P4726%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个$n-1$次整系数多项式$F(x)$，求在$\bmod x^n$意义下的整系数多项式$G(x)$，使得$G(x)=e^{F(x)}$。 在$\bmod 998244353$下进行，且$F(x)$系数均在$[0,998244352]$范围内。首先考虑与多项式对数函数一样的做法，两边求导，会得到这样一个式子： G^\prime(x)=F^\prime(x)e^{F(x)}但是$e^{F(x)}$没有消去，所以这种方法就这样活生生地被搞掉了。 然后考虑与多项式求逆一样去倍增。假设知道$H(x)=e^{F(x)}\pmod x^{\lceil\frac{n}{2}\rceil}$，想推出$G(x)$，那么肿么办？ 一个常见的策略是牛顿迭代。]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>模板</tag>
        <tag>数论，数学</tag>
        <tag>多项式</tag>
        <tag>NTT</tag>
        <tag>FFT</tag>
        <tag>微积分初步</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4725」【模板】多项式对数函数]]></title>
    <url>%2F2019%2F02%2F18%2F%E3%80%8CLuogu-P4725%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个$n-1$次整系数多项式$F(x)$，求在$\bmod x^n$意义下的整系数多项式$G(x)$，使得$G(x)=\ln F(x)$。 在$\bmod 998244353$下进行，且$F(x)$系数均在$[0,998244352]$范围内。 链接Luogu P4725 题解首先声明，这题要使用微积分知识。（不会的可以看我的微积分初步的笔记（一个大坑）） 自然对数直接求感觉很不对劲，但是有这样一个好东西： \cfrac{\mathrm{d}}{\mathrm{d}x}\ln x=\cfrac{1}{x}所以说可以考虑将等式两边求导，右边用链式求导法则搞一下，会得到这个 G^\prime(x)=\cfrac{F^\prime(x)}{F(x)}右边很明显，是$F(x)$的逆乘上它的导数，使用多项式求导和求逆即可算出右边。左边是$G(x)$的导数，而右边是可以求出的多项式，所以可以对右边在膜意义下求不定积分求出$G(x)$，即 G(x)=\int \cfrac{F^\prime(x)}{F(x)}时间复杂度当然只有多项式求逆的$O(n\log n)$啦qwq 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=3e5+51,MOD=998244353,G=3;ll fd,gd;ll f[MAXN],res[MAXN],tmp[MAXN],pinv[MAXN],der[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll qadd(ll x,ll y,ll mod)&#123; return x+y&gt;mod?x+y-mod:x+y;&#125;inline ll qmin(ll x,ll y,ll mod)&#123; return x-y&lt;0?x-y+mod:x-y;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; if(!exponent) &#123; return 1; &#125; ll temp=qpow(base,exponent&gt;&gt;1,mod),res=temp*temp%mod; if(exponent&amp;1) &#123; res=res*base%mod; &#125; return res;&#125;inline void NTT(ll *cp,ll cnt,ll inv,ll mod)&#123; ll lim=0,cur=0,res=0,omg=0; while((1&lt;&lt;lim)&lt;cnt) &#123; lim++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; cur=0; for(register int j=0;j&lt;lim;j++) &#123; if((i&gt;&gt;j)&amp;1) &#123; cur|=(1&lt;&lt;(lim-j-1)); &#125; &#125; if(i&lt;cur) &#123; swap(cp[i],cp[cur]); &#125; &#125; for(register int i=2;i&lt;=cnt;i&lt;&lt;=1) &#123; cur=i&gt;&gt;1,res=qpow(G,(mod-1)/i,mod); for(register ll *p=cp;p!=cp+cnt;p+=i) &#123; omg=1; for(register int j=0;j&lt;cur;j++) &#123; ll t=omg*p[j+cur]%mod; p[j+cur]=qmin(p[j],t,mod); p[j]=qadd(p[j],t,mod); omg=omg*res%mod; &#125; &#125; &#125; if(inv==-1) &#123; ll invl=qpow(cnt,mod-2,mod); cp[0]=cp[0]*invl%mod; for(register int i=1;i&lt;=cnt&gt;&gt;1;i++) &#123; cp[i]=cp[i]*invl%mod; if(i!=cnt-i) &#123; cp[cnt-i]=cp[cnt-i]*invl%mod; &#125; swap(cp[i],cp[cnt-i]); &#125; &#125;&#125;inline void deriv(ll fd,ll *f,ll *res,ll mod)&#123; for(register int i=1;i&lt;fd;i++) &#123; res[i-1]=f[i]*i%mod; &#125; res[fd-1]=0;&#125;inline void integ(ll fd,ll *f,ll *res,ll mod)&#123; for(register int i=1;i&lt;fd;i++) &#123; res[i]=f[i-1]*qpow(i,mod-2,mod)%mod; &#125; res[0]=0;&#125;inline void inv(ll fd,ll *f,ll *res,ll mod)&#123; if(fd==1) &#123; res[0]=qpow(f[0],mod-2,mod); return; &#125; inv((fd+1)&gt;&gt;1,f,res,mod); ll cnt=1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1; &#125; for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=i&lt;fd?f[i]:0; &#125; NTT(tmp,cnt,1,mod),NTT(res,cnt,1,mod); for(register int i=0;i&lt;cnt;i++) &#123; res[i]=qmin(2,tmp[i]*res[i]%mod,mod)*res[i]%mod; &#125; NTT(res,cnt,-1,mod); for(register int i=fd;i&lt;cnt;i++) &#123; res[i]=0; &#125;&#125;inline void ln(ll fd,ll *f,ll *res,ll mod)&#123; ll cnt=1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1; &#125; inv(fd,f,pinv,mod),deriv(fd,f,der,mod); NTT(pinv,cnt,1,mod),NTT(der,cnt,1,mod); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=der[i]*pinv[i]%mod; &#125; NTT(der,cnt,-1,mod),integ(fd,der,res,mod); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=pinv[i]=0; &#125;&#125;int main()&#123; fd=read(); for(register int i=0;i&lt;fd;i++) &#123; f[i]=read(); &#125; ln(fd,f,res,MOD); for(register int i=0;i&lt;fd;i++) &#123; printf("%lld ",res[i]); &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>模板</tag>
        <tag>数论，数学</tag>
        <tag>多项式</tag>
        <tag>NTT</tag>
        <tag>FFT</tag>
        <tag>微积分初步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ题解合集]]></title>
    <url>%2F2019%2F01%2F27%2FBZOJ%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[较慢更新ing…… 1001-19991001-10991001-10091002 [FJOI2007]轮状病毒 简单的$\texttt{Matrix-Tree}$定理的运用，找规律+高精。 题解 1011-10191012 [JSOI2008]最大数maxnumber 线段树裸题。 题解 1013 [JSOI2008]球形空间产生器sphere 构造二次方程组，相邻两项作差得到一次方程组，高斯消元即可。 题解 1015 [JSOI2008]星球大战starwar 考虑逆推加边，并查集即可。 题解 1040-10491041 [HAOI2008]圆上的整点 比较复杂的神仙数论题。 题解 1042 [HAOI2008]硬币购物 DP+容斥。 题解 今天暂时更到这里。]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>合集</tag>
        <tag>未完待续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2144」[FJOI2007]轮状病毒]]></title>
    <url>%2F2019%2F01%2F27%2F%E3%80%8CLuogu-P2144%E3%80%8D-FJOI2007-%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92%2F</url>
    <content type="text"><![CDATA[有$n+1$个点组成一个无向图，其中$n$个点组成一个环，剩下一个点向这$n$个点各连一条边，求这个图不同的生成树个数。 Data Range：$n\leq 100$ 链接Luogu P2144BZOJ 1002CodeVS 2886 题解既然这个题要你生成树数量，那么就可以用$\texttt{Matrix-Tree}$定理乱搞了。 设$F_i$表示$n=i$时的答案，那么有： $F_1=1,F_2=5,F_3=16,F_4=45\cdots$ 好像看不出来啊，然而你可以打一个$O(n^3)$的高斯消元求行列式，所以又可以算出一下数据： $F_5=121,F_6=320$ 那么可以看到奇数项都是平方数，于是想把偶数项拆成有关平方数的式子。 那么$F_1=1^2,F_2=3^2-4,F_3=4^2,F_4=7^2-4,F_5=11^2,F_6=18^2-4$ 于是考虑怎么推出这些平方项的。把它们提出来，会是这样： $1,3,4,7,11,18\cdots$ 所以这一项会是前两项的和，于是就可以开开心心写了。 但是$n\leq 100$，所以要用到高精qwq。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=151;struct BigInt&#123; ll digit; ll num[MAXN]; BigInt() &#123; memset(num,0,sizeof(num)); &#125; inline void operator =(ll x) &#123; while(x) &#123; num[digit++]=x%100000000,x/=100000000; &#125; &#125; inline void op() &#123; printf("%lld",num[digit-1]); for(register int i=digit-2;i&gt;=0;i--) &#123; if(!num[i]) &#123; printf("00000000"); continue; &#125; ll rest=7-(ll)(log10(num[i])); for(register int j=rest;j;j--) &#123; putchar('0'); &#125; printf("%lld",num[i]); &#125; &#125;&#125;; BigInt res;BigInt sqr[151];ll num;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline BigInt operator +(BigInt x,BigInt y)&#123; BigInt res; ll carry=0; res.digit=max(x.digit,y.digit)+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]+y.num[i]+carry; carry=res.num[i]/100000000,res.num[i]%=100000000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator *(BigInt x,ll y)&#123; BigInt res; ll carry=0; res.digit=x.digit+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]*y+carry; carry=res.num[i]/100000000,res.num[i]%=100000000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator *(BigInt x,BigInt y)&#123; BigInt res; res.digit=x.digit+y.digit; for(register int i=0;i&lt;res.digit;i++) &#123; for(register int j=0,k=i;k&gt;=0;j++,k--) &#123; res.num[i]+=x.num[j]*y.num[k]; res.num[i+1]+=res.num[i]/100000000,res.num[i]%=100000000; &#125; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline void setup(ll num)&#123; sqr[1]=1,sqr[2]=3; for(register int i=3;i&lt;=num;i++) &#123; sqr[i]=sqr[i-1]+sqr[i-2]; &#125;&#125;int main()&#123; num=read(); setup(num); res=sqr[num]*sqr[num],res.num[0]-=(num&amp;1)?0:4; res.op();&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>洛谷</tag>
        <tag>CodeVS</tag>
        <tag>组合数学</tag>
        <tag>生成树</tag>
        <tag>Matrix-Tree定理</tag>
        <tag>高精</tag>
        <tag>打表</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期的一些计划]]></title>
    <url>%2F2019%2F01%2F26%2F%E8%BF%91%E6%9C%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[我太菜了，天天被又强又巨，还全方位的吊打我的tbr爆踩，所以要列一些计划了。1.多项式全家桶 Y Luogu P3803 【模板】多项式乘法（FFT） Y Luogu P4245 【模板】任意模数NTT Luogu P4238 【模板】多项式求逆 Luogu P4512 【模板】多项式除法]]></content>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4245」【模板】任意模数NTT]]></title>
    <url>%2F2019%2F01%2F26%2F%E3%80%8CLuogu-P4245%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0NTT%2F</url>
    <content type="text"><![CDATA[给定两个$n$次多项式$F(x),G(x)$的系数数列$a,b$和一个整数$p$，求$F(x)G(x)$在$\bmod p$意义下的值，不保证$p$可以分解成$a\cdot 2^k+1$的形式。 Data Range：$1\leq n\leq 10^5,0\leq a_i,b_i\leq 10^9,2\leq p\leq 10^9+9$ 链接Luogu P4245 题解如果$p$是形如$a\cdot 2^k+1$的质数，可以直接刚$\texttt{NTT}$，但是布星啊，样例中的$p$都不是质数，所以说怎么办呢？ 用$\texttt{NTT}$计算多项式乘法的最终结果是取模后的，所以考虑采用$\texttt{CRT}$合并答案。 但是，答案要在$\texttt{long long}$范围内唯一，所以取两个模数布星，要取三个，即所谓的三模数$\texttt{NTT}$。 这里我个人倾向于取$p_1=469762049$，$p_2=998244353$和$p_3=1004535809$，因为这三个数的原根是$3$。 于是可以通过$\texttt{NTT}$算出所给的多项式在模$p_1,p_2,p_3$意义下的乘积。 坑。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=4e5+51,G=3;const ll MOD1=469762049,MOD2=998244353,MOD3=1004535809;const ll MOD=468937312667959297;struct Polynomial&#123; ll deg; ll coeff[MAXN];&#125;;Polynomial x,y,res1,res2,res3;ll cnt,mod;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll qadd(ll x,ll y,ll mod)&#123; return x+y&gt;mod?x+y-mod:x+y;&#125;inline ll qmin(ll x,ll y,ll mod)&#123; return x-y&lt;0?x-y+mod:x-y;&#125;inline ll qmul(ll x,ll y,ll mod)&#123; x%=mod,y%=mod; return ((x*y-(ll)((ll)((long double)x/mod*y+0.5)*mod))%mod+mod)%mod;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; if(!exponent) &#123; return 1; &#125; ll temp=qpow(base,exponent&gt;&gt;1,mod),res=temp*temp%mod; if(exponent&amp;1) &#123; res=res*base%mod; &#125; return res;&#125;inline void NTT(ll *cp,ll cnt,ll inv,ll mod)&#123; ll lim=0,cur=0,res=0,omg=0; while((1&lt;&lt;lim)&lt;cnt) &#123; lim++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; cur=0; for(register int j=0;j&lt;lim;j++) &#123; if((i&gt;&gt;j)&amp;1) &#123; cur|=(1&lt;&lt;(lim-j-1)); &#125; &#125; if(i&lt;cur) &#123; swap(cp[i],cp[cur]); &#125; &#125; for(register int i=2;i&lt;=cnt;i&lt;&lt;=1) &#123; cur=i&gt;&gt;1,res=qpow(G,(mod-1)/i,mod); for(register ll *p=cp;p!=cp+cnt;p+=i) &#123; omg=1; for(register int j=0;j&lt;cur;j++) &#123; ll t=omg*p[j+cur]%mod; p[j+cur]=qmin(p[j],t,mod); p[j]=qadd(p[j],t,mod); omg=omg*res%mod; &#125; &#125; &#125;&#125;inline Polynomial mul(Polynomial x,Polynomial y,ll mod)&#123; Polynomial res; ll cnt=1,inv; static ll cpx[MAXN],cpy[MAXN]; memset(cpx,0,sizeof(cpx)),memset(cpy,0,sizeof(cpy)); for(register int i=0;i&lt;=x.deg;i++) &#123; cpx[i]=x.coeff[i]; &#125; for(register int i=0;i&lt;=y.deg;i++) &#123; cpy[i]=y.coeff[i]; &#125; while(cnt&lt;=x.deg+y.deg) &#123; cnt&lt;&lt;=1; &#125; NTT(cpx,cnt,1,mod),NTT(cpy,cnt,1,mod); for(register int i=0;i&lt;=cnt;i++) &#123; cpx[i]=cpx[i]*cpy[i]%mod; &#125; NTT(cpx,cnt,-1,mod); res.deg=x.deg+y.deg,inv=qpow(cnt,mod-2,mod); cpx[0]=cpx[0]*inv%mod; for(register int i=1;i&lt;=cnt&gt;&gt;1;i++) &#123; cpx[i]=cpx[i]*inv%mod; if(i!=cnt-i) &#123; cpx[cnt-i]=cpx[cnt-i]*inv%mod; &#125; swap(cpx[i],cpx[cnt-i]); &#125; for(register int i=0;i&lt;=res.deg;i++) &#123; res.coeff[i]=qmin(cpx[i],0,mod); &#125; return res;&#125;inline ll CRT(ll r1,ll r2,ll r3,ll mod)&#123; ll inv1=208783132,inv2=395249030; ll r=qadd(qmul(qmul(qmin(r1,r2,MOD1),inv1,MOD1),MOD2,MOD),r2,MOD); ll k=qmul(qmin(r3,r,MOD3),inv2,MOD3); return ((k%mod)*(MOD%mod)%mod+r)%mod;&#125;int main()&#123; x.deg=read(),y.deg=read(),mod=read(); for(register int i=0;i&lt;=x.deg;i++) &#123; x.coeff[i]=read()%mod; &#125; for(register int i=0;i&lt;=y.deg;i++) &#123; y.coeff[i]=read()%mod; &#125; res1=mul(x,y,MOD1),res2=mul(x,y,MOD2),res3=mul(x,y,MOD3); for(register int i=0;i&lt;=res1.deg;i++) &#123; printf("%lld ",CRT(res1.coeff[i],res2.coeff[i],res3.coeff[i],mod)); &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>模板</tag>
        <tag>数论，数学</tag>
        <tag>多项式</tag>
        <tag>CRT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·多项式专题（一）]]></title>
    <url>%2F2019%2F01%2F20%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[多项式，爽！ FFTFFT，即快速傅里叶变换（英文名$\texttt{Fast Fourier Transform}$），是一个用来求卷积的方法。 卷积这个词以后会经常用到，所以先普及一下这个词到底是什么意思。 形如$y_n=\sum\limits_{i}x_ih_{n-i}$（表示所有$x_i$和$h_{n-i}$有意义时$x_i$）的式子，将$y$称为$xh$的卷积。 但是这个东西有一个更直观的名字：多项式乘法！ 为什么呢？可以看一个直观的解析。 比如说，设$f(x)=1x^2+3x-1,g(x)=3x^2+1x-5$计算$f(x)g(x)$（这里故意加上了这个系数）。 原式$=1x^2(3x^2+1x-5)+3x(3x^2+1x-5)-1(3x^2+1x-5)$ $\quad {=(1\times 3)x^4+(1\times 1+3\times 3)x^3+[1\times -5+3\times 1+(-1)\times(-5)]x^2+}$ $\quad\quad[3\times -5+(-1)\times 1]x+(-1)\times (-5)$。 抽出$x^2$项，将$f(x)$和$g(x)$的系数看做$x$和$h$，结果的系数看做$y$，其中$x_k$表示$x$这个多项式的$x^k$的系数（其实这个数列$x$叫做多项式$x$的系数数列），那么有： $y_2=x_0h_2+x_1h_1+x_2h_0$ $\quad=\sum\limits_{i}x_ih_{2-i}$ 有没有发现这是一个卷积的形式！ 再试别的一些多项式，会发现抽出任何项都会发现是卷积的形式。 为什么呢？ 考虑$y_k$的求法，即$y_kx^k$是怎么得到的。 首先，它只能是一些$x_ix^i$和$h_jx^j$的乘积组成的。（不能由一个多项式的两个单项式的乘积转移而来，还有，这里的$x$应该不会搞混吧） 其次，$x_ix^i$和$h_jx^j$的乘积是一个次数为$k$的单项式。 所以，它只能由$x_0x^0\cdot h_kx^k,x_1x^1\cdot h_{k-1}x^{k-1}\cdots$得到。 而$y_kx^k$正好是这些多项式的和。 所以，$y_kx^k=\sum\limits_{i=0}^kx_ix^i\cdot h_{k-i}x^{k-i}$ 于是自然有y_k=\sum\limits_{i=0}^{k}x_ih_{k-i} 这就是一个卷积的形式啊！ 于是，我们可以显然的知道，多项式乘法就是卷积。 回到正题，先定义几个符号： $F(x)$代表一个多项式，叫做“多项式$F$”。 比如说，设$F(x)=x^3+x^2-1$，如果以后说$x^3+x^2-1$，就直接提$F(x)$就好啦。 于是开始进入多项式乘法这个问题。 如果让你把两个$n$次多项式$F(x)$与$G(x)$乘起来，怎么办？ 你首先所想到的，肯定是像上面那样，把两个多项式暴力地乘起来。 但是，这样做时间复杂度是多少呢？ 我每一次从$F(x)$中拿出一个单项式与$G(x)$相乘，时间复杂度是$O(n)$的，但是$F(x)$从$x^0$到$x^n$有$n+1$个单项式，所以总的来说是$O(n^2)$的。 所以说，有没有更快一点的方法呢？ 还真有！！ 首先看一个问题。 给定有$n$个点$(a_i,F(a_i))$。$F(x)$是几次多项式呢？怎么求F(x)呢？ 先考虑一个简单的，比如说给出了两个点,$(0,1)$和$(1,3)$，怎么求$F(x)$？ 比如说，假设$F(x)$是一次的。那么设$F(x)=a_0x+a_1$，于是将$(0,1),(1,3)$代入$F(x)$，那么有： \begin{cases}a_1=1 \\ a_0+a_1=3\end{cases}解得 \begin{cases}a_0=2 \\ a_1=1\end{cases}而当$F(x)$为二次多项式时，即$F(x)=a_0x^2+a_1x+a_2$，那么可列出如下式子： \begin{cases}a_2=1 \\ a_0+a_1+a_2=3\end{cases}这样子我们最多得到 \begin{cases}a_0+a_1=2 \\ a_2=3\end{cases}$F(x)$为二次多项式就已经不能精确解出系数的值了，那么更高次多项式更不行了。 所以说给两个点的值能确定一个一次多项式。 可以尝试一下$3$个点，它是可以确定一个二次多项式的（可能不能确定一个一次多项式，因为方程组可能无解）。 根据以上的实验和常识可知，$n$个点最多确定一个$n-1$次多项式。 所以说，一个$n-1$次多项式与它的曲线上的$n$个点的集合是等价的，而这个集合，叫做多项式的点值表达。 下面说点值表达是怎么优化多项式乘法的。]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5160」WD与循环]]></title>
    <url>%2F2019%2F01%2F01%2F%E3%80%8CLuogu-P5160%E3%80%8DWD%E4%B8%8E%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[给定$n,m$，求以下代码的运行结果：12345678910111213int cnt=0;for(register int a_1=0;a_1&lt;=m;a_1++)&#123; for(register int a_2=0;a_1+a_2&lt;=m;a_2++) &#123; ... for(register int a_n=0;a_1+a_2+...+a_n&lt;=m;a_n++) &#123; cnt=(cnt+1)%19491001; &#125; &#125;&#125;printf("%d\n", cnt); Solution先声明：$19491001$是质数！质数的日子一般都会发生大事，比如说以1开头的某个8位质数如同第一题一样，可以考虑爆搜出小样例。（程序是个坑）还是一样，设$(n,m)$表示循环个数为$n$，上界为$m$时的答案]]></content>
      <tags>
        <tag>组合数学</tag>
        <tag>找规律</tag>
        <tag>Lucas定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5159」WD与矩阵]]></title>
    <url>%2F2018%2F12%2F31%2F%E3%80%8CLuogu-P5159%E3%80%8DWD%E4%B8%8E%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[求有多少个$n\times m$的矩阵，使得每行每列异或值都是$0$。 Data Range：$T\leq 10^5,1\leq n,m\leq 10^9$ Solution先声明一下，$(n,m)$表示$n\times m$矩阵的答案，这里假定$n\leq m$，因为$(n,m)=(m,n)$。 不知道有没有人在看到这题的时候想到了NOIP 2018的填数游戏，按照这个思路，可以写一个爆搜跑一下小数据，这里记录一下我得到的小数据的答案： $(2,2)=2,(2,3)=4,(2,4)=8,(2,5)=16,(2,6)=32\cdots$ $(3,3)=16,(3,4)=64,(3,5)=256,(3,6)=1024\cdots$ $(4,4)=512,(4,5)=4096,(4,6)=32768\cdots$ $(5,5)=65536\cdots$ 首先考虑$(n,m)\div (n,m-1)$，把这个值记为$\operatorname{grow}(n)$，于是有： $\operatorname{grow}(2)=2,\operatorname{grow}(3)=4,\operatorname{grow}(4)=8,\operatorname{grow}(5)=16\cdots$ 所以$\operatorname{grow}(n)=2^{n-1}$。 接下来算$(n,n)$，有： $(2,2)=2,(3,3)=16,(4,4)=512,(5,5)=65536$。 乍一看，没什么规律，所以将这些式子变个形： $(2,2)=2^1,(3,3)=2^4,(4,4)=2^9,(5,5)=2^{16}\cdots$ 啊哈！这样就有规律啦qwq！ 于是就有$(n,n)=2^{(n-1)^2}$ 综上，可以得出$(n,m)\equiv 2^{(n-1)^2}\times(2^{n-1})^{m-n}$。 于是就可以用快速幂做啦qwq。 但是这样子$\texttt{Subtask 3}$会TLE，所以考虑优化。 不是有欧拉定理吗？ 所以说可以把$(n-1)^2$模个$\varphi(998244353)=998244352$，就可以完结撒花啦qwq！ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MOD=998244353;ll test,length,width,base,grow;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; if(!exponent) &#123; return 1; &#125; ll temp=qpow(base,exponent&gt;&gt;1,mod),res=temp*temp%mod; if(exponent&amp;1) &#123; res=res*base%mod; &#125; return res;&#125;int main()&#123; test=read(); for(register int i=0;i&lt;test;i++) &#123; length=read(),width=read(); if(length&gt;width) &#123; swap(length,width); &#125; base=qpow(2,(length-1)*(length-1)%(MOD-1),MOD); grow=qpow(2,length-1,MOD); printf("%lld\n",base*qpow(grow,width-length,MOD)%MOD); &#125;&#125;]]></content>
      <tags>
        <tag>打表</tag>
        <tag>找规律</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5110」块速递推]]></title>
    <url>%2F2018%2F12%2F28%2F%E3%80%8CLuogu-P5110%E3%80%8D%E5%9D%97%E9%80%9F%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[给定一个数列$a$，满足如下递推式： $a_n=233a_{n-1}+666a_{n-2}$。 求出这个数列第$n$项$a_n\bmod 10^9+7$的值，一共有$T$组数据，为了减少输出量，请输出这些答案的异或和。 Data Range：$T\leq 5\times 10^7,0\leq n&lt;2^{64}$ 11 Solution首先求$a_n=233a_{n-1}+666a_{n-2}$的通项式。 考虑这个数列的特征方程，为$x^2=233x+666$，于是解出$x_1=\cfrac{233+\sqrt{56953}}{2},x_2=\cfrac{233-\sqrt{56953}}{2}$。 所以可以设这个数列的通项式为$a_n=p(\cfrac{233+\sqrt{56953}}{2})^n+q(\cfrac{233-\sqrt{56953}}{2})^n$。 可别忘了，$a_0=0,a_1=1$，所以解出$p=\cfrac{1}{\sqrt{56953}},q=-\cfrac{1}{\sqrt{56953}}$。 所以$a_n=\cfrac{1}{\sqrt{56953}}[(\cfrac{233+\sqrt{56953}}{2})^n-(\cfrac{233-\sqrt{56953}}{2})^n]$ 现在来解决除号以及根号。首先，枚举得$\sqrt{56953}\equiv 188305837\pmod {10^9+7}$。 所以说 a_n=\cfrac{1}{188305037}(94153035^n-905847205^n)$ 而$188305837^{-1}\equiv 233230706\pmod {10^9+7}所以，最终的通项式就是 a_n=233230706(94153035^n-905847205^n)。 但是，由于毒瘤出题人的毒瘤给分制度，前面六个点每点$1 pts$，所以用龟速幂只能水$6 pts$。我尝试用$O(1)$的按位龟速乘优化了一下后，还是只有$6 pts$。看来我们只能优化计算上面的两个幂的过程。 很明显可以先优化一下指数，由欧拉定理得： $a_{n+\varphi(10^9+7)}\equiv a_n\pmod {10^9+7}$ 于是可以把指数模$\varphi(10^9+7)=10^9+6$，但是还是只能得$6 pts$。 于是考虑$100 pts$的分块打表大法。由上面的结论可知，可以将指数控制在$10^9+6$以内，所以可以考虑分块打表。 可以知道，$\lceil\sqrt{10^9+6}\rceil=31623$，所以以这个数作为块长分块，将它记为$k$。 首先，预处理出 $94153035^0,94153035^1\cdots 94153035^{k-1}$ 和$905847205^0,905847205^1\cdots 905847205^{k-1}$ 然后，用龟速幂可算出 $94153035^k\equiv 37348318\pmod {10^9+7}$，$905847205^k\equiv 482464047\pmod {10^9+7}$ 最后，预处理出 $94153035^k,94153035^2k\cdots 94153035^{k(k-1)}$ 和$905847205^k,905847205^k\cdots 905847205^{k(k-1)}$ 显然，这些步骤的时间复杂度为$O(k)$的。 把询问$m$拆成$ak+b$的形式，其中$0\leq b\leq k-1$。用数学化的语言来讲，$a=\lfloor \frac{m}{k}\rfloor,b=m\bmod k$，所以可以拆成整块和散块来做到$O(1)$查询啦qwq。 时间复杂度为$O(T+\sqrt{10^9+6})$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long int ll;const ll MAXN=31651,MOD=1e9+7,blockSize=31623;ll test,num,res,resx,resy;ll blockx[MAXN],powx[MAXN],blocky[MAXN],powy[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void setup()&#123; blockx[0]=powx[0]=blocky[0]=powy[0]=1; for(register int i=1;i&lt;blockSize;i++) &#123; blockx[i]=blockx[i-1]*37348318ull%MOD; blocky[i]=blocky[i-1]*482464047ull%MOD; powx[i]=powx[i-1]*94153035ll%MOD; powy[i]=powy[i-1]*905847205ll%MOD; &#125;&#125;namespace maker&#123; ll sa,sb,sc; inline void setup() &#123; sa=read(),sb=read(),sc=read(); &#125; inline ll randInt() &#123; sa^=sa&lt;&lt;32,sa^=sa&gt;&gt;13,sa^=sa&lt;&lt;1; ll t=sa; sa=sb,sb=sc,sc^=t^sa; return sc; &#125;&#125;int main()&#123; test=read(); maker::setup(),setup(); for(register int i=0;i&lt;test;i++) &#123; num=maker::randInt()%(MOD-1); resx=blockx[num/blockSize]*powx[num%blockSize]%MOD; resy=blocky[num/blockSize]*powy[num%blockSize]%MOD; res^=(233230706*((resx-resy+MOD)%MOD)%MOD); &#125; printf("%llu",res);&#125;]]></content>
      <tags>
        <tag>打表</tag>
        <tag>数论，数学</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5104」红包发红包]]></title>
    <url>%2F2018%2F12%2F27%2F%E3%80%8CLuogu-P5104%E3%80%8D%E7%BA%A2%E5%8C%85%E5%8F%91%E7%BA%A2%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一个$w$元钱的红包，有$n$个人抢，求第$k$个人抢的钱的期望。 题解先来看一个引理：$\mathbf{Lemma}\quad$在$l$到$r$中随机选一个实数的期望为$\frac{l+r}{2}$。$\mathbf{Proof:}$采用切片法。由于实数密度的均匀性，可以考虑做极限。考虑将$l$到$r$的实数区间均匀的切$i-1$片，出现$i$个端点，于是对这些数求期望。那么这些数的期望是：$\cfrac{nl+(r-l)\sum\limits_{i=0}^{n-1}\frac{i}{n-1}}{n}$$=l+\cfrac{(r-l)\frac{n}{2}}{n}$$=l+\cfrac{r-l}{2}$$=\cfrac{l+r}{2}$所以，这东西与$i$没任何关系，求极限还是这个值，证毕。回到本题。于是可以知道，第一个人抢的钱的期望是$\frac{w}{2}$，剩下$\frac{w}{2}$元。]]></content>
      <tags>
        <tag>数论，数学</tag>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3690」【模板】Link Cut Tree （动态树）]]></title>
    <url>%2F2018%2F12%2F22%2F%E3%80%8CLuogu-P3690%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91Link-Cut-Tree-%EF%BC%88%E5%8A%A8%E6%80%81%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[给定$n$个点以及它们的点权，要求写一种数据结构支持以下操作：求$x$到$y$路径上点权的$operatorname{xor}$和，连接或删除一条边，以及修改某个点的点权。 链接题解一道LCT裸题。坑。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=3e5+51;ll cnt,qcnt,op,x,y;ll num[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;namespace LCT&#123; struct Node&#123; ll fa,val,tag; ll ch[2]; &#125;; struct LinkCutTree&#123; Node nd[MAXN]; ll st[MAXN]; inline bool nroot(ll x) &#123; return nd[nd[x].fa].ch[0]==x||nd[nd[x].fa].ch[1]==x; &#125; inline void update(ll x) &#123; nd[x].val=nd[nd[x].ch[0]].val^nd[nd[x].ch[1]].val^num[x]; &#125; inline void reverse(ll x) &#123; swap(nd[x].ch[0],nd[x].ch[1]),nd[x].tag^=1; &#125; inline void spread(ll x) &#123; if(nd[x].tag) &#123; if(nd[x].ch[0]) &#123; reverse(nd[x].ch[0]); &#125; if(nd[x].ch[1]) &#123; reverse(nd[x].ch[1]); &#125; nd[x].tag=0; &#125; &#125; inline void rotate(ll x) &#123; ll fa=nd[x].fa,gfa=nd[fa].fa; ll dir=nd[fa].ch[1]==x,son=nd[x].ch[!dir]; if(nroot(fa)) &#123; nd[gfa].ch[nd[gfa].ch[1]==fa]=x; &#125; nd[x].ch[!dir]=fa,nd[fa].ch[dir]=son; if(son) &#123; nd[son].fa=fa; &#125; nd[fa].fa=x,nd[x].fa=gfa; update(fa); &#125; inline void splay(ll x) &#123; ll fa=x,gfa,cur=0; st[++cur]=fa; while(nroot(fa)) &#123; st[++cur]=fa=nd[fa].fa; &#125; while(cur) &#123; spread(st[cur--]); &#125; while(nroot(x)) &#123; fa=nd[x].fa,gfa=nd[fa].fa; if(nroot(fa)) &#123; rotate((nd[fa].ch[0]==x)^(nd[gfa].ch[0]==fa)?x:fa); &#125; rotate(x); &#125; update(x); &#125; inline void access(ll x) &#123; for(register int i=0;x;x=nd[i=x].fa) &#123; splay(x),nd[x].ch[1]=i,update(x); &#125; &#125; inline void makeRoot(ll x) &#123; access(x),splay(x),reverse(x); &#125; inline ll findRoot(ll x) &#123; access(x),splay(x); while(nd[x].ch[0]) &#123; spread(x),x=nd[x].ch[0]; &#125; return x; &#125; inline void split(ll x,ll y) &#123; makeRoot(x),access(y),splay(y); &#125; inline void link(ll x,ll y) &#123; makeRoot(x); if(findRoot(y)!=x) &#123; nd[x].fa=y; &#125; &#125; inline void cut(ll x,ll y) &#123; makeRoot(x); if(findRoot(y)==x&amp;&amp;nd[x].fa==y&amp;&amp;!nd[x].ch[1]) &#123; nd[x].fa=nd[y].ch[0]=0; update(y); &#125; &#125; &#125;;&#125;LCT::LinkCutTree lct;int main()&#123; cnt=read(),qcnt=read(); for(register int i=1;i&lt;=cnt;i++) &#123; num[i]=read(); &#125; for(register int i=0;i&lt;qcnt;i++) &#123; op=read(),x=read(),y=read(); if(!op) &#123; lct.split(x,y); printf("%d\n",lct.nd[y].val); &#125; if(op==1) &#123; lct.link(x,y); &#125; if(op==2) &#123; lct.cut(x,y); &#125; if(op==3) &#123; lct.splay(x),num[x]=y; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
        <tag>模板</tag>
        <tag>Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4289」[HAOI2008]移动玩具]]></title>
    <url>%2F2018%2F12%2F19%2F%E3%80%8CLuogu-P4289%E3%80%8D-HAOI2008-%E7%A7%BB%E5%8A%A8%E7%8E%A9%E5%85%B7%2F</url>
    <content type="text"><![CDATA[给定两个$4\times 4$的$01$矩阵，第一个是初始矩阵，另一个是目标矩阵，每一次可以交换两个相邻的元素，求最少的操作使得初始矩阵可以变换到目标矩阵。 链接Luogu P4289BZOJ 1054]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>洛谷</tag>
        <tag>HAOI</tag>
        <tag>各省省选</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各省省选题选刷]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89%E9%A2%98%E9%80%89%E5%88%B7%2F</url>
    <content type="text"><![CDATA[蒟蒻Karry5307退役失败，只能继续努力啦qwq最近在做省选题明明是BZOJ第一版的，所以说大致是按照省份刷的我这种蒟蒻只配做老年省选题……这里放一下最近做的题，按省份和年代特别久远排列，加上几句话题解…… 这里放洛谷和BZOJ的题号HAOI2008「Luogu P1450 BZOJ 1042」 [HAOI2008]硬币购物「Luogu P2508 BZOJ 1041」 [HAOI2008]圆上的整点对$r^2$做分解质因数，对每一个质因子计算对答案的贡献即可。 「Luogu P2510 BZOJ 1043」 [HAOI2008]下落的圆盘「Luogu P2511」「Luogu P2512」「Luogu P4289 BZOJ 1054」 [HAOI2008]移动玩具「Luogu P4290」「Luogu P4291」 JSOI2008「Luogu P1197 BZOJ 1015」「Luogu P1198 BZOJ 1012」「Luogu P4035 BZOJ 1013」]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>洛谷</tag>
        <tag>各省省选</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2508」[HAOI2008]圆上的整点]]></title>
    <url>%2F2018%2F12%2F16%2F%E3%80%8CLuogu-P2508%E3%80%8D-HAOI2008-%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[给定$r$，求满足$x^2+y^2=r^2$的整数对$(x,y)$个数量。 链接Luogu P2508BZOJ 1041CodeVS 1867 前置知识首先引入虚数单位$\mathrm{i}$，表示$\sqrt{-1}$，将$a+b\mathrm{i},a,b\in\mathbb{R}$型的数称为复数（其中$a\in\mathbb{R}$表示$a$为实数）。所以说可以规定一些运算。$a+b\mathrm{i}\pm c+d\mathrm{i}=(a\pm b)+(c\pm d)\mathrm{i}$$(a+b\mathrm{i})(c+d\mathrm{i})=(ac-bd)+(ad+bc)\mathrm{i}$其中，称$a+b\mathrm{i}$的复共轭为$a-b\mathrm{i}$。每一个坐标$(x,y)$，又可以唯一对应到一个复数$x+y\mathrm{i}$，于是将这种一个坐标表示一个复数的平面直角坐标系叫做复平面。对于复平面上的格点$(x,y)$，可以对应到复数$x+y\mathrm{i}$，将这类复数叫做高斯整数。说白了，高斯整数就是满足$a,b$是整数的$a+b\mathrm{i}$型数。而不能再次被分解的数就是高斯素数。比如说，$5$不是高斯素数，因为$5=5+0\mathrm{i}=(2+\mathrm{i})(2-\mathrm{i})$，而分解出的$2+\mathrm{i}$和$2-\mathrm{i}$都是高斯素数。 题解一道码量不长，但是数学知识需求挺多的一道题。先转换一下所给的方程，改成$x^2-(y\mathrm{i})^2=r^2$。拆开可得$(x+y\mathrm{i})(x-y\mathrm{i})=r^2$。而两个括号内互为复共轭，所以只需要解决这个问题，即有多少个$x+y\mathrm{i}$使得它成它的复共轭为$r^2$。这里举个栗子，比如说手玩$r=5$的情况，要先将$r^2$拆成高斯素数的乘积。$25=5^2=(2+\mathrm{i})(2-\mathrm{i})(2+\mathrm{i})(2-\mathrm{i})$在将这些高斯素数分成两列，其中第一列的第$n$个数和第二列的第$n$个数互为复共轭，最后算出来有多少种组合方式。但是这些组合方式满足左边的乘积与右边的乘积互为复共轭吗？答案是显然的，先证明两个高斯整数的乘积与它们的复共轭的乘积互为复共轭。考虑这两个数的乘积，$(a+b\mathrm{i})(c+d\mathrm{i})=(ac-bd)+(ad+bc)\mathrm{i}$。它们的复共轭的乘积，$(a-b\mathrm{i})(c-d\mathrm{i})=(ac-bd)-(ad+bc)\mathrm{i}$。啊哈！它们正好互为复共轭，所以左边的乘积与右边的乘积互为复共轭。但是，还不够。要把答案乘上$4$才行，因为两列数的乘积可以同时乘上$1$或$-1$，或一个乘以$\mathrm{i}$，另一个乘以$-\mathrm{i}$都不改变两列乘起来后两个数的乘积，所以有$4$种变换，所以算出来是$12$。现在来看一般情况。对$r^2$做质因数分解，有$r^2={p_1}^{r_1}{p_2}^{r_2}\cdots {p_k}^{r_k}$。假设现在考虑到$p_i$了（这个$i$与虚数单位的字体不一样），那么……如果$p_i\equiv 1\pmod 4$，那么这个可以分解成两个高斯素数的乘积。这个因子对格点数目点的影响为$r_i+1$，因为可以在左边放$0,1\cdots r_i$个分解后的高斯素数中的一种。如果$p_i\equiv 3\pmod 4$，那么$p_i$本身是高斯素数，对分解的贡献取决于$r_i$，如果$r_i$是奇数，那么这个多出来的因子没地方放，它会使得两边不平衡，没有格点，否则，它可以放两边，对格点个数没有贡献。如果$p_i$为$2$，那么有$2=(1+\mathrm{i})(1-\mathrm{i})$，而这两个复数刚好是旋转$90^{\circ}$的，所以变换少了$2$种，但是带来$2$中组合，对格点个数没有贡献。所以，这个算法只需要分解质因数，然后判断即可。不懂的可以看看这个视频 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=5e4+51;ll r,tot,res=1;ll factor[MAXN],cnt[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void getFact(ll num)&#123; for(register int i=2;i&lt;=num;i++) &#123; if(num==1) &#123; break; &#125; if(num%i==0) &#123; factor[tot]=i; while(num%i==0) &#123; cnt[tot]+=2,num/=i; &#125; tot++; &#125; &#125;&#125;int main()&#123; getFact(r=read()); for(register int i=0;i&lt;tot;i++) &#123; if((factor[i]&amp;3)==1) &#123; res*=(cnt[i]+1); &#125; if((factor[i]&amp;3)==3) &#123; res*=((cnt[i]&amp;1)^1); &#125; &#125; printf("%lld",res&lt;&lt;2);&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>洛谷</tag>
        <tag>HAOI</tag>
        <tag>各省省选</tag>
        <tag>CodeVS</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4084」[USACO17DEC]Barn Painting]]></title>
    <url>%2F2018%2F12%2F13%2F%E3%80%8CLuogu-P4084%E3%80%8D-USACO17DEC-Barn-Painting%2F</url>
    <content type="text"><![CDATA[咕着先…… 前言开始写题解的今天，正是$12$月$13$日。今天，是南京大屠杀的$81$周年的纪念日。$81$年前，即$1937$年$12$月$13$日。日本侵略者在南京制造了震惊中外的南京大屠杀惨案。这是中华民族的血泪史，饱含着中华人民对日本侵略者的仇恨。现在，我们生活在伟大富强的新中国，与现代的日本作为隔海相望的邻邦，历史的悲剧已平和下来，但是我们不能忘记这次国家的耻辱。所以，我们要以史为鉴，吸取教训，努力学习，奋发图强，不让历史悲剧再次重演。 代码]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>USACO</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2234」[HNOI2002]营业额统计]]></title>
    <url>%2F2018%2F12%2F03%2F%E3%80%8CLuogu-P2234%E3%80%8D-HNOI2002-%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[给定一个数列$a$，对于$a_i$，寻找一个$a_j$使得$i&gt;j$且$\vert a_i-a_j\vert$最小。 题解一道近乎Splay裸题的题。很显然可以将最小的$\vert a_i-a_j\vert$拆成$a_i$与其前驱的差和与其后继的差的最小值。所以说就可以用Splay维护啦qwq。论手贱，你是比不过我的，今天又把while打成if啦 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=4e4+51,inf=0x3f3f3f3f;ll cnt,num,res,prv,nxt;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;namespace Splay&#123; struct Node&#123; ll fa,val,size,temp; ll ch[2]; inline void reset(ll val=0,ll fa=0) &#123; this-&gt;fa=fa,this-&gt;val=val,this-&gt;temp=this-&gt;size=1; this-&gt;ch[0]=this-&gt;ch[1]=0; &#125; &#125;; struct Splay&#123; ll tot,root; Node nd[MAXN]; inline bool id(ll x) &#123; return nd[nd[x].fa].ch[1]==x; &#125; inline void update(ll x) &#123; nd[x].size=nd[nd[x].ch[0]].size+nd[nd[x].ch[1]].size+nd[x].temp; &#125; inline void connect(ll x,ll fa,ll dir) &#123; nd[x].fa=fa,nd[fa].ch[dir]=x; &#125; inline void rotate(ll x) &#123; ll fa=nd[x].fa,gfa=nd[fa].fa,dir=id(x); connect(x,gfa,id(fa)); connect(nd[x].ch[dir^1],fa,dir); connect(fa,x,dir^1); update(fa),update(x); &#125; inline void splay(ll cur,ll target) &#123; while(nd[cur].fa!=target) &#123; ll fa=nd[cur].fa,gfa=nd[fa].fa; if(gfa!=target) &#123; rotate(id(cur)^id(fa)?cur:fa); &#125; rotate(cur); &#125; if(!target) &#123; root=cur; &#125; &#125; inline void insert(ll val) &#123; ll cur=root,fa=0; while(cur&amp;&amp;nd[cur].val!=val) &#123; fa=cur,cur=nd[cur].ch[val&gt;nd[cur].val]; &#125; if(cur) &#123; nd[cur].temp++; &#125; else &#123; cur=++tot; if(fa) &#123; nd[fa].ch[val&gt;nd[fa].val]=cur; &#125; nd[cur].reset(val,fa); &#125; splay(cur,0); &#125; inline void find(ll val) &#123; ll cur=root; if(!cur) &#123; return; &#125; while(nd[cur].ch[val&gt;nd[cur].val]&amp;&amp;val!=nd[cur].val) &#123; cur=nd[cur].ch[val&gt;nd[cur].val]; &#125; splay(cur,0); &#125; inline ll prev(ll val) &#123; find(val); ll cur=root; if(nd[cur].val&lt;=val) &#123; return nd[cur].val; &#125; cur=nd[cur].ch[0]; while(nd[cur].ch[1]) &#123; cur=nd[cur].ch[1]; &#125; return nd[cur].val; &#125; inline ll next(ll val) &#123; find(val); ll cur=root; if(nd[cur].val&gt;=val) &#123; return nd[cur].val; &#125; cur=nd[cur].ch[1]; while(nd[cur].ch[0]) &#123; cur=nd[cur].ch[0]; &#125; return nd[cur].val; &#125; &#125;;&#125;Splay::Splay splay;int main()&#123; cnt=read(); splay.insert(inf),splay.insert(-inf); splay.insert(res=read()); for(register int i=1;i&lt;cnt;i++) &#123; num=read(); prv=splay.prev(num),nxt=splay.next(num); res+=min(num-prv,nxt-num); splay.insert(num); &#125; printf("%d",res);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>各省省选</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·平衡树]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡树是一种使用较为广泛的数据结构，代码比较长。 SplaySplay最主要的一点是它能反转区间，而Treap以及替罪羊不能，这也是为什么它作为Link Cut Tree的辅助树。 框架首先需要写一个这样的程序框架：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define DEBUG printf("In function %s, line %d\n",__FUNCTION__,__LINE__)using namespace std;typedef int ll;const ll MAXN=2e5+51;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;ll cnt,qcnt,l,r;namespace Splay&#123; struct Node&#123; ll fa,val,size,tag; ll ch[2]; &#125;; struct Splay&#123; ll tot,root; Node nd[MAXN]; //Code goes here &#125;;&#125; 以下代码片段全部接在注释处。 基本操作首先是$update$，用于更新节点的$size$。既然写过线段树，那么这个操作应该不难。1234inline void update(ll x)&#123;nd[x].size=nd[nd[x].ch[0]].size+nd[nd[x].ch[1]].size+1;&#125; 接下来是$id$，用于判断一个节点是它的父亲的哪一个孩子。这个很简单，只需要几行代码。1234inline bool id(ll x)&#123; return nd[nd[x].fa].ch[1]==x;&#125; 下一个是$connect$，用于建立新的父子关系，这个也不难。1234inline void connect(ll x,ll fa,ll dir)&#123; nd[x].fa=fa,nd[fa].ch[dir]=x;&#125; 关键操作以下两个操作是旋转操作，很关键，而且不好调。首先是$rotate$，用于平衡旋转。举个栗子，这是原来的平衡树。其中蓝色指向父亲，红色指向儿子。调用$rotate(y)$之后，平衡树就变成这个样子了：由于之前$connect$的实现，这个就变得不难了，因为旋转依次要改变$3$对父子关系。第一对，对照第二幅图可以发现，可以直接在$y$与$R$建立关系，就像这样第二对，在$B$与$x$之间建立父子关系，然后就变成了这个最后，在$x$与$y$建立父子关系就大功告成啦qwq。所以，上代码12345678inline void rotate(ll x)&#123; ll fa=nd[x].fa,gfa=nd[fa].fa,dir=id(x); connect(x,gfa,id(fa)); connect(nd[x].ch[dir^1],fa,dir); connect(fa,x,dir^1); update(fa),update(x);&#125; 还有一个是$splay$，这个尽管代码不长，但是很难调。我不推荐直接上旋，因为这样可能会很慢。12345678910111213141516inline void splay(ll cur,ll target)&#123; while(nd[cur].fa!=target) &#123; ll fa=nd[cur].fa,gfa=nd[fa].fa; if(gfa!=target) &#123; rotate(id(cur)^id(fa)?cur:fa); &#125; rotate(cur); &#125; if(!target) &#123; root=cur; &#125;&#125; 一些特例]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3391」【模板】文艺平衡树（Splay）]]></title>
    <url>%2F2018%2F11%2F30%2F%E3%80%8CLuogu-P3391%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88Splay%EF%BC%89%2F</url>
    <content type="text"><![CDATA[给一个$1$到$n$的排列，每一次能将区间$[l,r]$反转，求最后的排列 链接题解实测暴力能Rush\ 48pts，但是不能用暴力，只能老老实实写Splay。作为一道模板题，还是说一下我犯过的错误吧qwq。第一，$splay$函数中旋转完了一定要更新$fa$和$x$的信息，由于这个，我居然调了一下午+一晚上。第二，注意$reverse$中更新信息的语句，又调了一中午。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;#define DEBUG printf("In function %s, line %d\n",__FUNCTION__,__LINE__)using namespace std;typedef int ll;const ll MAXN=2e5+51;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;ll cnt,qcnt,l,r;namespace Splay&#123; struct Node&#123; ll fa,val,size,tag; ll ch[2]; inline void reset(ll val=0,ll fa=0) &#123; this-&gt;fa=fa,this-&gt;val=val,this-&gt;size=1; this-&gt;tag=this-&gt;ch[0]=this-&gt;ch[1]=0; &#125; &#125;; struct Splay&#123; ll tot,root; Node nd[MAXN]; inline bool id(ll x) &#123; return nd[nd[x].fa].ch[1]==x; &#125; inline void update(ll x) &#123; nd[x].size=nd[nd[x].ch[0]].size+nd[nd[x].ch[1]].size+1; &#125; inline void spread(ll x) &#123; if(nd[x].tag) &#123; nd[nd[x].ch[0]].tag^=1,nd[nd[x].ch[1]].tag^=1; nd[x].tag=0; swap(nd[x].ch[0],nd[x].ch[1]); &#125; &#125; inline void connect(ll x,ll fa,ll dir) &#123; nd[x].fa=fa,nd[fa].ch[dir]=x; &#125; inline void rotate(ll x) &#123; ll fa=nd[x].fa,gfa=nd[fa].fa,dir=id(x); connect(x,gfa,id(fa)); connect(nd[x].ch[dir^1],fa,dir); connect(fa,x,dir^1); update(fa),update(x); &#125; inline void splay(ll cur,ll target) &#123; while(nd[cur].fa!=target) &#123; ll fa=nd[cur].fa,gfa=nd[fa].fa; if(gfa!=target) &#123; rotate(id(cur)^id(fa)?cur:fa); &#125; rotate(cur); &#125; if(!target) &#123; root=cur; &#125; &#125; inline void insert(ll val) &#123; ll cur=root,fa=0; while(cur) &#123; fa=cur,cur=nd[cur].ch[val&gt;nd[cur].val]; &#125; cur=++tot; if(fa) &#123; nd[fa].ch[val&gt;nd[fa].val]=cur; &#125; nd[cur].reset(val,fa); splay(cur,0); &#125; inline ll findVal(ll rk) &#123; ll cur=root; while(1) &#123; spread(cur); if(nd[nd[cur].ch[0]].size&gt;=rk) &#123; cur=nd[cur].ch[0]; &#125; else &#123; if(nd[nd[cur].ch[0]].size+1==rk) &#123; return cur; &#125; else &#123; rk-=nd[nd[cur].ch[0]].size+1,cur=nd[cur].ch[1]; &#125; &#125; &#125; &#125; inline void reverse(ll l,ll r) &#123; l=findVal(l),r=findVal(r+2); splay(l,0),splay(r,l); nd[nd[nd[root].ch[1]].ch[0]].tag^=1; &#125; inline void op(ll cur) &#123; spread(cur); if(nd[cur].ch[0]) &#123; op(nd[cur].ch[0]); &#125; if(nd[cur].val&gt;1&amp;&amp;nd[cur].val&lt;cnt+2) &#123; printf("%d ",nd[cur].val-1); &#125; if(nd[cur].ch[1]) &#123; op(nd[cur].ch[1]); &#125; &#125; &#125;;&#125;Splay::Splay splay;int main()&#123; cnt=read(),qcnt=read(); for(register int i=1;i&lt;=cnt+2;i++) &#123; splay.insert(i); &#125; for(register int i=0;i&lt;qcnt;i++) &#123; l=read(),r=read(); splay.reverse(l,r); &#125; splay.op(splay.root);&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>洛谷</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SP1043」Can you answer these queries I]]></title>
    <url>%2F2018%2F11%2F29%2F%E3%80%8CSP1043%E3%80%8DCan-you-answer-these-queries-I%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3701」「伪模板」主席树]]></title>
    <url>%2F2018%2F11%2F29%2F%E3%80%8CLuogu-P3701%E3%80%8D%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[A和B有五种不同的人物，共$n$个，两人之间要比$m$场。A的的$i$个人物的寿命为$hpA_i$，B的为$hpB_i$。每一次A和B选出不同的人物进行PK，每一次PK使得两边人物的寿命$-1s$，当寿命为$0$时就不能比赛了，两个人之间只能比一场。同时，当J的寿命为$0$时，同一棵树上的YYY可以为他$+1s$。每个YYY只能给每个J续一次，最大化A能赢的场次的数目。 题解一个比较巧妙的网络流建模题。首先打出人物之间输赢的表，然后考虑从源点像A的第$i$个人物连边，容量为$hpA_i$，从B的第$i$个人物像汇点连边，容量为$hpB_i$。以上连边，如果第$i$个人是J，则将容量增加本方YYY的数量。对于A的第$i$个人能赢B的第$j$个人，就从A的第$i$个人向B的第$j$个人A的人连边，容量为$1$。跑一边最大流即可。下面分析为什么这样连边是对的。先不考虑续命，这个人物不能出战即找不到经过这个人物的增广路，而通过这个人物的增广路只能是从源点直接到这个人物再到后面或是前面找到的增广路到这个人物再到汇点。以上这句话很重要，请仔细理解。所以，当源点到这个人物或这个人物到汇点的边为零流边就找不到增广路了，即这个人没命了。所以从源点发出或到汇点连边是正确的。由于两个人之间只能比一场，而题目要求只求胜利场次数，所以中间的连边也是正确的。现在考虑续命。对于一个J，无论YYY是死是活，总能在它死的时候续命，对于每一个J都是一样。所以将从源点连到J的边或是J连到汇点的边的容量增加本方YYY的个数。至此，连边的正确性就已经说明清楚了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e5+51,inf=0x7fffffff;struct Edge&#123; ll to,prev,flow;&#125;;Edge ed[MAXN&lt;&lt;1];map&lt;string,ll&gt;mp;ll nc,ec,source,sink,tot=1,from,to,flow,maxFlow;ll cnt,ccnt,life,xx,yy;ll last[MAXN],depth[MAXN],inQueue[MAXN];ll win[5][5]=&#123; 0,0,0,1,1, 1,0,1,0,0, 1,0,0,1,0, 0,1,0,0,1, 0,1,1,0,0&#125;;string x[151],y[151];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to,ll flow)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; ed[tot].flow=flow; last[from]=tot; &#125;inline ll Min(ll x,ll y)&#123; return x&lt;y?x:y;&#125;inline bool bfs()&#123; queue&lt;ll&gt;q; ll top,to; memset(depth,0x3f,sizeof(depth)); depth[source]=0,q.push(source); while(!q.empty()) &#123; top=q.front(); q.pop(),inQueue[top]=0; for(register int i=last[top];i;i=ed[i].prev) &#123; to=ed[i].to; if(depth[to]&gt;depth[top]+1&amp;&amp;ed[i].flow) &#123; depth[to]=depth[top]+1; if(!inQueue[to]) &#123; q.push(to),inQueue[to]=1; &#125; &#125; &#125; &#125; if(depth[sink]!=0x3f3f3f3f) &#123; return 1; &#125; return 0;&#125;inline ll dfs(ll cur,ll flow)&#123; ll low; if(cur==sink) &#123; return flow; &#125; for(register int i=last[cur];i;i=ed[i].prev) &#123; if(ed[i].flow&amp;&amp;depth[ed[i].to]==depth[cur]+1) &#123; if(low=dfs(ed[i].to,Min(flow,ed[i].flow))) &#123; ed[i].flow-=low,ed[i^1].flow+=low; return low; &#125; &#125; &#125; return 0;&#125;inline ll Dinic()&#123; ll flow; while(bfs()) &#123; while(flow=dfs(source,inf)) &#123; maxFlow+=flow; &#125; &#125; return maxFlow;&#125;int main()&#123; cnt=read(),ccnt=read(); nc=sink=(cnt+1)&lt;&lt;1,source=1; mp["J"]=0,mp["E"]=1,mp["YYY"]=2,mp["HK"]=3,mp["W"]=4; for(register int i=1;i&lt;=cnt;i++) &#123; cin&gt;&gt;x[i]; xx+=(x[i]=="YYY"); &#125; for(register int i=1;i&lt;=cnt;i++) &#123; cin&gt;&gt;y[i]; yy+=(y[i]=="YYY"); &#125; for(register int i=2;i&lt;=cnt+1;i++) &#123; life=read(); addEdge(source,i,life+(x[i-1]=="J"?xx:0)),addEdge(i,source,0); &#125; for(register int i=2;i&lt;=cnt+1;i++) &#123; life=read(); addEdge(i+cnt,sink,life+(y[i-1]=="J"?yy:0)),addEdge(sink,i+cnt,0); &#125; for(register int i=1;i&lt;=cnt;i++) &#123; xx=mp[x[i]]; for(register int j=1;j&lt;=cnt;j++) &#123; yy=mp[y[j]]; if(win[xx][yy]) &#123; addEdge(i+1,j+1+cnt,1),addEdge(j+1+cnt,i+1,0); &#125; &#125; &#125; printf("%d",min(ccnt,Dinic()));&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 558E」A Simple Task]]></title>
    <url>%2F2018%2F11%2F24%2F%E3%80%8CCodeForces-558E%E3%80%8DA-Simple-Task%2F</url>
    <content type="text"><![CDATA[给定一个字符串，每次将一个子串排序，问最后的字符串是什么。 链接题解一个比较好的思维题。用线段树维护区间内$26$个字母的出现次数。对于排序，将区间内每个字母出现的次数查出来，然后一个一个遍历就好了。如果是升序就从小往大覆盖，反之从大往小覆盖就好了。时间复杂度$O(26n\log n)$这里常数不能省还有，最坑爹的一点是，线段树开$4\times 10^5$过不去，会RE #9，要开$8\times 10^5$…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e5+51;struct Occur&#123; ll num[28]; Occur() &#123; memset(this-&gt;num,0,sizeof(this-&gt;num)); &#125; inline bool operator !=(const ll &amp;rhs)const &#123; for(register int i=1;i&lt;=26;i++) &#123; if(num[i]!=rhs) &#123; return 1; &#125; &#125; return 0; &#125; inline void clear() &#123; memset(num,0,sizeof(num)); &#125;&#125;;struct SegmentTree&#123; ll l,r; Occur sum,cover;&#125;;SegmentTree tree[MAXN&lt;&lt;2];ll cnt,qcnt,l,r,x;char str[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline Occur operator +(Occur x,Occur y)&#123; Occur res; for(register int i=1;i&lt;=26;i++) &#123; res.num[i]=x.num[i]+y.num[i]; &#125; return res;&#125;inline Occur operator *(Occur x,ll y)&#123; Occur res; for(register int i=1;i&lt;=26;i++) &#123; res.num[i]=x.num[i]*y; &#125; return res;&#125;inline void update(ll node)&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum.num[str[l-1]-'a'+1]=1; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void spread(ll node)&#123; ll ls=node&lt;&lt;1,rs=ls|1; if(tree[node].cover!=0) &#123; tree[ls].sum=tree[node].cover*(tree[ls].r-tree[ls].l+1); tree[rs].sum=tree[node].cover*(tree[rs].r-tree[rs].l+1); tree[ls].cover=tree[node].cover; tree[rs].cover=tree[node].cover; tree[node].cover.clear(); &#125;&#125;inline void cover(ll l,ll r,Occur val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum=val*(tree[node].r-tree[node].l+1); tree[node].cover=val; return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; spread(node); if(l&lt;=mid) &#123; cover(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; cover(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline Occur query(ll l,ll r,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; Occur res; spread(node); if(l&lt;=mid) &#123; res=res+query(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; res=res+query(l,r,(node&lt;&lt;1)|1); &#125; return res;&#125;inline void sorts(ll l,ll r,ll cmp)&#123; ll cur=l; Occur val=query(l,r,1),curr; if(!cmp) &#123; for(register int i=1;i&lt;=26;i++) &#123; curr.num[i]=1,curr.num[i-1]=0; if(val.num[i]) &#123; cover(l,l+val.num[i]-1,curr,1); l=l+val.num[i]; &#125; &#125; &#125; else &#123; for(register int i=26;i;i--) &#123; curr.num[i]=1,curr.num[i+1]=0; if(val.num[i]) &#123; cover(l,l+val.num[i]-1,curr,1); l=l+val.num[i]; &#125; &#125; &#125;&#125;inline void spreadAll(ll node)&#123; spread(node); if(tree[node].l==tree[node].r) &#123; return; &#125; spreadAll(node&lt;&lt;1); spreadAll((node&lt;&lt;1)|1); update(node);&#125;inline void preorder(ll node)&#123; if(tree[node].l==tree[node].r) &#123; for(register int i=1;i&lt;=26;i++) &#123; if(tree[node].sum.num[i]) &#123; putchar((char)(i+'a'-1)); break; &#125; &#125; return; &#125; preorder(node&lt;&lt;1); preorder((node&lt;&lt;1)|1);&#125;int main()&#123; cnt=read(),qcnt=read(); scanf("%s",&amp;str); create(1,cnt,1); for(register int i=0;i&lt;qcnt;i++) &#123; l=read(),r=read(),x=read(); sorts(l,r,!x); &#125; spreadAll(1),preorder(1);&#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>线段树</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 501D」Misha and Permutations Summation]]></title>
    <url>%2F2018%2F11%2F19%2F%E3%80%8CCodeForces-501D%E3%80%8DMisha-and-Permutations-Summation%2F</url>
    <content type="text"><![CDATA[设$P$是一个长度为$n$的排列，定义$\operatorname{ord}P$为$P$在所有排列中的名次。给定两个长度为$n$的排列$P_1,P_2$，求第$\operatorname{ord}P_1+\operatorname{ord}P_2 \bmod n!$小的排列。 前置技能康托展开这里讲从排列映射到数的过程，还是假设这个排列长度为$n$。对于第$i$次操作，统计这个数后面有多少个比它小的数，记为$a_i$那么答案是$\sum_{i=1}^{n}a_i(n-i)!$ 题解这一个题和UVa 11525很像，不会做的可以参考一下本蒟蒻的题解，做法就是用一颗权值线段树维护全局没被放进排列中的第$k$小，所以做这个题可以先把它转化为上面那个题。首先把两个排列映射到整数，这里要统计后面有多少个比第$i$个数$a_i$小的数。如果暴力找的话是$O(n^2)$的。但是，可以发现排列是由$0,1\cdots n-1$组成的，那么排列里比这个数小的数的个数就是这个数。这句话不是很好懂，但是很重要。因为排列里比这个数$x$小的只有$0,1\cdots x-1$，共有$x$个，所以有$x$个数比$x$小。所以可以显然推出后面比$a_i$小的数的个$=$总共比$a_i$小的数$-$在$a_i$前面比$a_i$小的数。而排在前面比$a_i$小的数可以用树状数组维护。用一个树状数组维护第$i$个数是否出现过。对于当前的数，统计$1$到当前数$-1$中的和，就是在这个数前面比它小的数。所以说，可以用$O(n\log n)$的时间复杂度把$a_{P_1,i}$和$a_{P_2,i}$（$a$指的是前置技能里的$a$数组）求出来，记$S_i=a_{P_1,i}+a_{P_2,i}$。接下来化简$S$，由于$(x+1)\cdot x!=(x+1)!$，于是可以用这个性质化简$S_i$，使得$0\leq S_i\leq n-i$。具体方法是，对于$S_i$，$S_{i+1}+=S_i \% n-i,S_i\%=n-i$就可以简化$S$数组了。最后我们就把问题转化为上面的那个题了，用那个题的方法做就可以了qwq。时间复杂度$O(n\log n)$，常数不大除了权值线段树，跑了$2270$ms，拿了最优解qwq。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e5+51;struct BIT&#123; ll size; ll num[MAXN]; inline ll lowbit(ll x) &#123; return x&amp;-x; &#125; inline void add(ll pos,ll val) &#123; for(;pos&lt;=size;pos+=lowbit(pos)) &#123; num[pos]+=val; &#125; &#125; inline ll queryPrefix(ll pos) &#123; ll res=0; for(;pos;pos-=lowbit(pos)) &#123; res+=num[pos]; &#125; return res; &#125;&#125;;struct SegmentTree&#123; ll l,r,size;&#125;;BIT bit,bit2;SegmentTree tree[MAXN&lt;&lt;2];ll cnt,num;ll perm[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll node)&#123; tree[node].size=tree[node&lt;&lt;1].size+tree[(node&lt;&lt;1)|1].size;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].size=1; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline ll findVal(ll rk,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].size=0; return tree[node].l; &#125; ll res=0; if(rk&lt;=tree[node&lt;&lt;1].size) &#123; res=findVal(rk,node&lt;&lt;1); &#125; else &#123; res=findVal(rk-tree[node&lt;&lt;1].size,(node&lt;&lt;1)|1); &#125; update(node); return res;&#125;int main()&#123; bit.size=bit2.size=cnt=read(); for(register int i=1;i&lt;=cnt;i++) &#123; num=read(); perm[i]=num-bit.queryPrefix(num),bit.add(num+1,1); &#125; for(register int i=1;i&lt;=cnt;i++) &#123; num=read(); perm[i]+=num-bit2.queryPrefix(num),bit2.add(num+1,1); &#125; for(register int i=cnt,j=0;i;i--,j++) &#123; perm[i-1]+=perm[i]/(j+1),perm[i]%=(j+1); &#125; create(1,cnt,1); for(register int i=1;i&lt;=cnt;i++) &#123; printf("%d ",findVal(perm[i]+1,1)-1); &#125; &#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>CodeForces</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11525」Permutation]]></title>
    <url>%2F2018%2F11%2F18%2F%E3%80%8CUVa-11525%E3%80%8DPermutation%2F</url>
    <content type="text"><![CDATA[给定$n$个数$x_1,x_2\cdots x_n$，已知$S=\sum^{n}_{i=1}x_i(n-i)!$，求第$S$个排列 前置技能康托展开是一个比较常用的哈希技巧，可以将一个排列$a_1,a_2\cdots a_n$映射到一个整数$k$，这个整数$k$就是这个排列在所有排列中的名次。由于它是双射的，所以也可以从一个整数还原这个整数所对应的全排列。假定这个排列是由$n$个数组成的，那么有从一个整数$k$映射到第$k$小的排列的方法：将$k$写成$\sum^{n}_{i=1}x_i(n-i)!$的形式，其中对于任意$x_i$，有$0\leq x_i\leq i$。对于第$i$次操作，选择当前没有选过的第$x_i$大的数加入排列。进行第二步$n$次，所得的排列即为所求。 题解注意到，题目已经完成了第一步，所以只需要完成第二步就可以了。而数据范围$k\leq 5\times10^4$，所以要写一种高效的数据结构，支持区间第$k$小和删除一个数。这里用权值线段树实现，由于$1\leq x_i\leq n$（这里的变量都是值上面的题意而言的），所以不用离散化。于是查询变得很简单了，但删除呢？可以将这个数置为$0$，意思是被删除了。如果这个节点的值为$0$，那么整个子树都不复存在。这份代码还是跑的蛮快的，$60$ms。可还是没有最优解跑的快最后，此题卡输出格式，要像我这么写才能AC 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=5e4+51;struct SegmentTree&#123; ll l,r,size;&#125;;ll test,cnt,num;SegmentTree tree[MAXN&lt;&lt;2];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll node)&#123; tree[node].size=tree[node&lt;&lt;1].size+tree[(node&lt;&lt;1)|1].size;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].size=1; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125; inline ll findVal(ll rk,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].size=0; return tree[node].l; &#125; ll res; if(rk&lt;=tree[node&lt;&lt;1].size) &#123; res=findVal(rk,node&lt;&lt;1); &#125; else &#123; res=findVal(rk-tree[node&lt;&lt;1].size,(node&lt;&lt;1)|1); &#125; update(node); return res;&#125;int main()&#123; test=read(); for(register int i=0;i&lt;test;i++) &#123; cnt=read(); create(1,cnt,1); for(register int j=0;j&lt;cnt;j++) &#123; num=read()+1; printf("%d",findVal(num,1)); putchar(j==cnt-1?'\n':' '); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>组合数学</tag>
        <tag>UVa</tag>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11297」Census]]></title>
    <url>%2F2018%2F11%2F16%2F%E3%80%8CUVa-11297%E3%80%8DCensus%2F</url>
    <content type="text"><![CDATA[给定一个$n\times n$的矩阵，支持单点修改，查询子矩阵最大值和子矩阵最小值。 链接UVa 11297 题解经典的二维带修RMQ问题。一个暴力的思想是建$500$棵线段树，对于修改就在对应的线段树上修改，对于查询的时候就一行一行的查询，每一次把答案与之前的答案合并一下就好了qwq。这样子做的时间复杂度是$O(qn\log n)$，不会TLE，但是跑的极慢，在测的时候跑了$1070$ms，没有树套树跑的快…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=551;struct SegmentTree&#123; ll l,r,minn,maxn; &#125;;SegmentTree tree[MAXN][MAXN&lt;&lt;2];ll size,qcnt,lx,ly,rx,ry,x,y,val,minn,maxn;char ch;ll num[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll dim,ll node)&#123; tree[dim][node].maxn=max(tree[dim][node&lt;&lt;1].maxn,tree[dim][(node&lt;&lt;1)|1].maxn); tree[dim][node].minn=min(tree[dim][node&lt;&lt;1].minn,tree[dim][(node&lt;&lt;1)|1].minn);&#125;inline void create(ll dim,ll l,ll r,ll node)&#123; tree[dim][node].l=l,tree[dim][node].r=r; if(l==r) &#123; tree[dim][node].minn=tree[dim][node].maxn=num[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(dim,l,mid,node&lt;&lt;1); create(dim,mid+1,r,(node&lt;&lt;1)|1); update(dim,node);&#125;inline void changePoint(ll dim,ll pos,ll val,ll node)&#123; if(tree[dim][node].l==tree[dim][node].r) &#123; tree[dim][node].minn=tree[dim][node].maxn=val; return; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1; if(pos&lt;=mid) &#123; changePoint(dim,pos,val,node&lt;&lt;1); &#125; else &#123; changePoint(dim,pos,val,(node&lt;&lt;1)|1); &#125; update(dim,node);&#125;inline ll queryMax(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].maxn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0; if(l&lt;=mid) &#123; res=max(res,queryMax(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=max(res,queryMax(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;inline ll queryMin(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].minn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0x7fffffff; if(l&lt;=mid) &#123; res=min(res,queryMin(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=min(res,queryMin(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;int main()&#123; size=read(); for(register int i=1;i&lt;=size;i++) &#123; for(register int j=1;j&lt;=size;j++) &#123; num[j]=read(); &#125; create(i,1,size,1); &#125; qcnt=read(); for(register int i=0;i&lt;qcnt;i++) &#123; cin&gt;&gt;ch; if(ch=='q') &#123; lx=read(),ly=read(),rx=read(),ry=read(); maxn=0,minn=0x7fffffff; for(register int j=lx;j&lt;=rx;j++) &#123; maxn=max(maxn,queryMax(j,ly,ry,1)); minn=min(minn,queryMin(j,ly,ry,1)); &#125; printf("%d %d\n",maxn,minn); &#125; else &#123; x=read(),y=read(),val=read(); changePoint(x,y,val,1); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11992」Fast Matrix Operations]]></title>
    <url>%2F2018%2F11%2F15%2F%E3%80%8CUVa-11992%E3%80%8DFast-Matrix-Operations%2F</url>
    <content type="text"><![CDATA[给定一个$r\times c$矩阵，支持子矩阵加某一个值，子矩阵覆盖为某一个值，查询某个子矩阵的值。 链接一如既往放洛谷的链接……UVa 11992 题解一个暴力的想法是由于$r$不超过$20$，所以可以开$20$棵线段树，修改和覆盖就不难啦qwq。至于查询，可以处理这一行的时候合并这一行的答案和原来的答案就好了qwq。所以我查询了$3$次这个时间复杂度是$O(r\log c)$，绝对不会T掉的 代码代码略丑，$233$行…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=5e4+51;struct SegmentTree&#123; ll l,r,sum,maxn,minn,tag,cover;&#125;; SegmentTree tree[21][MAXN&lt;&lt;2];ll length,width,qcnt,lx,rx,ly,ry,op,val,sum,maxn,minn;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll dim,ll node)&#123; tree[dim][node].sum=tree[dim][node&lt;&lt;1].sum+tree[dim][(node&lt;&lt;1)|1].sum; tree[dim][node].maxn=max(tree[dim][node&lt;&lt;1].maxn,tree[dim][(node&lt;&lt;1)|1].maxn); tree[dim][node].minn=min(tree[dim][node&lt;&lt;1].minn,tree[dim][(node&lt;&lt;1)|1].minn);&#125;inline void create(ll dim,ll l,ll r,ll node)&#123; tree[dim][node].l=l,tree[dim][node].r=r,tree[dim][node].cover=-1; if(l==r) &#123; tree[dim][node].sum=tree[dim][node].maxn=tree[dim][node].minn=0; return; &#125; ll mid=(l+r)&gt;&gt;1; create(dim,l,mid,node&lt;&lt;1); create(dim,mid+1,r,(node&lt;&lt;1)|1); update(dim,node);&#125;inline void spread(ll dim,ll node)&#123; ll ls=node&lt;&lt;1,rs=ls|1; ll lx=(tree[dim][ls].r-tree[dim][ls].l+1); ll rx=(tree[dim][rs].r-tree[dim][rs].l+1); if(tree[dim][node].cover!=-1) &#123; tree[dim][ls].maxn=tree[dim][node].cover; tree[dim][rs].maxn=tree[dim][node].cover; tree[dim][ls].minn=tree[dim][node].cover; tree[dim][rs].minn=tree[dim][node].cover; tree[dim][ls].sum=tree[dim][node].cover*lx; tree[dim][rs].sum=tree[dim][node].cover*rx; tree[dim][ls].cover=tree[dim][rs].cover=tree[dim][node].cover; tree[dim][ls].tag=tree[dim][rs].tag=0; tree[dim][node].cover=-1; &#125; if(tree[dim][node].tag) &#123; tree[dim][ls].maxn+=tree[dim][node].tag; tree[dim][rs].maxn+=tree[dim][node].tag; tree[dim][ls].minn+=tree[dim][node].tag; tree[dim][rs].minn+=tree[dim][node].tag; tree[dim][ls].sum+=tree[dim][node].tag*lx; tree[dim][rs].sum+=tree[dim][node].tag*rx; tree[dim][ls].tag+=tree[dim][node].tag; tree[dim][rs].tag+=tree[dim][node].tag; tree[dim][node].tag=0; &#125; &#125;inline void add(ll dim,ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; tree[dim][node].sum+=(tree[dim][node].r-tree[dim][node].l+1)*val; tree[dim][node].maxn+=val,tree[dim][node].minn+=val; tree[dim][node].tag+=val; return; &#125; spread(dim,node); ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(dim,l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(dim,l,r,val,(node&lt;&lt;1)|1); &#125; update(dim,node);&#125;inline void cover(ll dim,ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; tree[dim][node].sum=(tree[dim][node].r-tree[dim][node].l+1)*val; tree[dim][node].maxn=tree[dim][node].minn=val; tree[dim][node].cover=val; tree[dim][node].tag=0; return; &#125; spread(dim,node); ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1; if(l&lt;=mid) &#123; cover(dim,l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; cover(dim,l,r,val,(node&lt;&lt;1)|1); &#125; update(dim,node);&#125;inline ll query(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].sum; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0; spread(dim,node); if(l&lt;=mid) &#123; res+=query(dim,l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; res+=query(dim,l,r,(node&lt;&lt;1)|1); &#125; return res;&#125;inline ll queryMax(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].maxn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0; spread(dim,node); if(l&lt;=mid) &#123; res=max(res,queryMax(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=max(res,queryMax(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;inline ll queryMin(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].minn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0x7fffffff; spread(dim,node); if(l&lt;=mid) &#123; res=min(res,queryMin(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=min(res,queryMin(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;inline void solve()&#123; width=read(),qcnt=read(); for(register int i=1;i&lt;=length;i++) &#123; create(i,1,width,1); &#125; for(register int i=1;i&lt;=qcnt;i++) &#123; op=read(),lx=read(),ly=read(),rx=read(),ry=read(); if(op==1) &#123; val=read(); for(register int j=lx;j&lt;=rx;j++) &#123; add(j,ly,ry,val,1); &#125; &#125; if(op==2) &#123; val=read(); for(register int j=lx;j&lt;=rx;j++) &#123; cover(j,ly,ry,val,1); &#125; &#125; if(op==3) &#123; sum=maxn=0,minn=0x7fffffff; for(register int j=lx;j&lt;=rx;j++) &#123; sum+=query(j,ly,ry,1); maxn=max(maxn,queryMax(j,ly,ry,1)); minn=min(minn,queryMin(j,ly,ry,1)); &#125; printf("%d %d %d\n",sum,minn,maxn); &#125; &#125;&#125;int main()&#123; while(scanf("%d",&amp;length)!=EOF) &#123; solve(); memset(tree,0,sizeof(tree)); &#125;&#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018滚粗记]]></title>
    <url>%2F2018%2F11%2F15%2FNOIP2018%E6%BB%9A%E7%B2%97%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[NOIP要咕咕了…… Day 0上午写模板,lca,Heap+Dijkstra,k短路,网络流，好像背不下来……下午与全机房的大佬颓slay，咕咕咕…… Day 1Task 1 road开始：先写个线段树再说吧……后来:这……这不是积木大赛吗？我怎么一开始就写的线段树…… Task 2 money开始：一脸茫然的样子……后来：可以乱搞诶，消掉其他货币组成的货币，剩下的直接选，标记一下，$O(Tn25000)$应该不会TLE…… Task 3 track开始：应该是个二分答案……后来：觉得$m=1$可做，好像有$10$分啊，后面的骗一下分吧，今天要$100+100+10=210$滚粗了…… Day 2Task 1 travel开始：树上$60$分真好做，基环树？不会……后来：好像可以找环，断边乱搞……（事实上这是非正解，咕咕，但是可以过咕咕F的数据） Task 2 game开始：先爆搜，打个表再说……后来：为什么$3\times3$不对，搜出$144$，为什么……骗一点分吧 Task 3 defense开始：好像是个$dp$……后来：我擦！$ddp$？不会做，今天是不是要$76+33+0=109$滚粗…… Day $log(n)$洛谷成绩$100+100+25+76+55+0=356$滚粗…… Day $n$咕咕F的成绩再一次咕掉了，我的博客也要咕掉…… Day $n\log(n)$成绩？呵呵……技不如人，被吊打]]></content>
      <tags>
        <tag>游记/考试</tag>
        <tag>待修改</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2532」[AHOI2012]树屋阶梯]]></title>
    <url>%2F2018%2F11%2F10%2F%E3%80%8CLuogu-P2532%E3%80%8D-AHOI2012-%E6%A0%91%E5%B1%8B%E9%98%B6%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[引言NOIP rp++! 链接Luogu P2532 题解考虑$f_i$表示搭$i$层高的阶梯的方案数，$g_{i,j}$表示最左下角的钢材上面有$i$层高，右边有$j$层高的方案数，那么如图$f_n=\sum^{n-1}_{i=1}g_{i,j}$而$i+j=n$且$g_{i,j}=f_if_j$$\therefore f_n=\sum^{n-1}_{i=1}f_if_{n-i}$显然是卡特兰的递推式，所以就可以用卡特兰数求，但是要用高精度…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e4+51; struct BigInt&#123; ll digit; ll num[MAXN]; BigInt() &#123; memset(num,0,sizeof(num)); &#125; inline void operator =(ll x) &#123; while(x) &#123; num[digit++]=x%10000,x/=10000; &#125; &#125; inline void op() &#123; printf("%d",num[digit-1]); for(register int i=digit-2;i&gt;=0;i--) &#123; if(!num[i]) &#123; printf("0000"); continue; &#125; ll rest=3-(ll)(log10(num[i])); for(register int j=rest;j;j--) &#123; putchar('0'); &#125; printf("%d",num[i]); &#125; &#125; inline bool operator &gt;(const BigInt &amp;rhs)const &#123; if(digit!=rhs.digit) &#123; return digit&gt;rhs.digit; &#125; for(register int i=digit-1;i&gt;=0;i--) &#123; if(num[i]!=rhs.num[i]) &#123; return num[i]&gt;rhs.num[i]; &#125; &#125; return 0; &#125;&#125;; ll num;BigInt res;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline BigInt operator +(BigInt x,BigInt y)&#123; BigInt res; ll carry=0; res.digit=max(x.digit,y.digit)+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]+y.num[i]+carry; carry=res.num[i]/10000,res.num[i]%=10000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator *(BigInt x,ll y)&#123; BigInt res; ll carry=0; res.digit=x.digit+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]*y+carry; carry=res.num[i]/10000,res.num[i]%=10000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator /(BigInt x,ll y)&#123; BigInt res; ll cur=0; res.digit=x.digit; for(register int i=x.digit-1;i&gt;=0;i--) &#123; cur=cur*10000+x.num[i]; if(cur&gt;=y) &#123; res.num[i]=cur/y,cur%=y; &#125; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;int main()&#123; num=read(); res=1; for(register int i=1;i&lt;=2*num;i++) &#123; res=res*i; &#125; res=res/(num+1); for(register int i=1;i&lt;=num;i++) &#123; res=res/i/i; &#125; res.op();&#125;]]></content>
      <tags>
        <tag>高精</tag>
        <tag>数论</tag>
        <tag>卡特兰</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3939」数颜色]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%8CLuogu-P3939%E3%80%8D%E6%95%B0%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[给定一个序列，支持交换两个元素和询问区间$(l,r)$内等于这个值的位置的数量。 链接Luogu P3939 题解肯定有人学数据结构学傻了吧，我们机房有写cdq的，有写主席树的，跑的都很快亲测这份代码不吸氧比上面两份代码吸氧还快……评测结果用vector记录每一种颜色的兔子出现在从左到右的哪几个位置，对于每个询问，二分查找出当前右端点$r$的位置和左端点$l-1$的位置，两个值相减即得答案，但是要注意边界处理。对于交换，找到两个兔子的位置，直接进行交换即可，注意要把所有的信息都交换…… 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=3e5+51;vector&lt;ll&gt;rabbit[MAXN];ll cnt,ccnt,op,l,r,x,lx,rx,maxn;vector&lt;ll&gt;::iterator bg,ed;ll color[MAXN],ind[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;int main()&#123; cnt=read(),ccnt=read(); for(register int i=1;i&lt;=cnt;i++) &#123; color[i]=read(); rabbit[color[i]].push_back(i); ind[i]=rabbit[color[i]].size()-1; &#125; for(register int i=1;i&lt;=ccnt;i++) &#123; op=read(); if(op==1) &#123; l=read()-1,r=read(),x=read(); bg=rabbit[x].begin(); ed=rabbit[x].end(); if(bg==ed) &#123; puts("0"); continue; &#125; lx=lower_bound(bg,ed,l)-bg,rx=lower_bound(bg,ed,r)-bg; if(rabbit[x][lx]==l) &#123; lx++; &#125; if(rabbit[x][rx]==r) &#123; rx++; &#125; printf("%d\n",rx-lx); &#125; else &#123; x=read(); if(color[x]!=color[x+1]) &#123; rabbit[color[x]][ind[x]]=x+1; rabbit[color[x+1]][ind[x+1]]=x; swap(color[x],color[x+1]); swap(ind[x],ind[x+1]); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>模拟</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我们做过的模板 I]]></title>
    <url>%2F2018%2F11%2F08%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%81%9A%E8%BF%87%E7%9A%84%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>模板</tag>
        <tag>最短路</tag>
        <tag>DijkStra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1337」[JSOI2004]平衡点 / 吊打XXX]]></title>
    <url>%2F2018%2F11%2F05%2F%E3%80%8CLuogu-P1337%E3%80%8D-JSOI2004-%E5%B9%B3%E8%A1%A1%E7%82%B9-%E5%90%8A%E6%89%93XXX%2F</url>
    <content type="text"><![CDATA[给定一些带权点，求它们的带权费马点。 链接Luogu P1337BZOJ 3680 题解这题备选的解很多，所以采用猜答案的方法模拟退火来做此题。注意下一些常数吧……我是不会告诉你我卡了7次的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e4+51;const double delta=0.997;struct Node&#123; double x,y,weight; &#125;;Node nd[MAXN];ll cnt;double resx,resy,res=1e18,t; inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll randInt()&#123; return 2*rand()-RAND_MAX;&#125; inline double potentialEnergy(double x,double y)&#123; double sum=0,xx,yy; for(register int i=0;i&lt;cnt;i++) &#123; xx=x-nd[i].x,yy=y-nd[i].y; sum+=sqrt(xx*xx+yy*yy)*nd[i].weight; &#125; return sum;&#125; inline void simulatedAnnealing()&#123; double x=resx,y=resy,rd,xx,yy,dt; t=19260; while(t&gt;1e-18) &#123; xx=resx+randInt()*t,yy=resy+randInt()*t; rd=potentialEnergy(xx,yy),dt=rd-res; if(dt&lt;0) &#123; x=xx,y=yy,resx=x,resy=y,res=rd; &#125; else &#123; if(exp(-dt/t)*RAND_MAX&gt;rand()) &#123; x=xx,y=yy; &#125; &#125; t*=delta; &#125;&#125;inline void SA(ll times)&#123; for(register int i=0;i&lt;times;i++) &#123; simulatedAnnealing(); &#125;&#125;int main()&#123; srand(time(0)); cnt=read(); for(register int i=0;i&lt;cnt;i++) &#123; nd[i].x=read(),nd[i].y=read(),nd[i].weight=read(); &#125; SA(9); printf("%.3lf %.3lf",resx,resy);&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>未完待续</tag>
        <tag>洛谷</tag>
        <tag>JSOI</tag>
        <tag>随机化</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2197」【模板】nim游戏]]></title>
    <url>%2F2018%2F11%2F02%2F%E3%80%8CLuogu-P2197%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91nim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[有$n$堆石子，第$i$堆有$a_i$个，$Alice$和$Bob$轮流取石子，$Alice$先取。每个游戏者只能取一堆石子，至少取一个，问哪个游戏者会赢。 链接Luogu P2197 题解最基础的Nim游戏，先手必赢当且仅当$a_1 \operatorname{xor} a_2 \operatorname{xor} \cdots \operatorname{xor} a_n \not = 0$，代码很短。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;ll test,cnt,res;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll solve()&#123; cnt=read(); for(register int i=0;i&lt;cnt;i++) &#123; res^=read(); &#125; puts(res!=0?"Yes":"No"); res=0;&#125; int main()&#123; test=read(); while(test--) &#123; solve(); &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>博弈论</tag>
        <tag>Nim游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4438」[HNOI/AHOI2018]道路]]></title>
    <url>%2F2018%2F11%2F01%2F%E3%80%8CLuogu-P4438%E3%80%8D-HNOI-AHOI2018-%E9%81%93%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[给你一颗有$2n-1$个节点的树，这一棵树的非叶节点均有两个儿子，左儿子与它连红边，右儿子与它连绿边，定义节点$i$的不便利值为$c_i\cdot(a_i+x)\cdot(b_i+y)$其中$x$表示根节点到节点$i$的未加粗红边数量，$y$表示根节点到节点$i$的未加粗绿边数量。求加粗边数量为$n-1$的所有叶节点的不便利值。 链接Luogu P4438 题解一道比较好的树形dp题。将每一个城市标号$1$到$n-1$，乡村标号$n$到$2n-1$，设$dp[i][j][k]$表示标号后的$i$号节点到根节点要走过$j$条没有翻修的公路和$k$条没有翻修的铁路最小的不便利值。设$l[i]$指的是通过公路连接$i$号结点的城市或乡村，$r[i]$指的是通过铁路连接$i$号结点的城市或乡村，那么如果$i$是乡村，直接暴力算不便利值即可，即$dp[i][j][k]=c_i\cdot(a_i+j)\cdot(b_i+k)$如果$i$是城市，因为最多翻修$n-1$条路，所以考虑对通向每一个城市的公路或铁路进行翻修。翻修通往城市$i$的公路的不便利值是$dp[l_i][j+1][k]+dp[r_i[j][k]$（因为通向$i$的铁路没翻修），铁路同理，即$dp[i][j][k]=\min(dp[l_i][j+1][k]+dp[r_i[j][k],dp[l_i[j][k]+dp[r_i][j][k+1])$所以就得到了转移方程。最后善意的提醒一句，本题卡空间，大佬们可以将$dp$的一维改成$dfn$，蒟蒻不会，只能暴力 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=4e4+51;ll cnt;ll l[MAXN],r[MAXN],lx[MAXN],rx[MAXN];ll x[MAXN],y[MAXN],z[MAXN];ll dp[MAXN][41][41];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void dfs(ll node)&#123; if(node&gt;=cnt) &#123; return; &#125; lx[l[node]]=lx[node]+1,lx[r[node]]=lx[node]; rx[r[node]]=rx[node]+1,rx[l[node]]=rx[node]; dfs(l[node]); dfs(r[node]);&#125;inline void ddp(ll node)&#123; ll lc,rc; if(node&gt;=cnt) &#123; for(register int i=0;i&lt;=lx[node];i++) &#123; for(register int j=0;j&lt;=rx[node];j++) &#123; dp[node][i][j]=1ll*(x[node]+i)*(y[node]+j)*z[node]; &#125; &#125; return; &#125; else &#123; ddp(l[node]); ddp(r[node]); for(register int i=0;i&lt;=lx[node];i++) &#123; for(register int j=0;j&lt;=rx[node];j++) &#123; lc=dp[l[node]][i][j]+dp[r[node]][i][j+1]; rc=dp[r[node]][i][j]+dp[l[node]][i+1][j]; dp[node][i][j]=min(lc,rc); &#125; &#125; &#125;&#125;int main()&#123; cnt=read(); for(register int i=1;i&lt;cnt;i++) &#123; l[i]=read(),r[i]=read(); l[i]=l[i]&lt;0?-l[i]+cnt-1:l[i],r[i]=r[i]&lt;0?-r[i]+cnt-1:r[i]; &#125; for(register int i=1;i&lt;=cnt;i++) &#123; x[i+cnt-1]=read(),y[i+cnt-1]=read(),z[i+cnt-1]=read(); &#125; dfs(1),ddp(1); printf("%lld",dp[1][0][0]);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>各省省选</tag>
        <tag>HNOI</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>AHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 2713」Can you answer these queries IV]]></title>
    <url>%2F2018%2F10%2F28%2F%E3%80%8CSPOJ-2713%E3%80%8DCan-you-answer-these-queries-IV%2F</url>
    <content type="text"><![CDATA[给一段正整数构成的区间，支持区间开平方以及询问区间和。 链接SPOJ 2713 题解考虑线段树，显然区间开平方是不能用lazy\ tag的，所以我们选择暴力修改。先证明一个引理，区间最大值为1的区间进行修改是没有意义的。（这个证明算是补了一个坑）证明：由于区间内所有数是正整数，所以区间最大值为1的区间内所有数均为1，而\sqrt{1}=1，故修改区间内的值没有意义，证毕。于是我们考虑在修改区间时判断一下当前区间最大值是不是1，如果是，就没有修改的必要。如果这个节点的左右端点重合，直接修改即可，这样可以少修改许多修改了也没用的区间，至于查询还是一样的。提醒大家有多组数据，记得初始化 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=1e5+51;struct SegmentTree&#123; ll l,r,sum,maxn;&#125;;SegmentTree tree[MAXN&lt;&lt;2];ll cnt,qcnt,op,l,r,ccnt;ll num[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll node)&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum; tree[node].maxn=max(tree[node&lt;&lt;1].maxn,tree[(node&lt;&lt;1)|1].maxn);&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=tree[node].maxn=num[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void change(ll l,ll r,ll node)&#123; if(tree[node].maxn&lt;=1) &#123; return; &#125; if(tree[node].l==tree[node].r) &#123; tree[node].sum=tree[node].maxn=sqrt(tree[node].sum); return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; change(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; change(l,r,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll querySum(ll l,ll r,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,res=0; if(l&lt;=mid) &#123; res+=querySum(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; res+=querySum(l,r,(node&lt;&lt;1)|1); &#125; return res;&#125;inline ll queryMax(ll l,ll r,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].maxn; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,res=0; if(l&lt;=mid) &#123; res=max(res,queryMax(l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=max(res,queryMax(l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;int main()&#123; while(scanf("%lld",&amp;cnt)!=EOF) &#123; printf("Case #%lld:\n",++ccnt); for(register int i=1;i&lt;=cnt;i++) &#123; num[i]=read(); &#125; create(1,cnt,1); qcnt=read(); for(register int i=0;i&lt;qcnt;i++) &#123; op=read(),l=read(),r=read(); if(l&gt;r) &#123; swap(l,r); &#125; if(op) &#123; printf("%lld\n",querySum(l,r,1)); &#125; else &#123; if(queryMax(l,r,1)&gt;1) &#123; change(l,r,1); &#125; &#125; &#125; memset(num,0,sizeof(num)); memset(tree,0,sizeof(tree)); puts(""); &#125;&#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2742」【模板】二维凸包]]></title>
    <url>%2F2018%2F10%2F21%2F%E3%80%8CLuogu-P2742%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[给定一个点集，求它的凸包的周长。 链接Luogu P2742 题解二维凸包的模板题，没有什么好说的。不会凸包的右转这里但是最后求周长是一定要算点的距离，而不是向量的长度。被卡了两次 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef double db;const ll MAXN=1e4+51;struct Point&#123; db x,y; Point(ll x=0,ll y=0) &#123; this-&gt;x=x,this-&gt;y=y; &#125; inline bool operator &lt;(const Point &amp;rhs)const &#123; return y==rhs.y?x&lt;rhs.x:y&lt;rhs.y; &#125; inline db polar() &#123; return atan2(y,x); &#125;&#125;;typedef Point Vector;Point p[MAXN];ll cnt,minn;db res;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline Vector operator +(Vector x,Vector y)&#123; return Vector(x.x+y.x,x.y+y.y);&#125;inline Vector operator -(Vector x,Vector y)&#123; return Vector(x.x-y.x,x.y-y.y);&#125;inline Vector operator *(Vector x,db y)&#123; return Vector(x.x*y,x.y*y);&#125;inline Vector operator /(Vector x,db y)&#123; return Vector(x.x/y,x.y/y);&#125;inline db dot(Vector x,Vector y)&#123; return x.x*y.x+x.y*y.y;&#125;inline db length(Vector x)&#123; return sqrt(dot(x,x));&#125;inline db angle(Vector x,Vector y)&#123; return acos(dot(x,y)/length(x)/length(y));&#125;inline db cross(Vector x,Vector y)&#123; return x.x*y.y-x.y*y.x;&#125;inline db dist(Vector x,Vector y)&#123; db xx=x.x-y.x,yy=x.y-y.y; return sqrt(xx*xx+yy*yy);&#125;inline bool cmp(Point x,Point y)&#123; double xx=cross(x-p[1],y-p[1]); if(xx&gt;0) &#123; return 1; &#125; if(!xx&amp;&amp;length(x-p[1])&lt;length(y-p[1])) &#123; return 1; &#125; return 0;&#125;inline deque&lt;Point&gt; convexHull(Point *p,ll size)&#123; Point top; deque&lt;Point&gt;vec; if(size==1) &#123; vec.push_back(p[1]); return vec; &#125; if(size==2) &#123; vec.push_back(p[1]),vec.push_back(p[2]); return vec; &#125; vec.push_back(p[1]),vec.push_back(p[2]); for(register int i=3;i&lt;=size;i++) &#123; top=vec.back(); while(cross(top-vec[vec.size()-2],p[i]-top)&lt;0) &#123; vec.pop_back(),top=vec.back(); &#125; vec.push_back(p[i]); &#125; return vec;&#125;int main()&#123; cnt=read(); p[0].x=p[0].y=100000000000.0; if(cnt==0) &#123; printf("0.00"); return 0; &#125; for(register int i=1;i&lt;=cnt;i++) &#123; scanf("%lf%lf",&amp;p[i].x,&amp;p[i].y); if(p[i]&lt;p[minn]) &#123; minn=i; &#125; &#125; swap(p[minn],p[1]),sort(p+2,p+cnt+1,cmp); deque&lt;Point&gt;pt=convexHull(p,cnt); if(pt.size()==1) &#123; printf("%.2lf",0.0); &#125; else &#123; for(register int i=1;i&lt;pt.size();i++) &#123; res+=dist(pt[i],pt[i-1]); &#125; res+=dist(pt[0],pt[pt.size()-1]); printf("%.2lf",res); &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>二维凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·二维凸包]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[二维凸包是指一个面积最小的凸多边形，使得一个给定的点集都分布在这个凸多边形的内部或者边上。 前置技能计算几何基础，这个大概不用说了。 过程咕咕咕，这里我们使用比较好想的Graham算法进行求解。前方大图警告。首先呢，是一个点集。因为y坐标最小的点肯定在这个凸包上，所以我们先找出y坐标最小的点,记为P_1。接着考虑把剩下的点对于P_1从右往左编号。PS:截图的锅，P_{11}上面那个点是P_{12}。预处理完毕，接下来我们需要一个栈。由于P_1和P_2在凸包边界上，考虑将P_1和P_2入栈。未完成的凸包用红色线条表示。考虑P_3，加入它之后红色边界仍然是凸的，P_3入栈。接下来考虑P_4，加入它之后边界是凹的，把当前栈顶P_3出栈。考虑加入P_4当前红色边界加入P_4仍然是凸的，所以P_4入栈。由于连续加入P_5，P_6，P_7后所得的红色边界仍然是凸的，所以将它们依次入栈。在考虑P_8时，发现边界是凹的，将栈顶P_7出栈，而P_8入栈。考虑P_9。在连续出栈P_8和P_6都不能满足红色边界为凸的，所以一出栈，将P_9入栈。依次进行以下操作，可以得到一个处理到最后一个点的图像，然后就完结撒花了！所以说，code呢？对不起，没有个鬼。出门右转看代码]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>二维凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 1060C」Maximum Subrectangle]]></title>
    <url>%2F2018%2F10%2F15%2F%E3%80%8CCodeForces-1060C%E3%80%8DMaximum-Subrectangle%2F</url>
    <content type="text"><![CDATA[给一个数x，序列a和另一个序列b，构造一个矩阵c使得c_{i,j}=a_{i}\times b_{j}。在矩阵中找出一个最大的矩形使得矩形内所有数的和小于x。因为要求子矩阵的和，所以考虑二维前缀和。但是由于矩阵的特殊性质c_{i,j}=a_{i}\times b_{j}，所以可以将二维前缀和转化为两个一维前缀和的乘积。]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>CodeForces</tag>
        <tag>前缀和</tag>
        <tag>贪心</tag>
        <tag>two pointers</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4315」月下“毛景树”]]></title>
    <url>%2F2018%2F10%2F15%2F%E3%80%8CLuogu-P4315%E3%80%8D%E6%9C%88%E4%B8%8B%E6%AF%9B%E6%99%AF%E6%A0%91%2F</url>
    <content type="text"><![CDATA[给一棵树，支持修改边上的权值，将两点间路经全部增加k或全部覆盖为k，多次求当前树上两点间路径上的边权最大值。 链接Luogu P4315 题解我不会告诉你这道毒瘤题我调了两个月吐槽一下毒瘤出题人，这份代码我足足写了297行，无语……好吧当时交题的时候并没有把求lca删掉此题一眼看过去是树剖+边权下放，把边权下放之后就是普通的树剖。这里还有个奇淫技巧，就是在最后修改与查询时，为了不统计LCA，将id[x]改成id[x]+1，具体看注释。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,maxn,tag,cover;&#125;;const ll MAXN=2e5+51; edge ed[MAXN];SegmentTree tree[MAXN&lt;&lt;2];ll last[MAXN],val[MAXN],depth[MAXN],fa[MAXN],size[MAXN],heavy[MAXN];ll id[MAXN],pre[MAXN],top[MAXN],from[MAXN],to[MAXN],dist[MAXN];ll tot,nc,ccnt,tx,x,y,z;string op;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;inline void update(ll node)&#123; tree[node].maxn=max(tree[node&lt;&lt;1].maxn,tree[(node&lt;&lt;1)|1].maxn);&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r,tree[node].cover=-1; if(l==r) &#123; tree[node].maxn=val[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void spread(ll node)&#123; if(tree[node].cover!=-1) &#123; tree[node&lt;&lt;1].maxn=tree[node].cover; tree[(node&lt;&lt;1)|1].maxn=tree[node].cover; tree[node&lt;&lt;1].cover=tree[node].cover; tree[(node&lt;&lt;1)|1].cover=tree[node].cover; tree[node&lt;&lt;1].tag=tree[(node&lt;&lt;1)|1].tag=0; tree[node].cover=-1; &#125; if(tree[node].tag) &#123; tree[node&lt;&lt;1].maxn+=tree[node].tag; tree[(node&lt;&lt;1)|1].maxn+=tree[node].tag; tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; tree[node].tag=0; &#125;&#125;inline void change(ll pos,ll val,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].maxn=val; return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; spread(node); if(pos&lt;=mid) &#123; change(pos,val,node&lt;&lt;1); &#125; else &#123; change(pos,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline void cover(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].maxn=val; tree[node].cover=val; tree[node].tag=0; return; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; cover(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; cover(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].maxn+=val; tree[node].tag+=val; return; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll queryMax(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].maxn; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=-(1&lt;&lt;30); if(l&lt;=mid) &#123; val=max(val,queryMax(l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; val=max(val,queryMax(l,r,(node&lt;&lt;1)|1)); &#125; return val;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1; ll maxn=-1; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f) &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to]; if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to]; &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link; if(!heavy[node]) &#123; return; &#125; ddfs(heavy[node],link); for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to); &#125; &#125;&#125;inline ll queryPathMax(ll x,ll y)&#123; ll ans=-(1&lt;&lt;30); while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans=max(ans,queryMax(id[top[x]],id[x],1)); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans=max(ans,queryMax(id[x]+1,id[y],1));// return ans;&#125;inline void changePoint(ll x,ll y)&#123; change(id[x],y,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x]+1,id[y],val,1);//&#125;inline void coverPath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; cover(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; cover(id[x]+1,id[y],val,1);//&#125;int main()&#123; nc=read(); for(register int i=0;i&lt;nc-1;i++) &#123; from[i]=read(),to[i]=read(),dist[i]=read(); addEdge(from[i],to[i]),addEdge(to[i],from[i]); &#125; dfs(1,0,1),ddfs(1,1),create(1,nc,1); for(register int i=0;i&lt;nc-1;i++) &#123; changePoint(depth[from[i]]&gt;depth[to[i]]?from[i]:to[i],dist[i]); &#125; while(cin&gt;&gt;op,op!="Stop") &#123; if(op=="Max") &#123; x=read(),y=read(); cout&lt;&lt;queryPathMax(x,y)&lt;&lt;endl; &#125; if(op=="Change") &#123; x=read(),y=read(); tx=depth[from[x-1]]&gt;depth[to[x-1]]?from[x-1]:to[x-1]; changePoint(tx,y); &#125; if(op=="Add") &#123; x=read(),y=read(),z=read(); changePath(x,y,z); &#125; if(op=="Cover") &#123; x=read(),y=read(),z=read(); coverPath(x,y,z); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018之前的琐记]]></title>
    <url>%2F2018%2F10%2F09%2FNOIP2018%E4%B9%8B%E5%89%8D%E7%9A%84%E7%90%90%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[既然Karry5307已经变成了初二的小蒟蒻了，那么还是写点NOIP2018之前的琐记吧。 考试2018.10.8：出题人xzy，毒瘤题。T1什么鬼，7合1，gg。T3辣鸡模拟，让你算空间，最后交卷时发现bitset没开long\ long，写了个快速乘\% 998244353，读入出锅了，居然没看到有个空格没搞好，0+0+10=10分滚粗。（我不会告诉你我是因为没看大样例而导致的） 2018.10.9：出题人Despair，毒瘤题。第一题什么鬼，yyb大佬说是迭代，结果还真的是迭代（顺便吐槽一句，题解写的矩乘看都没看懂）T3随手开了个10^7的数组，MLE了。 2018.10.10：出题人Tyher，这次我觉得海星。T1被卡精度原地爆炸，log_{10}改成log_2就会有35分的好成绩啦，T3良心，Task\ 4特判了一下，其余线段树乱搞还有40分，拿了20+40+25=85分滚粗，yyb大佬太强了，又阿克了。 2018.10.11：T1毒瘤三合一，布星啊，墙裂谴责，乱搞还没分，幸好T2乱搞有20分。T3全场切except\ me，告辞告辞，0+20+0=20滚粗。 2018.10.12：出题人DarkFire，题目海星，只是我太蒟蒻了，连T2都没切。Despair大佬又阿克了，%%%，我这个小蒟蒻继续0+20+0=20滚粗。 2018.10.13：上午初赛模拟，什么鬼，一个排完序后的水题硬是考递归，体验极差。(最近有点懒，没更) 2018.10.26：T1不会莫比乌斯反演，被吊打，只好拿20分滚粗。T2不会写，跳过。T3居然还下放了一个game，什么鬼，最后才知道这game考有限状态自动机，我太蒻了，居然没玩通关，苟且21分。总共20+0+21=41分滚粗。tbr大佬玩个游戏T3都拿了66分，我竟无言以对。我突然觉得我连游戏都不会玩了]]></content>
      <tags>
        <tag>游记/考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4884」多少个1？]]></title>
    <url>%2F2018%2F10%2F07%2F%E3%80%8CLuogu-P4884%E3%80%8D%E5%A4%9A%E5%B0%91%E4%B8%AA1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[给定p和模数yyb，保证yyb为质数，求最小的x使得$111\cdots 1$(x个)\equiv 1\pmod {yyb} 链接Luogu P4884 题解注意到111\cdots 1(x个)=\cfrac{10^x-1}{9},则 111\cdots 1\equiv (10^x-1)\times 9^{-1}\therefore (10^x-1)\times 9^{-1}\equiv yyb\therefore 10^x \equiv 9\times yyb+1然后这个方程就化为BSGS的标准形式了，由于模数yyb为质数，直接利用BSGS即可。由于yyb会很大，所以再次建议不要用自己写的哈希表，而使用map。我是不会告诉你我因为这个原因被洛谷的数据坑了好几次了 代码为了保险，这里开了int128，美中不足的是要自己写读写，顺便写了一个O(1)的龟速乘。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef __int128 ll;map&lt;ll,ll&gt;ht;ll mod,val;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void write(ll num)&#123; if(num&gt;9) &#123; write(num/10); &#125; putchar(num%10+'0');&#125;inline ll qmul(ll x,ll y,ll mod)&#123; ll l=(y&gt;&gt;25)*x%mod*((1&lt;&lt;25)%mod),r=(y&amp;((1&lt;&lt;25)-1))*x%mod; return (l+r)%mod;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; if(!exponent) &#123; return 1; &#125; ll temp=qpow(base,exponent&gt;&gt;1,mod); ll res=qmul(temp,temp,mod); if(exponent&amp;1) &#123; res=qmul(res,base,mod); &#125; return res;&#125;inline ll BSGS(ll base,ll res,ll mod)&#123; ht.clear(),res%=mod; ll temp,val,fail; temp=sqrt((long double)(mod))+1; for(register int i=0;i&lt;temp;i++) &#123; val=qmul(res,qpow(base,i,mod),mod); ht[val]=i; &#125; base=qpow(base,temp,mod); if(!base) &#123; return !res?1:-1; &#125; for(register int i=0;i&lt;=temp;i++) &#123; val=qpow(base,i,mod),fail=ht.find(val)==ht.end()?-1:ht[val]; if(fail&gt;=0&amp;&amp;i*temp-fail&gt;=0) &#123; return i*temp-fail; &#125; &#125; return -1;&#125;int main()&#123; val=read(),mod=read(); val=(qmul(9,val,mod)+1)%mod; write(BSGS(10,val,mod));&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>数论</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2756」飞行员配对方案问题]]></title>
    <url>%2F2018%2F09%2F24%2F%E3%80%8CLuogu-P2756%E3%80%8D%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这个题是网络流24题中的第1题。给一个二分图，求最大匹配以及匹配方案。 链接Luogu P2756 题解这个题目的模型是二分图最大匹配，有多个源点和汇点。所以可以增加一个超级源点和一个超级汇点。超级源点1与2-(m+1)连流量为1的边；(m+2)-(n+1)与超级汇点n+2连流量为1的边；所给的边全部连流量为1的边。最后，这个网络的最大流即为二分图的最大匹配。对于每一条在二分图内的边，即它和它的反向边不连向源点和汇点，如果反向边有流量，就输出这条边连向的两个点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e5+51,inf=0x7fffffff;struct Edge&#123; ll to,prev,flow;&#125;;Edge ed[MAXN&lt;&lt;1];ll l,nc,source,sink,tot=1,from,to,flow,maxFlow;ll last[MAXN],depth[MAXN],inQueue[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to,ll flow)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; ed[tot].flow=flow; last[from]=tot; &#125;inline ll Min(ll x,ll y)&#123; return x&lt;y?x:y;&#125;inline bool bfs()&#123; queue&lt;ll&gt;q; ll top,to; memset(depth,0x3f,sizeof(depth)); depth[source]=0,q.push(source); while(!q.empty()) &#123; top=q.front(); q.pop(),inQueue[top]=0; for(register int i=last[top];i;i=ed[i].prev) &#123; to=ed[i].to; if(depth[to]&gt;depth[top]+1&amp;&amp;ed[i].flow) &#123; depth[to]=depth[top]+1; if(!inQueue[to]) &#123; q.push(to),inQueue[to]=1; &#125; &#125; &#125; &#125; if(depth[sink]!=0x3f3f3f3f) &#123; return 1; &#125; return 0;&#125;inline ll dfs(ll cur,ll flow)&#123; ll low; if(cur==sink) &#123; return flow; &#125; for(register int i=last[cur];i;i=ed[i].prev) &#123; if(ed[i].flow&amp;&amp;depth[ed[i].to]==depth[cur]+1) &#123; if(low=dfs(ed[i].to,Min(flow,ed[i].flow))) &#123; ed[i].flow-=low,ed[i^1].flow+=low; return low; &#125; &#125; &#125; return 0;&#125;inline ll Dinic()&#123; ll flow; while(bfs()) &#123; while(flow=dfs(source,inf)) &#123; maxFlow+=flow; &#125; &#125; return maxFlow;&#125;int main()&#123; l=read(),nc=read(),source=1,sink=nc+2; while(1) &#123; from=read()+1,to=read()+1; if(!from||!to) &#123; break; &#125; addEdge(from,to,1),addEdge(to,from,0); &#125; for(register int i=2;i&lt;=l+1;i++) &#123; addEdge(source,i,1),addEdge(i,source,0); &#125; for(register int i=l+2;i&lt;=nc+1;i++) &#123; addEdge(i,sink,1),addEdge(sink,i,0); &#125; if(Dinic()==0) &#123; puts("No solution!"); &#125; else &#123; printf("%d\n",maxFlow); for(register int i=2;i&lt;=tot;i+=2) &#123; if(ed[i].to!=source&amp;&amp;ed[i^1].to!=source&amp;&amp;ed[i].to!=sink&amp;&amp;ed[i^1].to!=sink) &#123; if(ed[i^1].flow) &#123; printf("%d %d\n",ed[i^1].to-1,ed[i].to-1); &#125; &#125; &#125; &#125; &#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>二分图匹配</tag>
        <tag>Dinic</tag>
        <tag>网络流24题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3376」【模板】网络最大流]]></title>
    <url>%2F2018%2F09%2F24%2F%E3%80%8CLuogu-P3376%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"></content>
      <tags>
        <tag>未完待续</tag>
        <tag>洛谷</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·网络流]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[网络流是一种解决各种神仙问题的算法，通过合理地建图，可以解决各类神仙问题。网络流的概念也许会有点难懂，于是就先上几幅图，借助水流理解。众所周知，你家的水是从自来水厂通过管道流过来的，假设s是自来水厂，t是你家，1,2,3是中转节点，管道连接如图所示。每条边上的边权是该管道允许的最大流量，即容量，如果流进来的水流流量超过容量，管道就会炸掉，这既不是自来水厂所期望的事，也不是你家所期望的事。现在，你希望自来水厂到你家的水最多，所以尝试找出一条s-&gt;t路径，比如这个对于这条路径，可以通过的可行流为10，所以将这些边的可行流-10，像这样：对于这个网络，一次一次找s-&gt;t路径是可以得到最大流的，但对于别的网络呢？流错了怎么办？这里给一个神仙技巧——加反向边，像这样]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3950」部落冲突]]></title>
    <url>%2F2018%2F09%2F14%2F%E3%80%8CLuogu-P3950%E3%80%8D%E9%83%A8%E8%90%BD%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[给一棵树，每次可以使一条可以经过边设置为不可经过，也可以将不可经过的边设置成可以经过，多次询问两点间路径上的所有边是否都可以经过。 链接Luogu P3950 题解我不会告诉你这题我调了10天将可以经过转换成0，不可经过转换成1，然后树剖+边权下放。对于每次询问，考虑两点间路径上的点权和减去LCA的点权是否等于0即可。最近($2018.12.24$)数据加强了，存边数组开$7e5$过不了，要开$6e5$才能卡过。但是，换一种思路，也可以用LCT过。坑。 代码树剖：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct Edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,sum,tag;&#125;;struct Battle&#123; ll x,y;&#125;;const ll MAXN=700051;Battle bt[MAXN];Edge ed[MAXN];SegmentTree tree[MAXN&lt;&lt;1];ll last[MAXN],val[MAXN],depth[MAXN],fa[MAXN],size[MAXN],heavy[MAXN];ll id[MAXN],pre[MAXN],top[MAXN];ll tot,nc,cnt,ccnt,x,y,from,to,num,toto,tx;char op; inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;inline void update(ll node)&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=val[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void spread(ll node)&#123; if(tree[node].tag) &#123; tree[node&lt;&lt;1].sum+=tree[node].tag*(tree[node&lt;&lt;1].r-tree[node&lt;&lt;1].l+1); tree[(node&lt;&lt;1)|1].sum+=tree[node].tag*(tree[(node&lt;&lt;1)|1].r-tree[(node&lt;&lt;1)|1].l+1); tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; tree[node].tag=0; &#125;&#125;inline void change(ll pos,ll val,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].sum+=val; return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(pos&lt;=mid) &#123; change(pos,val,node&lt;&lt;1); &#125; else &#123; change(pos,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum+=val*(tree[node].r-tree[node].l+1); tree[node].tag+=val; return; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll query(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=0; if(l&lt;=mid) &#123; val+=query(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; val+=query(l,r,(node&lt;&lt;1)|1); &#125; return val;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1; ll maxn=-1; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f) &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to]; if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to]; &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link; if(!heavy[node]) &#123; return; &#125; ddfs(heavy[node],link); for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to); &#125; &#125;&#125;inline ll queryPath(ll x,ll y)&#123; ll ans=0; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans+=query(id[top[x]],id[x],1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans+=query(id[x],id[y],1); return ans;&#125;inline ll querySubtree(ll root)&#123; return query(id[root],id[root]+size[root]-1,1);&#125;inline void changePoint(ll x,ll val)&#123; change(id[x],val,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x],id[y],val,1);&#125;inline void changeSubtree(ll root,ll val)&#123; add(id[root],id[root]+size[root]-1,val,1);&#125;inline ll lca(ll x,ll y)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; x=fa[top[x]]; &#125; return depth[x]&lt;depth[y]?x:y;&#125;int main()&#123; nc=read(),cnt=read(); for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(); addEdge(from,to),addEdge(to,from); &#125; dfs(1,0,1),ddfs(1,1),create(1,nc,1); for(register int i=0;i&lt;cnt;i++) &#123; cin&gt;&gt;op; switch(op) &#123; case 'C':&#123; x=read(),y=read(); bt[++num].x=x,bt[num].y=y; tx=depth[x]&gt;depth[y]?x:y; changePoint(tx,1); break; &#125; case 'U':&#123; x=read(); y=bt[x].y,x=bt[x].x; tx=depth[x]&gt;depth[y]?x:y; changePoint(tx,-1); break; &#125; case 'Q':&#123; x=read(),y=read(); toto=queryPath(x,y)-queryPath(lca(x,y),lca(x,y)); toto?puts("No"):puts("Yes"); break; &#125; &#125; &#125;&#125; LCT：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=3e5+51;struct Battle&#123; ll x,y;&#125;;Battle bt[MAXN];ll cnt,qcnt,x,y,tot;char op;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;namespace LCT&#123; struct Node&#123; ll fa,val,tag; ll ch[2]; &#125;; struct LinkCutTree&#123; Node nd[MAXN]; ll st[MAXN]; inline bool nroot(ll x) &#123; return nd[nd[x].fa].ch[0]==x||nd[nd[x].fa].ch[1]==x; &#125; inline void update(ll x) &#123; nd[x].val=nd[nd[x].ch[0]].val^nd[nd[x].ch[1]].val; &#125; inline void reverse(ll x) &#123; swap(nd[x].ch[0],nd[x].ch[1]); &#125; inline void spread(ll x) &#123; if(nd[x].tag) &#123; reverse(x); nd[nd[x].ch[0]].tag^=1,nd[nd[x].ch[1]].tag^=1; nd[x].tag=0; &#125; &#125; inline void rotate(ll x) &#123; ll fa=nd[x].fa,gfa=nd[fa].fa; ll dir=nd[fa].ch[1]==x,son=nd[x].ch[!dir]; if(nroot(fa)) &#123; nd[gfa].ch[nd[gfa].ch[1]==fa]=x; &#125; nd[x].ch[!dir]=fa,nd[fa].ch[dir]=son; if(son) &#123; nd[son].fa=fa; &#125; nd[fa].fa=x,nd[x].fa=gfa; &#125; inline void splay(ll x) &#123; ll fa=x,gfa,cur=0; st[++cur]=fa; while(nroot(fa)) &#123; st[++cur]=fa=nd[fa].fa; &#125; while(cur) &#123; spread(st[cur--]); &#125; while(nroot(x)) &#123; fa=nd[x].fa,gfa=nd[fa].fa; if(nroot(fa)) &#123; rotate((nd[fa].ch[0]==x)^(nd[gfa].ch[0]==fa)?x:fa); &#125; rotate(x); &#125; &#125; inline void access(ll x) &#123; for(register int i=0;x;x=nd[i=x].fa) &#123; splay(x),nd[x].ch[1]=i; &#125; &#125; inline void makeRoot(ll x) &#123; access(x),splay(x),nd[x].tag^=1; &#125; inline ll findRoot(ll x) &#123; access(x),splay(x); while(nd[x].ch[0]) &#123; spread(x),x=nd[x].ch[0]; &#125; return x; &#125; inline void split(ll x,ll y) &#123; makeRoot(x),access(y),splay(y); &#125; inline void link(ll x,ll y) &#123; makeRoot(x),nd[x].fa=y; &#125; inline void cut(ll x,ll y) &#123; split(x,y),nd[x].fa=nd[y].ch[0]=0; &#125; &#125;;&#125;LCT::LinkCutTree lct;int main()&#123; cnt=read(),qcnt=read(); for(register int i=0;i&lt;cnt-1;i++) &#123; x=read(),y=read(); lct.link(x,y); &#125; for(register int i=0;i&lt;qcnt;i++) &#123; op=getchar(); while(op&lt;'-') &#123; op=getchar(); &#125; if(op=='Q') &#123; x=read(),y=read(); puts(lct.findRoot(x)==lct.findRoot(y)?"Yes":"No"); &#125; if(op=='C') &#123; x=read(),y=read(); lct.cut(x,y),bt[++tot].x=x,bt[tot].y=y; &#125; if(op=='U') &#123; x=read(); lct.link(bt[x].x,bt[x].y); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
        <tag>Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4114」Qtree1]]></title>
    <url>%2F2018%2F08%2F16%2F%E3%80%8CLuogu-P4114%E3%80%8DQtree1%2F</url>
    <content type="text"><![CDATA[怎么说呢，有点裸的树链剖分加上一些常用小技巧…… 链接Luogu P3950]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3178」[HAOI2015]树上操作]]></title>
    <url>%2F2018%2F08%2F14%2F%E3%80%8CHAOI2015%E3%80%8D%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[给定一棵树和多个操作，对于每一个操作3，回答该询问的答案。 链接Luogu P3178BZOJ 4034 题解树链剖分板子题。对于每一个1操作，直接将起点和终点设为这个点，执行路径修改。对于操作2和操作3，直接使用树剖板子。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,sum,tag;&#125;;edge ed[200051];SegmentTree tree[200051&lt;&lt;2];ll last[200051],val[200051],depth[200051],fa[200051],size[200051],heavy[200051];ll id[200051],pre[200051],top[200051];ll tot,nc,cnt,ccnt,op,x,y,from,to;inline ll read()//快读&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)//邻接表基本操作&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;//线段树基本操作inline void update(ll node)//更新节点值，用位运算优化&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum;&#125;inline void create(ll l,ll r,ll node)//建树&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=val[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1);//建左子树 create(mid+1,r,(node&lt;&lt;1)|1);//建右子树 update(node);//更新当前节点&#125;inline void spread(ll node)//下传懒标记&#123; if(tree[node].tag) &#123; //更新节点信息 tree[node&lt;&lt;1].sum+=tree[node].tag*(tree[node&lt;&lt;1].r-tree[node&lt;&lt;1].l+1); tree[(node&lt;&lt;1)|1].sum+=tree[node].tag*(tree[(node&lt;&lt;1)|1].r-tree[(node&lt;&lt;1)|1].l+1); //下传懒标记 tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; //清除当前节点懒标记 tree[node].tag=0; &#125;&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum+=val*(tree[node].r-tree[node].l+1); //做标记 tree[node].tag+=val; return; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll query(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=0; if(l&lt;=mid) &#123; val+=query(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; val+=query(l,r,(node&lt;&lt;1)|1); &#125; return val;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1;//更新节点深度，父节点，节点为根的子树大小 ll maxn=-1;//重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f)//遍历子节点 &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to];//更新子树大小 if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to];//标记重儿子 &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link;//标记节点新编号，赋初始值，更新节点所在重链的顶部 if(!heavy[node])//连重儿子都没有，肯定没有轻儿子，回溯 &#123; return; &#125; ddfs(heavy[node],link);//先遍历重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to);//遍历轻儿子，该节点所在重链顶部节点为自己 &#125; &#125;&#125;//无脑操作inline ll queryPath(ll x,ll y)//查询路径点权和&#123; ll ans=0; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans+=query(id[top[x]],id[x],1);//加上整个链的点权和 x=fa[top[x]];//爬到链顶 &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans+=query(id[x],id[y],1); return ans;&#125;inline ll querySubtree(ll root)&#123; return query(id[root],id[root]+size[root]-1,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x],id[y],val,1);&#125;inline void changeSubtree(ll root,ll val)&#123; add(id[root],id[root]+size[root]-1,val,1);&#125;int main()&#123; nc=read(),cnt=read(); for(register int i=1;i&lt;=nc;i++) &#123; pre[i]=read(); &#125; for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(); addEdge(from,to),addEdge(to,from); &#125; dfs(1,0,1),ddfs(1,1),create(1,nc,1); for(register int i=0;i&lt;cnt;i++) &#123; op=read(); switch(op) &#123; case 1:&#123; x=read(),y=read(); changePath(x,x,y); break; &#125; case 2:&#123; x=read(),y=read(); changeSubtree(x,y); break; &#125; case 3:&#123; x=read(); cout&lt;&lt;queryPath(x,1)&lt;&lt;endl; break; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>未完待续</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>HAOI</tag>
        <tag>各省省选</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3384」【模板】树链剖分]]></title>
    <url>%2F2018%2F08%2F13%2F%E3%80%8CLuogu-P3384%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[模板题，裸的树链剖分，数组记得开大一倍，否则会WA3个点 链接Luogu P3384 代码代码有点长qwq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,sum,tag;&#125;;edge ed[200051];SegmentTree tree[200051&lt;&lt;2];ll last[200051],val[200051],depth[200051],fa[200051],size[200051],heavy[200051];ll id[200051],pre[200051],top[200051];ll tot,nc,cnt,root,ccnt,mod,op,x,y,z,from,to;inline ll read()//快读&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)//邻接表基本操作&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;//线段树基本操作inline void update(ll node)//更新节点值，用位运算优化&#123; tree[node].sum=(tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum)%mod;&#125;inline void create(ll l,ll r,ll node)//建树&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=val[l]%mod; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1);//建左子树 create(mid+1,r,(node&lt;&lt;1)|1);//建右子树 update(node);//更新当前节点&#125;inline void spread(ll node)//下传懒标记&#123; if(tree[node].tag) &#123; //更新节点信息 tree[node&lt;&lt;1].sum+=tree[node].tag*(tree[node&lt;&lt;1].r-tree[node&lt;&lt;1].l+1); tree[(node&lt;&lt;1)|1].sum+=tree[node].tag*(tree[(node&lt;&lt;1)|1].r-tree[(node&lt;&lt;1)|1].l+1); tree[node&lt;&lt;1].sum%=mod; tree[(node&lt;&lt;1)|1].sum%=mod; //下传懒标记 tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; tree[node&lt;&lt;1].tag%=mod; tree[(node&lt;&lt;1)|1].tag%=mod; //清除当前节点懒标记 tree[node].tag=0; &#125;&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum+=val*(tree[node].r-tree[node].l+1); //做标记 tree[node].tag+=val; return; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll query(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum%mod; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=0; if(l&lt;=mid) &#123; val+=query(l,r,node&lt;&lt;1); val%=mod; &#125; if(r&gt;mid) &#123; val+=query(l,r,(node&lt;&lt;1)|1); val%=mod; &#125; return val%mod;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1;//更新节点深度，父节点，节点为根的子树大小 ll maxn=-1;//重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f)//遍历子节点 &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to];//更新子树大小 if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to];//标记重儿子 &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link;//标记节点新编号，赋初始值，更新节点所在重链的顶部 if(!heavy[node])//连重儿子都没有，肯定没有轻儿子，回溯 &#123; return; &#125; ddfs(heavy[node],link);//先遍历重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to);//遍历轻儿子，该节点所在重链顶部节点为自己 &#125; &#125;&#125;//无脑操作inline ll queryPath(ll x,ll y)//查询路径点权和&#123; ll ans=0; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans+=query(id[top[x]],id[x],1)%mod;//加上整个链的点权和 x=fa[top[x]];//爬到链顶 &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans+=query(id[x],id[y],1)%mod; return ans;&#125;inline ll querySubtree(ll root)&#123; return query(id[root],id[root]+size[root]-1,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x],id[y],val,1);&#125;inline void changeSubtree(ll root,ll val)&#123; add(id[root],id[root]+size[root]-1,val,1);&#125;int main()&#123; nc=read(),cnt=read(),root=read(),mod=read(); for(register int i=1;i&lt;=nc;i++) &#123; pre[i]=read(); &#125; for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(); addEdge(from,to),addEdge(to,from); &#125; dfs(root,0,1),ddfs(root,root),create(1,nc,1); for(register int i=0;i&lt;cnt;i++) &#123; op=read(); switch(op) &#123; case 1:&#123; x=read(),y=read(),z=read(); changePath(x,y,z%mod); break; &#125; case 2:&#123; x=read(),y=read(); cout&lt;&lt;queryPath(x,y)%mod&lt;&lt;endl; break; &#125; case 3:&#123; x=read(),y=read(); changeSubtree(x,y%mod); break; &#125; case 4:&#123; x=read(); cout&lt;&lt;querySubtree(x)%mod&lt;&lt;endl; break; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·树链剖分]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[树链剖分是一种将一颗树通过划分不相交的来维护树上路径信息的算法。它保证每一个点仅在一个链上，并通过毒瘤数据结构来维护节点信息。树链剖分是干什么用的呢？很简单，借助树链剖分，可以任意修改树上两点最短路径的点权和子树点权，根本用不着树上差分。如果这棵树是一条链，支持修改和查询，那么我们可以重新按深度编号，这样子每棵子树上的编号都是连续的了，就可以用毒瘤数据结构来解决。但是，事实上，连洛谷模板的样例都不是一条链。尽管有人说可以用LCA+树上差分过，但你觉得数据可能是纯随机的么qwq。所以说，我们应该用树链剖分。 前置技能第一个是刚才标粗的毒瘤数据结构，树链剖分是依靠毒瘤数据结构，比如线段树，树状数组，平衡树等来修改和查询，否则就GG了……第二个是LCA，即最近公共祖先。第三个是树的DFS序，这个有什么用后面会讲。]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2002」消息扩散]]></title>
    <url>%2F2018%2F08%2F11%2F%E3%80%8CLuogu-P2002%E3%80%8D%E6%B6%88%E6%81%AF%E6%89%A9%E6%95%A3%2F</url>
    <content type="text"><![CDATA[给出一个有向图，消息沿着边扩散，求最少需要在几个点发消息才能使整个图所有点都得到消息。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[500001],scc[500001];ll test,tot,num,top,cnt,nc,ec,ans;ll last[500001],sccLast[500001],dfn[500001],low[500001],ins[500001],belong[500001];ll from[500001],to[500001],size[500001],in[500001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void addSCC(ll from,ll to)&#123; scc[++tot].to=to; scc[tot].prev=sccLast[from]; sccLast[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;inline void mergePoint()&#123; tot=0; for(register int i=0;i&lt;ec;i++) &#123; if(belong[from[i]]!=belong[to[i]]) &#123; addSCC(belong[from[i]],belong[to[i]]); in[belong[to[i]]]++; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;nc&gt;&gt;ec; for(register int i=0;i&lt;ec;i++) &#123; cin&gt;&gt;from[i]&gt;&gt;to[i]; addEdge(from[i],to[i]); &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; mergePoint(); for(register int i=1;i&lt;=cnt;i++) &#123; if(!in[i]) &#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 402E」Strictly Positive Matrix]]></title>
    <url>%2F2018%2F08%2F11%2F%E3%80%8CCodeForces-402E%E3%80%8DStrictly-Positive-Matrix%2F</url>
    <content type="text"><![CDATA[给你一个$n*n$大小的矩阵，问你是否有一个正整数$k$使得这个矩阵的$k$次幂均为正数。未完，贴代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[5000001];ll tot,num,dist,top,cnt,nc;ll last[5000001],dfn[5000001],low[5000001],ins[5000001],belong[5000001],size[5000001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;int main()&#123; scanf("%d",&amp;nc); for(register int i=0;i&lt;nc;i++) &#123; for(register int j=0;j&lt;nc;j++) &#123; scanf("%d",&amp;dist); if(dist) &#123; addEdge(i+1,j+1); &#125; &#125; &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; cnt==1?printf("YES\n"):printf("NO\n");&#125;]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>待修改</tag>
        <tag>CodeForces</tag>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>邻接矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2341」[HAOI2006]受欢迎的牛]]></title>
    <url>%2F2018%2F08%2F09%2F%E3%80%8CHAOI2006%E3%80%8D%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[给定一个有向图，找出与其他点均可达的点的个数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[150001],scc[150001];ll sccno,tot,num,top,cnt,nc,ec,ans;ll last[150001],sccLast[150001],dfn[150001],low[150001],ins[150001],belong[150001];ll from[150001],to[150001],size[150001],out[150001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void addSCC(ll from,ll to)&#123; scc[++tot].to=to; scc[tot].prev=sccLast[from]; sccLast[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;inline void mergePoint()&#123; tot=0; for(register int i=0;i&lt;ec;i++) &#123; if(belong[from[i]]!=belong[to[i]]) &#123; addSCC(belong[from[i]],belong[to[i]]); out[belong[from[i]]]++; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;nc&gt;&gt;ec; for(register int i=0;i&lt;ec;i++) &#123; cin&gt;&gt;from[i]&gt;&gt;to[i]; addEdge(from[i],to[i]); &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; mergePoint(); for(register int i=1;i&lt;=cnt;i++) &#123; if(!out[i]) &#123; ans++; sccno=i; &#125; &#125; if(ans!=1) &#123; cout&lt;&lt;0; &#125; else &#123; cout&lt;&lt;size[sccno]; &#125;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>未完待续</tag>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>洛谷</tag>
        <tag>HAOI</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11324」The Largest Clique]]></title>
    <url>%2F2018%2F08%2F08%2F%E3%80%8CUVa-11324%E3%80%8DThe-Largest-Clique%2F</url>
    <content type="text"><![CDATA[给定一个有向图，找出一个子图使得对于该子图的任意两个点$u$,$v$,$u$可以到达$v$或$v$可以到达$u$,判断这样的最大子图的节点个数。 链接登不了UVa，只能用洛谷的链接惹qwqUVa 11324 题解求出图中的强连通分量，缩点，变成DAG。每一个点给一个权值，权值设为每个强连通分量的结点数。最后用记忆化搜索给出最长路。求最长路时写炸了，输入居然可以决定最长路的总权值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[150001],scc[150001];ll test,tot,num,top,cnt,nc,ec,ans;ll last[150001],sccLast[150001],dfn[150001],low[150001],ins[150001],belong[150001];ll from[150001],to[150001],size[150001],dp[150001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void addSCC(ll from,ll to)&#123; scc[++tot].to=to; scc[tot].prev=sccLast[from]; sccLast[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;inline void mergePoint()&#123; tot=0; for(register int i=0;i&lt;ec;i++) &#123; if(belong[from[i]]!=belong[to[i]]) &#123; addSCC(belong[from[i]],belong[to[i]]); &#125; &#125;&#125;inline void search(ll node)&#123; if(dp[node]) &#123; return; &#125; dp[node]=size[node]; ll maxn=0; for(register int i=sccLast[node];i;i=scc[i].prev) &#123; if(!dp[scc[i].to]) &#123; search(scc[i].to); &#125; maxn=max(maxn,dp[scc[i].to]); &#125; dp[node]+=maxn;&#125;int main()&#123; cin&gt;&gt;test; for(register int i=0;i&lt;test;i++) &#123; cin&gt;&gt;nc&gt;&gt;ec; for(register int i=0;i&lt;ec;i++) &#123; cin&gt;&gt;from[i]&gt;&gt;to[i]; addEdge(from[i],to[i]); &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; mergePoint(); for(register int i=1;i&lt;=cnt;i++) &#123; if(!dp[i]) &#123; search(i); ans=max(ans,dp[i]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; tot=num=top=cnt=nc=ec=ans=0; memset(last,0,sizeof(last)); memset(sccLast,0,sizeof(sccLast)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(ins,0,sizeof(ins)); memset(belong,0,sizeof(belong)); memset(from,0,sizeof(from)); memset(to,0,sizeof(to)); memset(size,0,sizeof(size)); memset(dp,0,sizeof(dp)); for(register int i=0;i&lt;150001;i++) &#123; ed[i].prev=ed[i].to=scc[i].prev=scc[i].to=0; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>UVa</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3128」最大流]]></title>
    <url>%2F2018%2F08%2F08%2F%E3%80%8CLuogu-P3128%E3%80%8D%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[给出一棵树和一些操作，每次操作都将两点间所有经过的点的点权+1，求出点权最大的点的权值。 链接Luogu P3128 题解怎么说呢，一道树上点差分模板题，当然树链剖分也可以做。定义$diff[i]$为点$i$的差分值，那么对于每一次修改的参数$start$和$end$，将$diff[start++,diff[end++,diff[\operatorname{lca}(start,end)—]$。为了不让路线修改蔓延到祖先，把LCA的父节点的差分值-1。最后用DFS求出子树差分数组的和就得到该节点修改后的点权啦。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev; &#125;;ll nc,ec,query,root,from,to;ll depth[500010],anc[500010][31],last[500010],diff[500010],LCA,maxn;edge ed[500010*2];inline void addEdge(ll from,ll to)&#123; ed[++ec].prev=last[from]; ed[ec].to=to; last[from]=ec;&#125;inline void dfs(ll node)&#123; ll son; for(register int i=last[node];i!=0;i=ed[i].prev) &#123; son=ed[i].to; if(!depth[son]) &#123; depth[son]=depth[node]+1; anc[son][0]=node; dfs(son); &#125; &#125;&#125;inline void LCASetup()&#123; depth[1]=1; anc[1][0]=0; dfs(1); for(register int i=1;i&lt;=21;i++) &#123; for(register int j=1;j&lt;=nc;j++) &#123; anc[j][i]=anc[anc[j][i-1]][i-1]; &#125; &#125;&#125;inline ll lca(ll x,ll y)&#123; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; for(register int i=21;i&gt;=0;i--) &#123; if(depth[anc[y][i]]&gt;=depth[x]) &#123; y=anc[y][i]; &#125; &#125; if(x==y) &#123; return x; &#125; for(register int i=21;i&gt;=0;i--) &#123; if(anc[x][i]!=anc[y][i]) &#123; x=anc[x][i]; y=anc[y][i]; &#125; &#125; return anc[x][0];&#125;inline ll ddfs(ll node)&#123; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to==anc[node][0]) &#123; continue; &#125; ddfs(ed[i].to); diff[node]+=diff[ed[i].to]; &#125; maxn=max(maxn,diff[node]);&#125;int main()&#123; scanf("%d%d",&amp;nc,&amp;query); for(register int i=0;i&lt;nc-1;i++) &#123; scanf("%d%d",&amp;from,&amp;to); addEdge(from,to); addEdge(to,from); &#125; LCASetup(); for(register int i=0;i&lt;query;i++) &#123; scanf("%d%d",&amp;from,&amp;to); LCA=lca(from,to); diff[from]++,diff[to]++,diff[LCA]--,diff[anc[LCA][0]]--; &#125; ddfs(1); cout&lt;&lt;maxn;&#125;]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>树上差分</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 191C」Fools and Roads]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8CCodeForces-191C%E3%80%8DFools-and-Roads%2F</url>
    <content type="text"><![CDATA[给一棵有根树和一些路线，路线上的边权都+1，求所有边的权值 链接CodeForces 191C 题解这个题目的输出是每一条边所经过的次数，所以想到树上边差分。在差分之后确实是晕了，没有想到好的方法，但是突然想到了DFS求树上前缀和，对于每一条边，只要计算深度小的前缀和-深度大的前缀和即得答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev; &#125;;ll nc,ec,query,root,from,to;ll depth[500010],anc[500010][31],last[500010],diff[500010],prefix[500010],LCA,maxn;ll From[500010],To[500010];edge ed[500010*2];inline void addEdge(ll from,ll to)&#123; ed[++ec].prev=last[from]; ed[ec].to=to; last[from]=ec;&#125;inline void dfs(ll node)&#123; ll son; for(register int i=last[node];i!=0;i=ed[i].prev) &#123; son=ed[i].to; if(!depth[son]) &#123; depth[son]=depth[node]+1; anc[son][0]=node; dfs(son); &#125; &#125;&#125;inline void LCASetup()&#123; depth[1]=1; anc[1][0]=0; dfs(1); for(register int i=1;i&lt;=21;i++) &#123; for(register int j=1;j&lt;=nc;j++) &#123; anc[j][i]=anc[anc[j][i-1]][i-1]; &#125; &#125;&#125;inline ll lca(ll x,ll y)&#123; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; for(register int i=21;i&gt;=0;i--) &#123; if(depth[anc[y][i]]&gt;=depth[x]) &#123; y=anc[y][i]; &#125; &#125; if(x==y) &#123; return x; &#125; for(register int i=21;i&gt;=0;i--) &#123; if(anc[x][i]!=anc[y][i]) &#123; x=anc[x][i]; y=anc[y][i]; &#125; &#125; return anc[x][0];&#125;inline void ddfs(ll node)&#123; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to==anc[node][0]) &#123; continue; &#125; ddfs(ed[i].to); diff[node]+=diff[ed[i].to]; &#125;&#125;inline void dffs(ll node,ll val)&#123; prefix[node]=diff[node]+val; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to==anc[node][0]) &#123; continue; &#125; dffs(ed[i].to,prefix[node]); &#125;&#125;int main()&#123; scanf("%d",&amp;nc); for(register int i=0;i&lt;nc-1;i++) &#123; scanf("%d%d",&amp;from,&amp;to); From[i]=from,To[i]=to; addEdge(from,to); addEdge(to,from); &#125; LCASetup(); scanf("%d",&amp;query); for(register int i=0;i&lt;query;i++) &#123; scanf("%d%d",&amp;from,&amp;to); LCA=lca(from,to); diff[from]++,diff[to]++,diff[LCA]-=2; &#125; ddfs(1); dffs(1,0); for(register int i=0;i&lt;nc-1;i++) &#123; if(depth[From[i]]&lt;depth[To[i]]) &#123; swap(From[i],To[i]); &#125; printf("%d ",prefix[From[i]]-prefix[To[i]]); &#125;&#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>CodeForces</tag>
        <tag>LCA</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
</search>
