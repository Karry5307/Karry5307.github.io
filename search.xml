<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「Luogu P4148」简单题]]></title>
    <url>%2F2019%2F07%2F21%2F%E3%80%8CLuogu-P4148%E3%80%8D%E7%AE%80%E5%8D%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[给定一个$n\times n$的矩阵$a$，初始状态下所有元素均为$0$，还有$m$个操作，这些操作分为以下$3$种： 1 x y z：将$a_{x,y}$加上$z$ 2 x1 y1 x2 y2：求出$\sum\limits_{i=x_1}^{x_2}\sum\limits_{j=y_1}^{y_2}a_{i,j}$。 3：终止程序。 对于所有的修改和询问要求强制在线。 $\texttt{Data Range:}n\leq 5\times 10^5,m\leq 2\times 10^5$ 链接题解一道$\texttt{kdt}$的模板题因为参数次序出问题让我调了好久 如果不要求强制在线，那么可以考虑$\texttt{cdq}$分治或整体二分。 可是既然强制在线，那么这就变成了一道$\texttt{KD Tree}$的模板题。 没什么好说的，所以这里放一张图： 呵呵。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e5+51;const double alpha=0.75;ll dim;struct Node&#123; ll d[2]; ll val; inline bool operator &lt;(const Node &amp;rhs)const;&#125;;struct KDTree&#123; Node nd; ll sum,size; ll minn[2],maxn[2],ch[2]; inline void clear() &#123; minn[0]=minn[1]=maxn[0]=maxn[1]=sum=size=nd.d[0]=nd.d[1]=nd.val=0; &#125;&#125;;Node nd[MAXN];KDTree tree[MAXN];ll cnt,ptr,ptr2,tot,x,y,xx,yy,z,op,lastAns,rt;ll pool[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125; inline void chkmin(ll &amp;x,ll y)&#123; if(x&gt;y) &#123; x=y; &#125;&#125;inline void chkmax(ll &amp;x,ll y)&#123; if(x&lt;y) &#123; x=y; &#125;&#125;inline bool Node::operator &lt;(const Node &amp;rhs)const&#123; return this-&gt;d[dim]&lt;rhs.d[dim]; &#125; inline ll newNode()&#123; if(!ptr) &#123; return ++tot; &#125; tree[pool[ptr]].clear(); return pool[ptr--];&#125;inline void update(ll x,ll y)&#123; chkmin(tree[x].minn[0],tree[y].minn[0]); chkmin(tree[x].minn[1],tree[y].minn[1]); chkmax(tree[x].maxn[0],tree[y].maxn[0]); chkmax(tree[x].maxn[1],tree[y].maxn[1]);&#125;inline void update(ll node)&#123; ll ls=tree[node].ch[0],rs=tree[node].ch[1]; tree[node].minn[0]=tree[node].maxn[0]=tree[node].nd.d[0]; tree[node].minn[1]=tree[node].maxn[1]=tree[node].nd.d[1]; tree[node].size=tree[ls].size+tree[rs].size+1; tree[node].sum=tree[ls].sum+tree[rs].sum+tree[node].nd.val; if(ls) &#123; update(node,ls); &#125; if(rs) &#123; update(node,rs); &#125;&#125;inline ll create(ll l,ll r,ll d)&#123; ll mid=(l+r)&gt;&gt;1; dim=d,nth_element(nd+l,nd+mid,nd+r+1); ll node=newNode(); tree[node].nd=nd[mid]; tree[node].ch[0]=l&lt;mid?create(l,mid-1,d^1):0; tree[node].ch[1]=r&gt;mid?create(mid+1,r,d^1):0; update(node); return node;&#125;inline void pia(ll node)&#123; if(tree[node].ch[0]) &#123; pia(tree[node].ch[0]); &#125; nd[++ptr2]=tree[node].nd; pool[++ptr]=node; if(tree[node].ch[1]) &#123; pia(tree[node].ch[1]); &#125;&#125;inline void check(ll &amp;node,ll d)&#123; ll ls=tree[node].ch[0],rs=tree[node].ch[1]; double sz=alpha*tree[node].size; if(sz&lt;tree[ls].size||sz&lt;tree[rs].size) &#123; ptr2=0,pia(node),node=create(1,ptr2,d); &#125;&#125;inline void insert(Node nd,ll d,ll &amp;node)&#123; if(!node) &#123; node=newNode(),tree[node].nd=nd,update(node); return; &#125; ll x=tree[node].nd.d[d]&lt;nd.d[d]; insert(nd,d^1,tree[node].ch[x]); update(node),check(node,d);&#125;inline ll check(KDTree nd,ll x,ll y,ll xx,ll yy)&#123; ll p=nd.minn[0],q=nd.minn[1],r=nd.maxn[0],s=nd.maxn[1]; if(x&lt;=p&amp;&amp;xx&gt;=r&amp;&amp;y&lt;=q&amp;&amp;yy&gt;=s) &#123; return 1; &#125; if((xx&lt;p||x&gt;r)||(yy&lt;q||y&gt;s)) &#123; return 0; &#125; return 2;&#125;inline ll query(ll x,ll y,ll xx,ll yy,ll node)&#123; ll chk,res=0,p=tree[node].nd.d[0],q=tree[node].nd.d[1]; ll ls=tree[node].ch[0],rs=tree[node].ch[1]; if(p&gt;=x&amp;&amp;p&lt;=xx&amp;&amp;q&gt;=y&amp;&amp;q&lt;=yy) &#123; res+=tree[node].nd.val; &#125; if(ls) &#123; chk=check(tree[ls],x,y,xx,yy); if(chk==1) &#123; res+=tree[ls].sum; &#125; if(chk==2) &#123; res+=query(x,y,xx,yy,ls); &#125; &#125; if(rs) &#123; chk=check(tree[rs],x,y,xx,yy); if(chk==1) &#123; res+=tree[rs].sum; &#125; if(chk==2) &#123; res+=query(x,y,xx,yy,rs); &#125; &#125; return res;&#125;int main()&#123; cnt=read(); while(1) &#123; op=read(); if(op==3) &#123; return 0; &#125; if(op==1) &#123; x=read()^lastAns,y=read()^lastAns,z=read()^lastAns; insert((Node)&#123;x,y,z&#125;,0,rt); &#125; else &#123; x=read()^lastAns,y=read()^lastAns; xx=read()^lastAns,yy=read()^lastAns; printf("%d\n",lastAns=query(x,y,xx,yy,rt)); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>KD Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·KD Tree]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7KD-Tree%2F</url>
    <content type="text"><![CDATA[博客日日咕系列。 等我做完简单题再来更吧。 机房里的人全会就我不会系列。]]></content>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4389」[APIO2013]出题人]]></title>
    <url>%2F2019%2F07%2F19%2F%E3%80%8CLuogu-P3640%E3%80%8D-APIO2013-%E5%87%BA%E9%A2%98%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[题面不会解释。 链接题解前言对于给出的三份$\texttt{SSSP}$的程序，考虑分析其时间复杂度。 $\texttt{Floyd:}$无论如何都是$O(n^3)$，与询问无关。 $\texttt{Dijkstra:}$搞了个堆优化，$O(n\log n)$，一上负权图就$\texttt{GG}$。 $\texttt{Bellman-Ford:}$一旦有负权照样退化成$O(qnm)$。 $\texttt{Subtask 1}$卡$\texttt{Floyd}$，让$\texttt{Dijkstra}$过。 由于$\texttt{Floyd}$总是$O(n^3)$，所以考虑构造一个$101$个点的图，没有边，就可以卡掉了。 $\texttt{Subtask 2}$卡$\texttt{Bellman-Ford}$，让$\texttt{Floyd}$过。 要让$\texttt{Floyd}$过，$n=100$即可。然后每个点随机连一些负权边，让$\texttt{Bellman-Ford}$不断的进行松弛操作，再带上$10$组询问就可以卡掉了。 这里我的策略是前$50$个点随机连$11$条边，后$50$个点随机连$10$条边，在这种随机图上很容易卡掉。 $\texttt{Subtask 3}$跟$\texttt{Subtask 1}$一样。 $\texttt{Subtask 4}$卡$\texttt{Dijkstra}$，让$\texttt{Floyd}$过。 先来看一个图： 这样一个图诱导$\texttt{Dijkstra}$走边权为$0$的边，走着走着就发现原来的那条不是最短路，就白白走了许多路径。用这种方法卡掉即可。 $\texttt{Subtask 5}$卡$\texttt{Bellman-Ford}$，让$\texttt{Dijkstra}$过。 考虑到代码中的一个性质：每一次都是所有顶点进行松弛操作，而且只要有改变最短路就可以再松弛一遍，所以考虑构造一堆自己连向自己的负环，再在$0$和$1$之间连重边就可以卡掉啦qwq。 $\texttt{Subtask 6}$只要你$\texttt{Subtask 4}$做得好的话，这个点也是一样的。 $\texttt{Subtask 7}$染色问题，让你卡爆搜。 生成一个随机图就可以啦。 $\texttt{Subtask 8}$让你构造数据使得爆搜通过。 考虑把点染色，异色的点之间连边，同色点之间不连边，于是就完了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e5+51;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125; inline void hack1()&#123; puts("101"); for(register int i=0;i&lt;101;i++) &#123; puts("0"); &#125; puts("1\n1 100");&#125;inline void hack2()&#123; ll edges; puts("100"); for(register int i=0;i&lt;100;i++) &#123; edges=i&lt;50?11:10; printf("%d ",edges); for(register int j=0;j&lt;edges;j++) &#123; printf("%d %d ",rand()%100,-1); &#125; puts(""); &#125; puts("10"); for(register int i=0;i&lt;10;i++) &#123; puts("0 99"); &#125;&#125;inline void hack3()&#123; puts("101"); for(register int i=0;i&lt;101;i++) &#123; puts("0"); &#125; puts("1\n1 100");&#125;inline void hack4()&#123; ll k=131072; puts("33"); for(register int i=0;i&lt;32;i++) &#123; if(i&amp;1) &#123; printf("1 %d %d",i+1,-(k&lt;&lt;1)),k&gt;&gt;=1; &#125; else &#123; printf("2 %d 0 %d %d",i+2,i+1,k); &#125; puts(""); &#125; puts("0\n6"); for(register int i=0;i&lt;6;i++) &#123; puts("0 32"); &#125;&#125;inline void hack5()&#123; puts("300\n1 1 1\n0"); for(register int i=2;i&lt;300;i++) &#123; printf("%d ",i&lt;6?12:1); for(register int j=0;j&lt;(i&lt;6?12:1);j++) &#123; printf("%d -1 ",i); &#125; puts(""); &#125; puts("10"); for(register int i=0;i&lt;10;i++) &#123; puts("0 1"); &#125;&#125;inline void hack6()&#123; ll k=131072; puts("33"); for(register int i=0;i&lt;32;i++) &#123; if(i&amp;1) &#123; printf("1 %d %d",i+1,-(k&lt;&lt;1)),k&gt;&gt;=1; &#125; else &#123; printf("2 %d 0 %d %d",i+2,i+1,k); &#125; puts(""); &#125; puts("0\n6"); for(register int i=0;i&lt;6;i++) &#123; puts("0 32"); &#125;&#125;inline void hack7()&#123; ll x,y; static ll vis[75][75]; puts("71 1501"); for(register int i=0;i&lt;1501;i++) &#123; x=rand()%71,y=rand()%71; while(vis[x][y]||x==y) &#123; x=rand()%71,y=rand()%71; &#125; printf("%d %d\n",x,y),vis[x][y]=vis[y][x]=1; &#125;&#125;inline void hack8()&#123; ll x,y; static ll color[151],vis[151][151]; puts("101 1501"); for(register int i=0;i&lt;101;i++) &#123; color[i]=i%2; &#125; for(register int i=0;i&lt;1501;i++) &#123; x=rand()%101,y=rand()%101; while(vis[x][y]||x==y||color[x]==color[y]) &#123; x=rand()%101,y=rand()%101; &#125; printf("%d %d\n",x,y),vis[x][y]=vis[y][x]=1; &#125;&#125; int main()&#123;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>洛谷</tag>
        <tag>提交答案题</tag>
        <tag>最短路</tag>
        <tag>Floyd</tag>
        <tag>Dijkstra</tag>
        <tag>Bellman-Ford</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4389」付公主的背包]]></title>
    <url>%2F2019%2F07%2F19%2F%E3%80%8CLuogu-P4389%E3%80%8D%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85%2F</url>
    <content type="text"><![CDATA[给定$n$种物品，每种物品的体积为$w_i$，有无限个。对于$c\in[1,m]$，求出用这些物品正好装满体积为$c$的背包的总数。 $\texttt{Data Range:}n,m\leq 10^5,w_i\leq m$ 链接Luogu P4389 题解考虑写出每种物品的生成函数。 如果没有体积的限制，那生成函数是 F(x)=\sum\limits_{i=0}^{\infty}x^i但是有了体积的限制，咋办？ 考虑将一个体积为$v$的物品拆成$v$个体积为$1$的物品，再把这些体积为$1$的物品每$v$个捆绑成一组。所以说，你每次只能拿$v$的倍数个体积为$1$的物品，那么生成函数就是 F(x)=\sum\limits_{i=0}^{\infty}[i\bmod v=0]x^i也即 F(x)=1+x^v+(x^v)^2+(x^v)^3+\cdots写成封闭形式，有 F(x)=\frac{1}{1-x^v}于是答案就是每种物品对应的生成函数的卷积。可是时间复杂度过高，考虑优化。 假设第$i$种物品所对应的生成函数为$F_i(x)$，答案所对应的生成函数为$G(x)$，则 G(x)=\prod\limits_{i=0}^{n}F_i(x)于是很自然的想到两边取对数，有 \ln G(x)=\sum\limits_{i=0}^{n}\ln F_i(x)暴力的求$\ln F_i(x)$是$O(n^2\log n)$的，所以考虑巧妙的求，所以开始推柿子。 设$H(x)=\ln F(x)$，则 H^\prime(x)=\frac{F^\prime(x)}{F(x)}展开得 H^\prime(x)=(1-x^v)\sum\limits_{i=1}^{\infty}ivx^{iv-1}暴力乘上去 H^\prime(x)=\sum\limits_{i=1}^{\infty}vx^{iv-1}所以说 H(x)=\sum\limits_{i=1}^{\infty}\frac{x^{iv}}{i}对每种物品求出该多项式相加后$\texttt{exp}$即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef long long int li;const ll MAXN=4e5+51,MOD=998244353,G=3,INVG=332748118;ll cnt,fd;ll f[MAXN],tmp[MAXN],res[MAXN],rev[MAXN],fact[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll qpow(ll base,ll exponent)&#123; li res=1; while(exponent) &#123; if(exponent&amp;1) &#123; res=(li)res*base%MOD; &#125; base=(li)base*base%MOD,exponent&gt;&gt;=1; &#125; return res;&#125;inline void setup(ll ccnt)&#123; fact[0]=fact[1]=1; for(register int i=2;i&lt;=ccnt;i++) &#123; fact[i]=(li)fact[i-1]*i%MOD; &#125;&#125;inline void NTT(ll *cp,ll cnt,ll inv)&#123; ll cur=0,res=0,omg=0; for(register int i=0;i&lt;cnt;i++) &#123; if(i&lt;rev[i]) &#123; swap(cp[i],cp[rev[i]]); &#125; &#125; for(register int i=2;i&lt;=cnt;i&lt;&lt;=1) &#123; cur=i&gt;&gt;1,res=qpow(inv==1?G:INVG,(MOD-1)/i); for(register ll *p=cp;p!=cp+cnt;p+=i) &#123; omg=1; for(register int j=0;j&lt;cur;j++) &#123; ll t=(li)omg*p[j+cur]%MOD,t2=p[j]; p[j+cur]=(t2-t+MOD)%MOD,p[j]=(t2+t)%MOD; omg=(li)omg*res%MOD; &#125; &#125; &#125; if(inv==-1) &#123; ll invl=qpow(cnt,MOD-2); for(register int i=0;i&lt;=cnt;i++) &#123; cp[i]=(li)cp[i]*invl%MOD; &#125; &#125;&#125;inline void deriv(ll fd,ll *f,ll *res)&#123; for(register int i=1;i&lt;fd;i++) &#123; res[i-1]=(li)f[i]*i%MOD; &#125; res[fd-1]=0;&#125;inline void integ(ll fd,ll *f,ll *res)&#123; for(register int i=1;i&lt;fd;i++) &#123; res[i]=(li)f[i-1]*qpow(i,MOD-2)%MOD; &#125; res[0]=0;&#125;inline void inv(ll fd,ll *f,ll *res)&#123; static ll tmp[MAXN]; if(fd==1) &#123; res[0]=qpow(f[0],MOD-2); return; &#125; inv((fd+1)&gt;&gt;1,f,res); ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=i&lt;fd?f[i]:0; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp,cnt,1),NTT(res,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; res[i]=(li)(2-(li)tmp[i]*res[i]%MOD+MOD)%MOD*res[i]%MOD; &#125; NTT(res,cnt,-1); for(register int i=fd;i&lt;cnt;i++) &#123; res[i]=0; &#125;&#125;inline void ln(ll fd,ll *f,ll *res)&#123; static ll pinv[MAXN],der[MAXN]; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; inv(fd,f,pinv),deriv(fd,f,der); for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(pinv,cnt,1),NTT(der,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=(li)der[i]*pinv[i]%MOD; &#125; NTT(der,cnt,-1),integ(fd,der,res); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=pinv[i]=0; &#125;&#125;inline void exp(ll fd,ll *f,ll *res)&#123; static ll texp[MAXN]; if(fd==1) &#123; res[0]=1; return; &#125; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; exp((fd+1)&gt;&gt;1,f,res),ln(fd,res,texp); for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; texp[0]=(f[0]+1-texp[0]+MOD)%MOD; for(register int i=1;i&lt;fd;i++) &#123; texp[i]=(f[i]-texp[i]+MOD)%MOD; &#125; NTT(texp,cnt,1),NTT(res,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; res[i]=(li)res[i]*texp[i]%MOD; &#125; NTT(res,cnt,-1); for(register int i=0;i&lt;cnt;i++) &#123; texp[i]=0,res[i]=i&lt;fd?res[i]:0; &#125;&#125;int main()&#123; cnt=read(),fd=read(); for(register int i=0;i&lt;cnt;i++) &#123; tmp[read()]++; &#125; for(register int i=1;i&lt;=fd;i++) &#123; if(tmp[i]) &#123; for(register int j=i;j&lt;=fd;j+=i) &#123; f[j]=(f[j]+(li)tmp[i]*i%MOD*qpow(j,MOD-2)%MOD)%MOD; &#125; &#125; &#125; exp(fd+1,f,res); for(register int i=1;i&lt;=fd;i++) &#123; printf("%d\n",res[i]); &#125;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>生成函数</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4366」[Code+#4]最短路]]></title>
    <url>%2F2019%2F07%2F14%2F%E3%80%8CLuogu-P4366%E3%80%8D-Code-4-%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[给定一个$n$个点的有向图和一个常数$c$，其中对于任意的$i$和$j$，有一条边权$(i\operatorname{xor}j)\times C$的边。还给定$m$条边，第$i$条边从$u_i$到$v_i$，边权为$w_i$，求出$s$到$t$的最短路。 $\texttt{Data Range:}n\leq 10^5,m\leq 5\times 10^5,1\leq u_i,v_i\leq n,1\leq w_i\leq 100$ 链接Luogu P4366 LOJ 6354 题解直接建图跑最短路是不行的，因为边数是$n^2m$级别的，要优化建图。 对于$x$到$y$的边，其权值为$x\operatorname{xor}y$，也即 x\operatorname{xor}y_0\operatorname{xor}y_1\operatorname{xor}\cdots\operatorname{xor}y_{31}其中，$y_i$为$y$在二进制下第$i$位的值$\times2^i$。 为什么呢？ 因为对于每一次异或，只会修改一个位置上的数，对别的位置没有影响。所以说从$x$到$y$只需要这样一个一个走即可，对答案没有影响 所以只需要对任意的点$i$向$2^j$连$i\operatorname{xor}2^j$的边，再跑最短路即可，边数立马降至$n\log n+m$级别。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// luogu-judger-enable-o2#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e5+51,MAXM=2.2e6+51;struct Edge&#123; ll to,prev,dist;&#125;;struct Tuple&#123; ll node,dist; inline bool operator &lt;(const Tuple &amp;rhs)const &#123; return this-&gt;dist&gt;rhs.dist; &#125;&#125;;Edge ed[MAXM];priority_queue&lt;Tuple&gt;pq;ll nc,ec,tot,from,to,dist,wt,source;ll last[MAXN],minn[MAXN],inQueue[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to,ll dist)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; ed[tot].dist=dist; last[from]=tot;&#125;inline void Dijkstra(ll source)&#123; ll top; memset(minn,0x3f,sizeof(minn)); pq.push((Tuple)&#123;source,0&#125;),minn[source]=0,inQueue[source]=1; while(!pq.empty()) &#123; top=pq.top().node,pq.pop(); for(register int i=last[top];i;i=ed[i].prev) &#123; if(minn[top]+ed[i].dist&lt;minn[ed[i].to]) &#123; minn[ed[i].to]=minn[top]+ed[i].dist; pq.push((Tuple)&#123;ed[i].to,minn[ed[i].to]&#125;); &#125; &#125; &#125;&#125;int main()&#123; nc=read(),ec=read(),wt=read(); for(register int i=0;i&lt;ec;i++) &#123; from=read(),to=read(),dist=read(); addEdge(from,to,dist); &#125; for(register int i=0;i&lt;=nc;i++) &#123; for(register int j=1;j&lt;=nc;j&lt;&lt;=1) &#123; if((i^j)&lt;=nc) &#123; addEdge(i,i^j,j*wt); &#125; &#125; &#125; Dijkstra(source=read()); printf("%d\n",minn[to=read()]);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>LOJ</tag>
        <tag>CodePlus</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu-P5431」【模板】乘法逆元2]]></title>
    <url>%2F2019%2F06%2F30%2F%E3%80%8CLuogu-P5431%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%B9%98%E6%B3%95%E9%80%86%E5%85%832%2F</url>
    <content type="text"><![CDATA[给定$n$个正整数$a_i$，求出在$\bmod p$意义下$\sum\limits_{i=1}^{n}k^i\cdot a_i^{-1}$ $\texttt{Data Range:}1\leq n\leq 5\times 10^6,2\leq k]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>数论，数学</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·多项式专题（三）]]></title>
    <url>%2F2019%2F06%2F23%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在这一篇文章里，我们来谈一谈上升幂，下降幂多项式，斯特林数以及一些优美的结论。 前言如果有什么比如说像链接有问题或者是别的问题，包括不懂的，请在下面发讨论。 下降幂多项式的定义下降幂多项式（$\texttt{Falling Factorial Polynomial}$，也即$\texttt{FFP}$），也称下降阶乘幂多项式，是一类特殊的多项式。 首先，看一下下降幂单项式的递归定义： x^{\underline n}=\begin{cases}1, & n=0\\x\times (x-1)^{n-1} & n\geq 1,\end{cases}所以说，$x^{\underline 0}=1$，那么$x^{\underline 1}$呢？ x^{\underline 1}=x\times (x-1)^{\underline 0}=x那么有 x^{\underline 2}=x\times (x-1)^{\underline 1}=x(x-1)=x^2-xx^{\underline 3}=x\times (x-1)^{\underline 2}=x(x-1)(x-2)=x^3-3x^2+2x于是可以得出一个普遍的结论，就是 x^{\underline n}=x(x-1)\cdots(x-n+1)=\frac{x!}{(x-n)!}=n!C_x^n$x^{\underline n}=n!C^n_x$这个公式很重要，因为$x^{\underline n}$与两类斯特林数有强关联。 那么，下降幂多项式，是由许多个下降幂单项式相加得来的，如 3x^{\underline 2}+2x^{\underline 1}+1=3x(x-1)+2x+1=3x^2-x+1普通多项式转下降幂多项式Luogu P5383 首先看一个简单的结论： n^m=\sum\limits_{i=0}^{m}i!S^i_mC^i_n其中$S$表示第二类斯特林数。 为什么呢？考虑等号两边的组合意义。 左边是$n$个球任意放$m$个盒子的答案，右边的话枚举非空盒子的数量，用组合数枚举一下，最后由于盒子不同，所以要乘个$i!$。 所以，把它拓展一下，得到一个跳跃性结论： x^n=\sum\limits_{i=0}^{n}i!S^i_nC^i_x这时，我们看到了$i!C_i^x$的形式，考虑把它转成下降幂多项式，那么就会有 x^n=\sum\limits_{i=0}^{n}S^i_nx^{\underline i}于是我们就把普通单项式转换成了一个下降幂单项式。但如果拓展成普通多项式，结论又会是什么？ 设$n$次多项式$F(x)$的系数数列为$f$，那么有 F(x)=\sum\limits_{i=0}^nf_ix^i把结论用上去，有 F(x)=\sum\limits_{i=0}^nf_i\sum\limits_{j=0}^{i}S_i^jx^{\underline j}这里有一个小$\texttt{trick}$，改变求和顺序！所以说 F(x)=\sum\limits_{j=0}^nx^{\underline j}\sum\limits_{i=j}^{n}S_i^jf_i本来$i$的下界应该是$0$的，但是当$i&lt;j$时$S_i^j=0$，所以可以将$i$的下界改成$j$。 这就是一个下降幂多项式的形式了，看来问题解决了！但是后面一长串和式该怎么求？ 这里有一个小结论：（证明在下面，用心找可以找得到） S^n_m=\sum\limits_{i=0}^n\frac{(-1)^{n-i}}{(n-i)!}\cdot\frac{i^m}{i!}所以，把结论用上去啊。。。 \sum\limits_{i=j}^{n}S_i^jf_i=\sum\limits_{i=j}^{n}\sum\limits_{k=0}^{j}\frac{(-1)^{j-k}}{(j-k)!}\cdot\frac{f_ik^i}{k!}改变求和顺序，有 \sum\limits_{i=j}^{n}S_i^jf_i=\sum\limits_{k=0}^{j}\frac{(-1)^{j-k}}{(j-k)!}\cdot\sum\limits_{i=j}^{n}\frac{f_ik^i}{k!}这就是卷积的形式了，直接$\texttt{NTT}$就好啦qwq。但是求后面那个和式要多点求值。 接着就是神奇的上代码环节啦。。。（包括预处理） 12345678910111213141516171819202122232425262728inline void polyToFFP(ll fd,ll *f,ll *res)&#123; static ll pts[MAXN&gt;&gt;1],tmp[MAXN],tmp2[MAXN]; for(register int i=0;i&lt;fd;i++) &#123; pts[i]=i,tmp[i]=(i&amp;1)?MOD-finv[i]:finv[i]; &#125; eval(fd,fd,f,pts,tmp2); for(register int i=0;i&lt;fd;i++) &#123; tmp2[i]=(li)tmp2[i]*finv[i]%MOD,pts[i]=0; &#125; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp2,cnt,1),NTT(tmp,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; res[i]=(li)tmp[i]*tmp2[i]%MOD,tmp[i]=tmp2[i]=0; &#125; NTT(res,cnt,-1);&#125; 下降幂多项式乘法Luogu P5394 首先，拿题目的样例来解释一下： $\quad(3x^{\underline 2}+2x^{\underline 1}+1)(4x^{\underline 3}+3x^{\underline 2}+2x^{\underline 1}+1)$$=(3x^2-x+1)(4x^3-9x^2+7x+1)$$=12x^5-30x^4+34x^3-12x^2+6x+1$$=12x^{\underline 5}+89x^{\underline 4}+148^{\underline 3}+52x^{\underline 2}+8x^{\underline 1}+1$ 难道要普通多项式与下降幂多项式的转换吗？题目难度告诉我们不要。但又怎么做呢？ 考虑通过$\texttt{EGF}$将普通多项式与下降幂多项式建立联系，自然考虑下降幂单项式$x^{\underline n}$的$\texttt{EGF}$，设它为$g(x)$，那么有： g(x)=\sum\limits_{i=n}^{\infty}\frac{i!}{(i-n)!i!}x^i把$x^n$提出来并约分 g(x)=x^n\sum\limits_{i=n}^{\infty}\frac{1}{(i-n)!}x^{i-n}改变求和符号的变量 g(x)=x^n\sum\limits_{i=0}^{\infty}\frac{x^i}{i!}和式就是$e^x$的麦克劳林级数，所以 g(x)=x^ne^x设$F(x)$为下降幂多项式$f(x)$点值的$\texttt{EGF}$，$G(x)$为下降幂多项式$f(x)$系数的$\texttt{EGF}$，$f$是$f(x)$的系数数组，因为 f(x)=\sum\limits_{i=0}^{n}f_ix^{\underline i}所以 F(x)=\sum\limits_{i=0}^{n}f_ie^xx^i把$e^x$提出来 F(x)=e^x\sum\limits_{i=0}^{n}f_ix^iF(x)=e^xG(x)所以说，下降幂多项式的点值和系数是可以互相转换的。只要得到两个下降幂多项式的点值，把对应点值乘起来再转系数就可以了，这些操作都可以通过简单的多项式乘法实现。 于是上一个令人身心愉悦的代码qwq（预处理跟上面的代码一模一样） 12345678910111213141516171819202122232425262728293031323334353637383940414243inline void FFPMul(ll fd,ll gd,ll *f,ll *g,ll *res)&#123; static ll tmp[MAXN],tmpf[MAXN],tmpg[MAXN]; ll cnt=1,limit=-1; for(register int i=0;i&lt;fd;i++) &#123; tmpf[i]=f[i]; &#125; for(register int i=0;i&lt;gd;i++) &#123; tmpg[i]=g[i]; &#125; for(register int i=0;i&lt;fd+gd-1;i++) &#123; tmp[i]=finv[i]; &#125; while(cnt&lt;(fd+gd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmpf,cnt,1),NTT(tmpg,cnt,1),NTT(tmp,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; tmpf[i]=(li)tmpf[i]*tmp[i]%MOD,tmpg[i]=(li)tmpg[i]*tmp[i]%MOD; &#125; NTT(tmpf,cnt,-1),NTT(tmpg,cnt,-1); for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=i&lt;fd+gd-1?(i&amp;1?(MOD-finv[i]):finv[i]):0; tmpf[i]=i&lt;fd+gd-1?(li)tmpf[i]*tmpg[i]%MOD*fact[i]%MOD:0; &#125; NTT(tmpf,cnt,1),NTT(tmp,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; res[i]=(li)tmpf[i]*tmp[i]%MOD,tmpf[i]=tmpg[i]=tmp[i]=0; &#125; NTT(res,cnt,-1);&#125; 第二类斯特林数·行Luogu P5395 不知道第二类斯特林数的去看组合专题（大坑）。 还记得上面那个有关于第二类斯特林数的结论吗？ 可是这又与这题有什么关系呢？ 很明显，$m\leq n$，所以把和式上界改一下，为后续做准备 n^m=\sum\limits_{i=0}^{n}i!S^i_mC^i_n然后再设$f(n)=n^m,g(i)=i!S^i_m$，那么有 f(n)=\sum\limits_{i=0}^{n}C^i_ng(i)这是什么？二项式反演啊，所以反演一下 g(n)=\sum\limits_{i=0}^{n}(-1)^{n-i}C^i_nf(i)再换回来 n!S^n_m=\sum\limits_{i=0}^n(-1)^{n-i}i^mC^i_n把阶乘除过去，把组合数拆出来 S^n_m=\sum\limits_{i=0}^n\frac{1}{n!}\cdot\frac{n!}{i!(n-i)!}(-1)^{n-i}i^m约个分 S^n_m=\sum\limits_{i=0}^n\frac{(-1)^{n-i}i^m}{i!(n-i)!}然后再拆一下 S^n_m=\sum\limits_{i=0}^n\frac{(-1)^{n-i}}{(n-i)!}\cdot\frac{i^m}{i!}很明显的卷积形式啊。。。$\texttt{NTT}$做就行啦qwq 时间复杂度$O(n\log n)$ 代码呢？不见了。。。 第二类斯特林数·列Luogu P5396 我们先从一个小结论入手（从维基百科蒯的）: \sum\limits_{i=n}^{\infty}\frac{S_i^n}{i!}x^i=\frac{(e^x-1)^n}{n!}证明留给读者做练习这掩盖不了我不会证的事实 这里主要讲讲求法。 很明显的把$e^x-1$拆开 e^x-1=\sum\limits_{i=1}^\infty\frac{x^n}{n!}构造这样一个多项式，$n$次方之后对每一个系数乘上$n!$的逆元，再对于$x^i$的系数乘上$i!$就没了 时间复杂度$O(n\log n)$，代码无。 第一类斯特林数·列先看一个恒等式 (x+1)^n=(x+1)^n你可能会想，这样一个恒等式与斯特林数有啥关系嘛。且听我慢慢道来。 左边二项式展开，右边化成指数形式，有 \sum\limits_{i=0}^{n}C_n^ix^i=e^{n\ln (x+1)}当$i&gt;n$时，显然，$C_n^i=0$，所以左边改变求和上界，右边泰勒展开，有 \sum\limits_{i=0}^{\infty}C_n^ix^i=\sum\limits_{i=0}^{\infty}\frac{n^i\ln(x+1)^i}{i!}把组合数拆成下降幂的形式 \sum\limits_{i=0}^{\infty}\frac{x^i}{i!} n^{\underline i}=\sum\limits_{i=0}^{\infty}\frac{n^i\ln(x+1)^i}{i!}下降幂拆成第一类斯特林数 \sum\limits_{i=0}^{\infty}\frac{x^i}{i!} \sum\limits_{j=0}^{i}(-1)^{i-j}s_i^jn^i=\sum\limits_{i=0}^{\infty}\frac{n^i\ln(x+1)^i}{i!}整理一下 \sum\limits_{i=0}^{\infty}n^i \sum\limits_{j=i}^{\infty}\frac{(-1)^{j-i}s_j^ix^j}{j!}=\sum\limits_{i=0}^{\infty}\frac{n^i\ln(x+1)^i}{i!}两边约掉 \sum\limits_{j=i}^{\infty}\frac{(-1)^{j-i}s_j^ix^j}{j!}=\frac{\ln(x+1)^i}{i!}这样就没了啊。。。用多项式$\ln$和快速幂做，时间复杂度$O(n\log n)$ 第一类斯特林数·行Luogu P5408 应$\texttt{M}$$\texttt{_sea}$的要求，这里终于不咕咕了。 这里可是最最最卡常的地方了！ 首先，我们可以自然的想到一个做法。原理是这样 x^{\overline n}=\sum\limits_{i=0}^ns_n^ix^i而 x^{\overline n}=\prod_{i=0}^{n-1}(x+i)所以考虑直接分治乘法即可，时间复杂度$O(n\log^2n)$ 可是这样过不去。考虑倍增，有 x^{\overline{2n}}=x^{\overline n}(x+n)^{\overline n}假设$F(x)=x^{\overline n}$，我们当前的目标是求出$F(x+n)$，所以 F(x+n)=\sum\limits_{i=0}^{n}f_i(x+n)^i强行展开 F(x+n)=\sum\limits_{i=0}^{n}f_i\sum\limits_{j=0}^{i}C_i^jn^{i-j}x^j合并一下 F(x+n)=\sum\limits_{j=0}^{n}\frac{x^j}{j!}\sum\limits_{i=0}^{j}i!f_i\frac{n^{j-i}}{(j-i)!}把$i!f_i$翻转一下做一次卷积即可。时间复杂度$O(n\log n)$，要卡卡常。]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
        <tag>组合数学</tag>
        <tag>数论，数学</tag>
        <tag>Stirling数</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2495」[SDOI2011]消耗战]]></title>
    <url>%2F2019%2F06%2F19%2F%E3%80%8CLuogu-P2495%E3%80%8D-SDOI2011-%E6%B6%88%E8%80%97%E6%88%98%2F</url>
    <content type="text"><![CDATA[给定一棵有$n$个节点的带边权树和$q$组询问，第$i$条边的边权为$w_i$。对于每组询问，给定$m$个关键点$k_i$，你要给出一个边集使得割掉这些边会$1$号节点无法到达任意一个关键点。为了方便，你只需要求出这个边集所包含的边的最小边权就行了。 $\texttt{Data Range}:2\leq 2\leq 2.5\times 10^5,m\geq 1,\sum k_i\leq 5\times 10^5,w_i\leq 10^5$ 前言生地终于考完了，我是不能阿克的。 链接Luogu P2495 BZOJ 2286 题解这道题普通$\texttt{dp}$显然是$O(nm)$的，布星，只有$\texttt{40 pts}$，吸氧后还是只有$\texttt{50 pts}$。 所以说，怎么做呢？ 注意到，$\sum k_i\leq 5\times 10^5$，所以，这道题能不能考虑对关键点动(luan)动(gao)手(yi)脚(xia)呢？ 没错，是可以的。手玩样例可以发现，有很多点是没有用到的，于是，何不建一棵新的树，使得这棵树只包含所有用到的点呢？ 这是可行的。我们想建的树，就叫做虚树。 虚树的建立首先，第一个问题，虚树上究竟会有哪些点？ 很明显，为了要维持原来的树的祖先关系，所有点间两两的$\texttt{lca}$也要算上。 所以说，建树的复杂度是$O(m^2\log n)$的？ 非也，非也。把所有的标记点按$\texttt{dfs}$序排序，在相邻两点求$\texttt{lca}$即可。证明略。 于是建树的复杂度变成了$O(m\log n)$。实际操作的话就用单调栈维护一下就好了，$\texttt{dp}$的话，还是原来那么做呀。 时间复杂度$O(\sum k\log \sum k)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef long long int li;const ll MAXN=2.5e5+51;const li inf=0x3f3f3f3f3f3f3f3f;struct Edge&#123; ll to,prev; ll dist;&#125;;Edge ed[MAXN&lt;&lt;1];ll nc,qcnt,cnt,tot,cur,tp,from,to,dist;ll last[MAXN],fa[MAXN],depth[MAXN],size[MAXN],heavy[MAXN],top[MAXN];ll dfn[MAXN],st[MAXN],key[MAXN];li minn[MAXN];vector&lt;ll&gt; vtree[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to,ll dist)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; ed[tot].dist=dist; last[from]=tot;&#125;inline void dfs(ll node,ll f,ll dep)&#123; fa[node]=f,depth[node]=dep,size[node]=1; ll maxn=-1; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f) &#123; minn[ed[i].to]=min(minn[node],(li)ed[i].dist); dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to]; if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to]; &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; top[node]=link,dfn[node]=++cur; if(!heavy[node]) &#123; return; &#125; ddfs(heavy[node],link); for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to); &#125; &#125;&#125;inline ll LCA(ll x,ll y)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; x=fa[top[x]]; &#125; return depth[x]&lt;depth[y]?x:y;&#125;inline void push(ll node)&#123; if(tp==1) &#123; st[++tp]=node; return; &#125; ll lca=LCA(node,st[tp]); if(lca==st[tp]) &#123; return; &#125; while(tp&gt;1&amp;&amp;dfn[st[tp-1]]&gt;=dfn[lca]) &#123; vtree[st[tp-1]].push_back(st[tp]),tp--; &#125; if(st[tp]!=lca) &#123; vtree[lca].push_back(st[tp]),st[tp]=lca; &#125; st[++tp]=node;&#125;inline bool cmp(ll x,ll y)&#123; return dfn[x]&lt;dfn[y];&#125;inline void createVirtualTree()&#123; sort(key,key+cnt,cmp); st[tp=1]=1; for(register int i=0;i&lt;cnt;i++) &#123; push(key[i]); &#125; while(tp&gt;0) &#123; vtree[st[tp-1]].push_back(st[tp]),tp--; &#125;&#125;inline li DP(ll node)&#123; li tmp=0; if(!vtree[node].size()) &#123; return minn[node]; &#125; for(register int i=0;i&lt;vtree[node].size();i++) &#123; tmp+=DP(vtree[node][i]); &#125; vtree[node].clear(); return min(minn[node],tmp);&#125;int main()&#123; nc=read(); for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(),dist=read(); addEdge(from,to,dist),addEdge(to,from,dist); &#125; minn[1]=inf,dfs(1,0,1),ddfs(1,1),qcnt=read(); for(register int i=0;i&lt;qcnt;i++) &#123; cnt=read(); for(register int j=0;j&lt;cnt;j++) &#123; key[j]=read(); &#125; createVirtualTree(); printf("%lld\n",DP(1)); &#125;&#125;]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>DP</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>虚树</tag>
        <tag>树链剖分</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5340」[TJOI2019]大中锋的游乐场]]></title>
    <url>%2F2019%2F05%2F10%2F%E3%80%8CLuogu-P5340%E3%80%8D-TJOI2019-%E5%A4%A7%E4%B8%AD%E9%94%8B%E7%9A%84%E6%B8%B8%E4%B9%90%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[一共有$T$组数据，每组数据给定一张有$n$个点，$m$条边的无向图，点$i$的类型为$type_i$，其中$type_1$要么为$1$，要么为$2$。一个人想从$s$走到$t$，如果他经过的点$i$中$type_i=1$，则$p_1++$，否则$p_2++$。求出在任何时候，$\vert p_1-p_2\vert\leq k$，为条件下的最短路径。（有点牵强，理解就好） $\texttt{Data Range:}T\leq 10,n\leq 10^4,m\leq 10^5,k\leq 10$ 链接Luogu P5340 LOJ 3107 题解去搞生地会考了，所以近一个月没有更博客。（这就是理由？？） 设可乐的权值为$-1$，汉堡的权值为$1$，喝掉的可乐的数量减去吃掉的汉堡的数量为$p$。 由于$k\leq 10$，所以可以考虑将一个点$i$拆成$2k+1$个点$i_{-k},i_{-k+1},\cdots ,i_{-1},i_0,\cdots ,i_k$，这里，$i_l$是指到达$i$且$p=l$时的最短路总长。 加边的话就这么做：（这里假设现在加的边是$(i,j)$） 如果$j$卖汉堡的话，就从$i_l$连到$j_{l-1}$，其中$i_{-k}$不要连边，就像这样： 如果$j$卖可乐的话，就从$i_l$连到$j_{l+1}$，其中$i_{k}$不要连边。 但是，这是个无向图啊，按照上面的连边方式，连出来的是个有向图，而这题的边又不对称。 所以说，在加边$(i,j)$时，按照上面的方法先加一条边，在把$i,j$换一下，就行了。 于是在新的图上跑一遍最短路就做完了。 但是，这里有一些地方需要注意： 首先是起点的问题，这个应该不用多说，在起点或终点也要买可乐或汉堡。 然后是终点的问题，答案是终点拆出来的每一个点的最短路的最小值。 最后，要特判$k=0$的情况！！！ 最最最后，多组数据，记得清零！！！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef long long int li;typedef pair&lt;li,ll&gt; pii;const ll MAXN=2.1e5+51;const li inf=0x3f3f3f3f3f3f3f3f;struct Edge&#123; ll to,prev,dist;&#125;;priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;pq;Edge ed[MAXN*10];ll test,nc,ec,tot,k,from,to,dist;li res=inf;ll last[MAXN],type[MAXN],inQueue[MAXN];li minn[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125; inline void addEdge(ll from,ll to,ll dist)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; ed[tot].dist=dist; last[from]=tot;&#125;inline ll getID(ll node,ll wt)&#123; return (node-1)*(k*2+1)+wt+k+1;&#125;inline void Dijkstra(ll source)&#123; ll top; pq.push(make_pair(0,source)),inQueue[source]=1,minn[source]=0; while(!pq.empty()) &#123; top=pq.top().second,pq.pop(),inQueue[top]=0; for(register int i=last[top];i;i=ed[i].prev) &#123; if(minn[ed[i].to]&gt;minn[top]+ed[i].dist) &#123; minn[ed[i].to]=minn[top]+ed[i].dist; if(!inQueue[ed[i].to]) &#123; pq.push(make_pair(minn[ed[i].to],ed[i].to)); inQueue[ed[i].to]=1; &#125; &#125; &#125; &#125;&#125;inline void solve()&#123; nc=read(),ec=read(),k=read(); if(k==0) &#123; puts("-1"); return; &#125; for(register int i=1;i&lt;=nc;i++) &#123; type[i]=read()==1?1:-1; &#125; for(register int i=0;i&lt;ec;i++) &#123; from=read(),to=read(),dist=read(); for(register int j=-k;j&lt;=k;j++) &#123; if((type[to]==-1&amp;&amp;j==-k)||(type[to]==1&amp;&amp;j==k)) &#123; continue; &#125; addEdge(getID(from,j),getID(to,j+type[to]),dist); &#125; swap(from,to); for(register int j=-k;j&lt;=k;j++) &#123; if((type[to]==-1&amp;&amp;j==-k)||(type[to]==1&amp;&amp;j==k)) &#123; continue; &#125; addEdge(getID(from,j),getID(to,j+type[to]),dist); &#125; &#125; from=read(),to=read(),memset(minn,0x3f,sizeof(minn)); Dijkstra(getID(from,type[from])); for(register int i=-k;i&lt;=k;i++) &#123; res=min(res,minn[getID(to,i)]); &#125; res==inf?puts("-1"):printf("%lld\n",res);&#125;int main()&#123; test=read(); for(register int i=0;i&lt;test;i++) &#123; solve(); tot=0,memset(last,0,sizeof(last)); &#125;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>建图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5283」[十二省联考2019]异或粽子]]></title>
    <url>%2F2019%2F04%2F27%2F%E3%80%8CLuogu-P5283%E3%80%8D-%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E5%BC%82%E6%88%96%E7%B2%BD%E5%AD%90%2F</url>
    <content type="text"><![CDATA[给定一个长度为$n$的序列$a$,求出$a$的所有子序列中和最大的$k$个的和。 $\texttt{Data Range:}1\leq n\leq 5\times 10^5,1\leq k\leq \min\{\frac{n(n-1)}{2},2\times 10^5\},0\leq a_i\leq 2^32-1$]]></content>
      <tags>
        <tag>位运算</tag>
        <tag>可持久化</tag>
        <tag>Trie</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5068」[Ynoi2015]我回来了]]></title>
    <url>%2F2019%2F04%2F13%2F%E3%80%8CLuogu-P5068%E3%80%8D-Ynoi2015-%E6%88%91%E5%9B%9E%E6%9D%A5%E4%BA%86%2F</url>
    <content type="text"><![CDATA[这里没有珂朵莉的图片啊qwq 给定一个$n$个点$m$条边的无向图和$q$组询问。每组询问给定$k$个二元组$(x_i,y_i)$，求出图上有多少个点$u$与至少一个这次询问的二元组满足$u$到$x_i$的距离小于等于$y_i$。 $\texttt{Data Range:}n\leq 10^3,m\leq 10^5,q\leq 10^5,\sum k\leq 2.1\times 10^6$ 题解生平第一次做Ynoi诶qwq 设$rch_{i,j}$为到$i$的最短距离为$j$的点组成的点集，很显然拿$\texttt{bitset}$维护。 而怎么求$rch_{i,j}$呢？ 好像只要跑$n$遍$\texttt{bfs}$就行啦qwq。]]></content>
      <tags>
        <tag>图论</tag>
        <tag>洛谷</tag>
        <tag>BFS</tag>
        <tag>Ynoi</tag>
        <tag>基础算法</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5268」[SNOI2017]一个简单的询问]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%8CLuogu-P5268%E3%80%8D-SNOI2017-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE%2F</url>
    <content type="text"><![CDATA[给定一个长度为$n$的序列$a$和$q$组询问，对于每组询问，给定$l_1,r_1,l_2,r_2$，求 \sum\limits_{x=0}^{\infty}\operatorname{get}(l_1,r_1,x)\cdot\operatorname{get}(l_2,r_2,x)其中，$\operatorname{get}(l,r,x)$表示在区间$[l,r]$中，数字$x$出现的次数。 注意：答案有可能超过$\texttt{int}$的最大值。 $\texttt{Data Range:}n,q\leq 5\times 10^4,1\leq a_i\leq n,1\leq l_1\leq r_1\leq n,1\leq l_2\leq r_2\leq n$ 链接Luogu P5268 BZOJ 5016 题解文化课选手$\texttt{Karry5307}$终于更博了qwq! 首先，显然会有 \operatorname{get}(l,r,x)=\sum\limits_{i=l}^{r}[a_i=x]右边的和式是可以拆成前缀和的形式的，就暴力拆一下，于是有 \operatorname{get}(l,r,x)=\operatorname{get}(1,r,x)-\operatorname{get}(1,l-1,x)我们定义一个$\operatorname{g}(r,x)=\operatorname{get}(1,r,x)$，拆一下式子，有 \sum\limits_{x=0}^{\infty}(\operatorname{g}(r_1,x)-\operatorname{g}(l_1-1,x))\cdot(\operatorname{g}(r_2,x)-\operatorname{g}(l_2-1,x))展开一下里面的括号 \sum\limits_{x=0}^{\infty}(\operatorname{g}(r_1,x)-\operatorname{g}(l_1-1,x))\cdot(\operatorname{g}(r_2,x)-\operatorname{g}(l_2-1,x))\sum\limits_{x=0}^{\infty}\operatorname{g}(r_1,x)\operatorname{g}(r_2,x)-\operatorname{g}(r_1,x)\operatorname{g}(l_2-1,x)-\operatorname{g}(r_2,x)\operatorname{g}(l_1-1,x)+\operatorname{g}(l_2-1,x)\operatorname{g}(l_1-1,x)拆成四个询问维护一下就好了 这里说说转移。 首先考虑从$\sum\limits_{x=0}^{\infty}\operatorname{g}(l,x)\operatorname{g}(r,x)$转移到$\sum\limits_{x=0}^{\infty}\operatorname{g}(l+1,x)\operatorname{g}(r,x)$会发生什么。 为了接下来好懂，这里开两个数组，$cntl$和$cntr$。$cntl_i$指$a_1\sim a_l$中$i$的出现次数，$cntr_i$，相应的为$a_1\sim a_r$中$i$的出现次数。 不难发现 \sum\limits_{x=0}^{\infty}\operatorname{g}(l+1,x)\operatorname{g}(r,x)-\sum\limits_{x=0}^{\infty}\operatorname{g}(l+1,x)\operatorname{g}(r,x)=\operatorname{g}(r,a_{l+1})这个的话，把求和符号展开一下就行了。 所以说，这样的转移应该是$++cntl_{a_{l+1}},res+=cntr_{a_{l+1}}$的。 剩下三种情况在这里就不详细解释了，推的方法也是这个样子的。 于是就可以完结撒花了qwq! 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef long long int li;const ll MAXN=5e4+51;struct Query&#123; ll l,r,ord,sign; inline bool operator &lt;(const Query &amp;rhs)const;&#125;;Query qry[MAXN&lt;&lt;2];ll cnt,qcnt,qtot,blockSize,l,r,lx,rx,ptrl,ptrr;li ress;ll num[MAXN],cntl[MAXN&lt;&lt;2],cntr[MAXN&lt;&lt;2];li res[MAXN&lt;&lt;2];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125; inline bool Query::operator &lt;(const Query &amp;rhs)const&#123; return (r/blockSize)==(rhs.r/blockSize)?l&lt;rhs.l:r&lt;rhs.r;&#125;inline void add(ll cur,ll op)&#123; op?++cntr[num[cur]]:++cntl[num[cur]]; ress+=op?cntl[num[cur]]:cntr[num[cur]];&#125;inline void del(ll cur,ll op)&#123; ress-=op?cntl[num[cur]]:cntr[num[cur]]; op?cntr[num[cur]]--:cntl[num[cur]]--;&#125;int main()&#123; blockSize=sqrt((cnt=read())); for(register int i=1;i&lt;=cnt;i++) &#123; num[i]=read(); &#125; qcnt=read(); for(register int i=0;i&lt;qcnt;i++) &#123; l=read(),r=read(),lx=read(),rx=read(); qry[++qtot]=(Query)&#123;r,rx,i,1&#125;; qry[++qtot]=(Query)&#123;l-1,rx,i,-1&#125;; qry[++qtot]=(Query)&#123;r,lx-1,i,-1&#125;; qry[++qtot]=(Query)&#123;l-1,lx-1,i,1&#125;; &#125; for(register int i=1;i&lt;=qtot;i++) &#123; if(qry[i].l&lt;qry[i].r) &#123; swap(qry[i].l,qry[i].r); &#125; &#125; sort(qry+1,qry+qtot+1); for(register int i=1;i&lt;=qtot;i++) &#123; while(ptrl&lt;qry[i].l) &#123; add(++ptrl,0); &#125; while(ptrl&gt;qry[i].l) &#123; del(ptrl--,0); &#125; while(ptrr&lt;qry[i].r) &#123; add(++ptrr,1); &#125; while(ptrr&gt;qry[i].r) &#123; del(ptrr--,1); &#125; res[qry[i].ord]+=qry[i].sign*ress; &#125; for(register int i=0;i&lt;qcnt;i++) &#123; printf("%lld\n",res[i]); &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>洛谷</tag>
        <tag>分块</tag>
        <tag>BZOJ，各省省选</tag>
        <tag>SNOI</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3804」【模板】后缀自动机]]></title>
    <url>%2F2019%2F04%2F05%2F%E3%80%8CLuogu-P3804%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[给定一个只用小写字母组成的串$S$，求出$S$中所有出现次数大于$1$的子串的出现次数与它的长度的乘积的最大值。 $\texttt{Data Range:}\vert S\vert \leq 10^6$ 链接Luogu P3804 题解首先把后缀自动机建出来，然后考虑对每个自动机上的节点求一遍$\texttt{size}$，答案就是$\max\{len\times size\}$啦qwq 顺便说一句，这种方法会在后面的文章上频繁使用，注意！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef long long int li;const ll MAXN=2e6+51;ll length,k,cur;li res;ll prefix[MAXN],barrel[MAXN],size[MAXN];char str[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;namespace SuffixAutomaton&#123; const ll sigmaSize=27; struct Node&#123; ll son[sigmaSize]; ll fa,length; &#125;; struct SuffixAutomaton&#123; Node nd[MAXN]; ll last,tot; SuffixAutomaton() &#123; last=tot=1; &#125; inline void extend(ll ch) &#123; ll p=last,nxt=++tot,nxt2,k; last=nxt,nd[nxt].length=nd[p].length+1; while(p&amp;&amp;!nd[p].son[ch]) &#123; nd[p].son[ch]=nxt,p=nd[p].fa; &#125; if(!p) &#123; nd[nxt].fa=1; &#125; else &#123; k=nd[p].son[ch]; if(nd[p].length+1==nd[k].length) &#123; nd[nxt].fa=k; &#125; else &#123; nxt2=++tot,nd[nxt2]=nd[k]; nd[nxt2].length=nd[p].length+1,nd[k].fa=nd[nxt].fa=nxt2; while(p&amp;&amp;nd[p].son[ch]==k) &#123; nd[p].son[ch]=nxt2,p=nd[p].fa; &#125; &#125; &#125; size[nxt]=1; &#125; &#125;;&#125;SuffixAutomaton::SuffixAutomaton sam;int main()&#123; scanf("%s",str+1); length=strlen(str+1); for(register int i=1;i&lt;=length;i++) &#123; sam.extend(str[i]-97); &#125; k=sam.tot; for(register int i=1;i&lt;=k;i++) &#123; prefix[sam.nd[i].length]++; &#125; for(register int i=1;i&lt;=k;i++) &#123; prefix[i]+=prefix[i-1]; &#125; for(register int i=1;i&lt;=k;i++) &#123; barrel[prefix[sam.nd[i].length]--]=i; &#125; for(register int i=k;i;i--) &#123; cur=barrel[i]; size[sam.nd[cur].fa]+=size[cur]; if(size[cur]&gt;1) &#123; res=max(res,(li)size[cur]*sam.nd[cur].length); &#125; &#125; printf("%lld",res);&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>洛谷</tag>
        <tag>后缀自动机，SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4171」[JSOI2010]满汉全席]]></title>
    <url>%2F2019%2F04%2F04%2F%E3%80%8CLuogu-P4171%E3%80%8D-JSOI2010-%E6%BB%A1%E6%B1%89%E5%85%A8%E5%B8%AD%2F</url>
    <content type="text"><![CDATA[有$n$种食材和$m$位评委。每一位选手要将$n$种食材全部做成满式或汉式料理。如果一位选手做出的菜符合每位评委所喜好的两种菜品中的一种，那么说这位选手是通过考核的。 一共有$T$组数据，对于每组数据，给定$m$位评委所喜好的菜品，问是否有一种做法，使得能通过考核。 $\texttt{Data Range:}T\leq 10,n\leq 100,m\leq 1000$ 链接Luogu P4171 BZOJ 1823 题解设$x_i$为$[$第$i$种食材做汉式$]$，那么评委的限制就变成$x_i$为真或者$x_j$为假这样的形式了。 于是，可以把题意转换成是否存在一组$x_i$的取值，使得这些取值能满足所有约束条件。 这就是个$\texttt{2-SAT}$的板子题了。 唯一需要注意的是多组数据记得清零！！！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e4+51;struct Edge&#123; ll to,prev;&#125;;Edge ed[MAXN&lt;&lt;1];stack&lt;ll&gt;st;ll test,cnt,ccnt,tot,num,sccCnt,x,y,vx,vy;ll last[MAXN&lt;&lt;1],dfn[MAXN&lt;&lt;1],low[MAXN&lt;&lt;1],belong[MAXN&lt;&lt;1],ins[MAXN&lt;&lt;1];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125; inline ll getType()&#123; register char ch=getchar(); while(ch!='m'&amp;&amp;ch!='h') &#123; ch=getchar(); &#125; return ch=='h';&#125;inline void addEdge(ll from,ll to)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;inline void addOr(ll x,ll y,ll vx,ll vy)&#123; addEdge(y+cnt*(vy^1),x+cnt*(vx&amp;1)); addEdge(x+cnt*(vx^1),y+cnt*(vy&amp;1));&#125;inline void Tarjan(ll node)&#123; ll nd; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; for(register int i=last[node];i;i=ed[i].prev) &#123; if(!dfn[ed[i].to]) &#123; Tarjan(ed[i].to); low[node]=min(low[node],low[ed[i].to]); &#125; else &#123; if(ins[ed[i].to]) &#123; low[node]=min(low[node],dfn[ed[i].to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; sccCnt++; do &#123; nd=st.top(),st.pop(); ins[nd]=0,belong[nd]=sccCnt; &#125; while(node!=nd); &#125;&#125;inline void solve()&#123; cnt=read(),ccnt=read(); for(register int i=0;i&lt;ccnt;i++) &#123; vx=getType(),x=read(),vy=getType(),y=read(); addOr(x,y,vx,vy); &#125; for(register int i=1;i&lt;=(cnt&lt;&lt;1);i++) &#123; if(!dfn[i]) &#123; Tarjan(i); &#125; &#125; for(register int i=1;i&lt;=cnt;i++) &#123; if(belong[i]==belong[i+cnt]) &#123; puts("BAD"); return; &#125; &#125; puts("GOOD");&#125;inline void clear()&#123; memset(ed,0,sizeof(ed)),memset(last,0,sizeof(last)); memset(dfn,0,sizeof(dfn)),memset(low,0,sizeof(low)); memset(belong,0,sizeof(belong)),memset(ins,0,sizeof(ins)); tot=num=sccCnt=0; while(!st.empty()) &#123; st.pop(); &#125;&#125;int main()&#123; test=read(); for(register int i=0;i&lt;test;i++) &#123; solve(),clear(); &#125;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>JSOI</tag>
        <tag>各省省选</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4555」[国家集训队]最长双回文串]]></title>
    <url>%2F2019%2F04%2F01%2F%E3%80%8CLuogu-P4555%E3%80%8D-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个串$S$，求$S$中最长的子串$T$，使得可以将$T$分为两个长度大于等于$1$的回文串，只需输出$T$的长度即可。 $\texttt{Data Range:}2\leq \vert S\vert \leq 10^5$很明显的回文树题。只是因为窝不会马拉车 考虑枚举分的位置，假设以这个位置结尾的回文子串为$X$，这个位置开头的回文子串为$Y$，那么有 贪心地考虑，如果这个$X$或者$Y$的长度不是最大的话，那么它绝对不是答案，因为$X$或者$Y$还可以继续扩展。所以，这个位置的答案为$\max\{\vert X\vert +\vert Y\vert\}$。 于是预处理出位置$i$的$pre_i=\max\{\vert X\vert\}$和$suf_i=\max\{\vert Y\vert\}$。 然后很明显的扫一遍，求出$\max\{pre_i+suf_{i+1}\}$就好了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e5+51;ll length,res;ll prefix[MAXN],suffix[MAXN]; char str[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;namespace PalindromicTree&#123; const ll sigmaSize=27; struct Node&#123; ll son[sigmaSize]; ll fa,length; &#125;; struct PalindromicTree&#123; Node nd[MAXN]; ll last,tot; PalindromicTree() &#123; nd[0].fa=nd[1].fa=1; nd[tot=1].length=-1; &#125; inline void extend(ll ch,ll length,char *str) &#123; ll p=last,nxt,k; while(str[length-nd[p].length-1]!=str[length]) &#123; p=nd[p].fa; &#125; if(!nd[p].son[ch]) &#123; nxt=++tot,k=nd[p].fa; nd[nxt].length=nd[p].length+2; while(str[length-nd[k].length-1]!=str[length]) &#123; k=nd[k].fa; &#125; nd[nxt].fa=nd[k].son[ch],nd[p].son[ch]=nxt; &#125; last=nd[p].son[ch]; &#125; &#125;;&#125;PalindromicTree::PalindromicTree pt,pt2;int main()&#123; scanf("%s",str+1),length=strlen(str+1); for(register int i=1;i&lt;=length;i++) &#123; pt.extend(str[i]-97,i,str),prefix[i]=pt.nd[pt.last].length; &#125; reverse(&amp;str[1],&amp;str[length+1]); for(register int i=1;i&lt;=length;i++) &#123; pt2.extend(str[i]-97,i,str),suffix[length-i+1]=pt2.nd[pt2.last].length; &#125; for(register int i=1;i&lt;length;i++) &#123; res=max(res,prefix[i]+suffix[i+1]); &#125; printf("%d",res);&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>回文树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4091」[HEOI2016/TJOI2016]求和]]></title>
    <url>%2F2019%2F03%2F28%2F%E3%80%8CLuogu-P4091%E3%80%8D-HEOI2016-TJOI2016-%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定整数$n$，求$\sum\limits_{i=0}^{n}\sum\limits_{j=0}^{i}S(i,j)\times 2^j\times j!\bmod{998244353}$，其中$S(i,j)$为第二类$\texttt{Stirling}$数。 $\texttt{Data Range:}n\leq 10^5$ 链接之前的题目好多都没放链接，之后再补qwq。 Luogu P4091 BZOJ 4555 题解这么一长串式子看起来挺不爽，所以可以考虑推公式。 根据当$n&lt;m$时$S(n,m)=0$，考虑将$j$的范围改一下 \sum\limits_{i=0}^{n}\sum\limits_{j=0}^{i}S(i,j)\times 2^j\times j!换个枚举顺序，再把$2^j\times j$提出来 \sum\limits_{j=0}^{n}2^j\times j!\sum\limits_{i=0}^{n}S(i,j)把$\texttt{Stirling}$数展开 \sum\limits_{j=0}^{n}2^j\times j!\sum\limits_{i=0}^{n}\frac{1}{j!}\sum\limits_{k=0}^{n}(-1)^kC^k_j(j-k)^i这个组合数看起来极其不好，展开一下，顺便把$j!$消掉 \sum\limits_{j=0}^{n}2^j\sum\limits_{i=0}^{n}\sum\limits_{k=0}^{n}(-1)^k\frac{j!(j-k)^i}{k!(j-k)!}交换一下$k$和$i$的枚举顺序，把与$i$无关的提出来 \sum\limits_{j=0}^{n}2^j\times j!\sum\limits_{k=0}^{n}(-1)^k\frac{1}{k!(j-k)!}\sum\limits_{i=0}^{n}(j-k)^i把$j-k$提进去，顺便用等比数列求和消掉关与$i$的枚举 \sum\limits_{j=0}^{n}2^j\times j!\sum\limits_{k=0}^{n}(-1)^k\frac{1}{k!}\times\frac{(j-k)^{n+1}-1}{(j-k)!(j-k+1)}设$f_i=\frac{(-1)^i}{i!},g_i=\frac{i^{n+1}-1}{i!(i-1)}$，那么就会有 \sum\limits_{j=0}^{n}2^j\times j!\sum\limits_{k=0}^{n}f_kg_{j-k}发现右边是一个卷积，使用$\texttt{NTT}$计算即可，时间复杂度$O(n\log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef long long int li;const ll MAXN=3e5+51,MOD=998244353,G=3,INVG=332748118;ll fd,ccnt,limit,rres;ll f[MAXN],g[MAXN],res[MAXN],rev[MAXN],inv[MAXN],fact[MAXN],finv[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll qpow(ll base,ll exponent)&#123; li res=1; while(exponent) &#123; if(exponent&amp;1) &#123; res=(li)res*base%MOD; &#125; base=(li)base*base%MOD,exponent&gt;&gt;=1; &#125; return res;&#125;inline void setup(ll ccnt)&#123; fact[0]=fact[1]=finv[0]=finv[1]=inv[1]=1; for(register int i=2;i&lt;=ccnt;i++) &#123; fact[i]=(li)fact[i-1]*i%MOD; inv[i]=(li)inv[MOD%i]*(MOD-MOD/i)%MOD; finv[i]=(li)finv[i-1]*inv[i]%MOD; &#125;&#125;inline void NTT(ll *cp,ll cnt,ll inv)&#123; ll cur=0,res=0,omg=0; for(register int i=0;i&lt;cnt;i++) &#123; if(i&lt;rev[i]) &#123; swap(cp[i],cp[rev[i]]); &#125; &#125; for(register int i=2;i&lt;=cnt;i&lt;&lt;=1) &#123; cur=i&gt;&gt;1,res=qpow(inv==1?G:INVG,(MOD-1)/i); for(register ll *p=cp;p!=cp+cnt;p+=i) &#123; omg=1; for(register int j=0;j&lt;cur;j++) &#123; ll t=(li)omg*p[j+cur]%MOD,t2=p[j]; p[j+cur]=(t2-t+MOD)%MOD,p[j]=(t2+t)%MOD; omg=(li)omg*res%MOD; &#125; &#125; &#125; if(inv==-1) &#123; ll invl=qpow(cnt,MOD-2); for(register int i=0;i&lt;=cnt;i++) &#123; cp[i]=(li)cp[i]*invl%MOD; &#125; &#125;&#125;int main()&#123; fd=read(),ccnt=1,limit=-1; while(ccnt&lt;(fd&lt;&lt;1)) &#123; ccnt&lt;&lt;=1,limit++; &#125; setup(ccnt); for(register int i=0;i&lt;=fd;i++) &#123; f[i]=i&amp;1?MOD-finv[i]:finv[i]; g[i]=i==0?1:(i==1?fd+1:(li)(qpow(i,fd+1)-1)*inv[i-1]%MOD*finv[i]%MOD); &#125; for(register int i=0;i&lt;ccnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(f,ccnt,1),NTT(g,ccnt,1); for(register int i=0;i&lt;=ccnt;i++) &#123; res[i]=(li)f[i]*g[i]%MOD; &#125; NTT(res,ccnt,-1); for(register int i=0;i&lt;=fd;i++) &#123; rres=(rres+(li)qpow(2,i)*fact[i]%MOD*res[i]%MOD)%MOD; &#125; printf("%d",rres);&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>组合数学</tag>
        <tag>各省省选</tag>
        <tag>HEOI</tag>
        <tag>TJOI</tag>
        <tag>数论，数学</tag>
        <tag>Stirling数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HNOI2019滚粗记]]></title>
    <url>%2F2019%2F03%2F28%2FHNOI2019%E6%BB%9A%E7%B2%97%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[别人都说它们是去划水的，其实真正去划水的是我。 自己这一个月，天天被$\texttt{x}$$\texttt{gzc}$，$\texttt{h}$$\texttt{yj}$，$\texttt{n}$$\texttt{zr}$和$\texttt{M}$$\texttt{_sea}$等神仙吊打了qwq $\texttt{Day -1}$上午考$\texttt{ZJOI2019 Day 1}$，而且还只有$\texttt{4h}$，像窝这种不会打麻将的老年选手只能$\texttt{boom 0}$啦qwq $\texttt{Day 0}$上午看了一上午的多项式和$\texttt{SAM}$，不得不说我的多项式总结是真的长，写了$\texttt{3.4k}$字qwq 于是我又看了一下午的树剖和$\texttt{LCT}$，感觉还是有点玄学吧qwq 写博客让人清醒，看题目使人犯困 所以说，$\texttt{++HNOI2019.rp!}$ $\texttt{Day 1}$早上面基了$\texttt{t}$$\texttt{br}$等人，$\texttt{t}$$\texttt{br}$太强了，$\texttt{orz}$ 密码感觉很不对劲啊，好像是$\texttt{ROUTER}$之类的，难道是说$\texttt{Day 2}$考最短路？ 先看一眼$\texttt{T1}$，居然是传说中的计算几何？？？可是后两题比这题更难写，于是考虑刚$\texttt{T1}$，发现自己在三个点所成的角度都不知道，卡到了$\texttt{8:45}$。发现自己是真的呆，写了个余弦定理。 然后就去写$\texttt{20 pts}$，枚举选排列，调选排列都调了$\texttt{20 min}$，自己连选排列都不会了，被劝退了qwq。 本来想写$O(n^4)$的，结果看了下$\texttt{Data Range}$发现跟写$O(n^6)$的低级暴力一模一样，而且$O(n^6)$还更好写，所以就没写$O(n^4)$了。 $\texttt{9:00}$去刚$\texttt{T2}$，一看有贪心性质优化枚举，就写了，结果写萎了，调到了$\texttt{10:00}$。我脑子一热，只好去了一趟$\texttt{WC}$，但是居然碰到了$\texttt{l}$$\texttt{k}$，先$\texttt{molokai}$为好。 又调了$\texttt{100 min}$的高级暴力，感觉自己人都不好了，还不如写低级暴力呢，然后我居然过样例了？？]]></content>
      <tags>
        <tag>游记/考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5245」【模板】多项式快速幂]]></title>
    <url>%2F2019%2F03%2F23%2F%E3%80%8CLuogu-P5245%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[给定$n-1$次多项式$F(x)$与整数$k$，求$\bmod x^n$意义下的$(F(x))^k$。 $\texttt{Data Range:}n\leq 10^5,2\leq k\leq 10^{10^5}$ 前置知识多项式基本操作，不会请右转模板区qwq。 题解首先大力推一波式子 G(x)=(F(x))^k\pmod{x^n}取下对数 \ln G(x)=kF(x)\pmod{x^n}再取一下指数 G(x)=e^{kF(x)}\pmod{x^n}很明显，时间复杂度是$O(n\log n)$，但是如果像我一样写代码会$\texttt{TLE 8-20}$，于是来践行OI界的优良传统卡常数。 前方大图警告 中间有$\texttt{selftest}$的是我的自测，数据比这一题强。 首先看一份比较$\texttt{naive}$的代码（只有$\texttt{35 pts}$，吸氧后在$\texttt{selftest}$上跑还只有$\texttt{45070ms}$）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef long long int li;const ll MAXN=3e5+51,MOD=998244353,G=3,INVG=332748118;ll fd,exponent;ll f[MAXN],res[MAXN],tmp[MAXN],pinv[MAXN],der[MAXN],texp[MAXN],texp2[MAXN];ll g[MAXN],rev[MAXN],root[MAXN],invl[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll readm(ll mod)&#123; register li num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(((num&lt;&lt;3)+(num&lt;&lt;1))%MOD+(ch-'0'))%MOD; ch=getchar(); &#125; return num*neg;&#125; inline ll qadd(ll x,ll y,ll mod)&#123; return x+y&gt;mod?x+y-mod:x+y;&#125;inline ll qmin(ll x,ll y,ll mod)&#123; return x-y&lt;0?x-y+mod:x-y;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; li res=1; while(exponent) &#123; if(exponent&amp;1) &#123; res=(li)res*base%mod; &#125; base=(li)base*base%mod,exponent&gt;&gt;=1; &#125; return res;&#125;inline void NTT(ll *cp,ll cnt,ll inv,ll mod)&#123; ll cur=0,res=0,omg=0; for(register int i=0;i&lt;cnt;++i) &#123; if(i&lt;rev[i]) &#123; swap(cp[i],cp[rev[i]]); &#125; &#125; for(register int i=2;i&lt;=cnt;i&lt;&lt;=1) &#123; cur=i&gt;&gt;1,res=qpow(inv==1?G:INVG,(mod-1)/i,mod); for(register ll *p=cp;p!=cp+cnt;p+=i) &#123; omg=1; for(register int j=0;j&lt;cur;++j) &#123; ll t=(li)omg*p[j+cur]%mod; p[j+cur]=qmin(p[j],t,mod),p[j]=qadd(p[j],t,mod); omg=(li)omg*res%mod; &#125; &#125; &#125; if(inv==-1) &#123; ll invl=qpow(cnt,mod-2,mod); for(register int i=0;i&lt;=cnt;++i) &#123; cp[i]=(li)cp[i]*invl%mod; &#125; &#125;&#125;inline void deriv(ll fd,ll *f,ll *res,ll mod)&#123; for(register int i=1;i&lt;fd;++i) &#123; res[i-1]=(li)f[i]*i%mod; &#125; res[fd-1]=0;&#125;inline void integ(ll fd,ll *f,ll *res,ll mod)&#123; for(register int i=1;i&lt;fd;++i) &#123; res[i]=(li)f[i-1]*qpow(i,mod-2,mod)%mod; &#125; res[0]=0;&#125;inline void inv(ll fd,ll *f,ll *res,ll mod)&#123; if(fd==1) &#123; res[0]=qpow(f[0],mod-2,mod); return; &#125; inv((fd+1)&gt;&gt;1,f,res,mod); ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;++i) &#123; tmp[i]=i&lt;fd?f[i]:0; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp,cnt,1,mod),NTT(res,cnt,1,mod); for(register int i=0;i&lt;cnt;++i) &#123; res[i]=(li)qmin(2,(li)tmp[i]*res[i]%mod,mod)*res[i]%mod; &#125; NTT(res,cnt,-1,mod); for(register int i=fd;i&lt;cnt;++i) &#123; res[i]=0; &#125;&#125;inline void ln(ll fd,ll *f,ll *res,ll mod)&#123; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; inv(fd,f,pinv,mod),deriv(fd,f,der,mod); for(register int i=0;i&lt;cnt;++i) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(pinv,cnt,1,mod),NTT(der,cnt,1,mod); for(register int i=0;i&lt;cnt;++i) &#123; der[i]=(li)der[i]*pinv[i]%mod; &#125; NTT(der,cnt,-1,mod),integ(fd,der,res,mod); for(register int i=0;i&lt;cnt;++i) &#123; der[i]=pinv[i]=0; &#125;&#125;inline void exp(ll fd,ll *f,ll *res,ll mod)&#123; if(fd==1) &#123; res[0]=1; return; &#125; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; exp((fd+1)&gt;&gt;1,f,res,mod),ln(fd,res,texp,mod); for(register int i=0;i&lt;cnt;++i) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; texp[0]=qmin(f[0]+1,texp[0],mod); for(register int i=1;i&lt;fd;++i) &#123; texp[i]=qmin(f[i],texp[i],mod); &#125; NTT(texp,cnt,1,mod),NTT(res,cnt,1,mod); for(register int i=0;i&lt;cnt;++i) &#123; res[i]=(li)res[i]*texp[i]%mod; &#125; NTT(res,cnt,-1,mod); for(register int i=0;i&lt;cnt;++i) &#123; texp[i]=0,res[i]=i&lt;fd?res[i]:0; &#125;&#125;int main()&#123; fd=read(),exponent=readm(MOD); for(register int i=0;i&lt;fd;++i) &#123; f[i]=read(); &#125; ln(fd,f,g,MOD); for(register int i=0;i&lt;fd;++i) &#123; g[i]=(li)g[i]*exponent%MOD; &#125; exp(fd,g,res,MOD); for(register int i=0;i&lt;fd;++i) &#123; printf("%d ",res[i]); &#125;&#125; 首先考虑把一些调用次数多而短的函数给搞掉。 一眼看过去，调用次数最多的是$\texttt{qadd}$和$\texttt{qmin}$，于是考虑吧这两个函数搞掉，把一些副本放到函数里面开$\texttt{static}$，于是就优化到了$\texttt{31078ms}$。 接下来，就可以考虑压缩$\texttt{deriv}$和$\texttt{integ}$了，尽管代码里只有调用一次，但是$\texttt{exp}$中会调用$\log n$次，所以果断搞掉，现在时间是$\texttt{28972ms}$。 接着考虑删掉一些不必要的参数，因为传$\texttt{int}$是$O(32)$的。于是可以考虑删掉$\texttt{mod}$，因为这题只有一个模数，用不着加这样一个参。 经过毒瘤卡常后，一个$\texttt{45000+ms}$的代码被优化成了$\texttt{12000-ms}$，可以见得卡常是个好东西。 附赠$\texttt{selftest}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef long long int li;const ll MAXN=3e5+51,MOD=998244353,G=3,INVG=332748118;ll fd,exponent;ll f[MAXN],res[MAXN],g[MAXN],rev[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll readm()&#123; register li num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=((num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'))%MOD; ch=getchar(); &#125; return num*neg;&#125; inline ll qpow(ll base,ll exponent)&#123; li res=1; while(exponent) &#123; if(exponent&amp;1) &#123; res=(li)res*base%MOD; &#125; base=(li)base*base%MOD,exponent&gt;&gt;=1; &#125; return res;&#125;inline void NTT(ll *cp,ll cnt,ll inv)&#123; ll cur=0,res=0,omg=0; for(register int i=0;i&lt;cnt;++i) &#123; if(i&lt;rev[i]) &#123; swap(cp[i],cp[rev[i]]); &#125; &#125; for(register int i=2;i&lt;=cnt;i&lt;&lt;=1) &#123; cur=i&gt;&gt;1,res=qpow(inv==1?G:INVG,(MOD-1)/i); for(register ll *p=cp;p!=cp+cnt;p+=i) &#123; omg=1; for(register int j=0;j&lt;cur;++j) &#123; ll t=(li)omg*p[j+cur]%MOD,t2=p[j]; p[j+cur]=(t2-t+MOD)%MOD,p[j]=(t2+t)%MOD; omg=(li)omg*res%MOD; &#125; &#125; &#125; if(inv==-1) &#123; ll invl=qpow(cnt,MOD-2); for(register int i=0;i&lt;=cnt;++i) &#123; cp[i]=(li)cp[i]*invl%MOD; &#125; &#125;&#125;inline void inv(ll fd,ll *f,ll *res)&#123; static ll tmp[MAXN]; if(fd==1) &#123; res[0]=qpow(f[0],MOD-2); return; &#125; inv((fd+1)&gt;&gt;1,f,res); ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;++i) &#123; tmp[i]=i&lt;fd?f[i]:0; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp,cnt,1),NTT(res,cnt,1); for(register int i=0;i&lt;cnt;++i) &#123; res[i]=(li)(2-(li)tmp[i]*res[i]%MOD+MOD)%MOD*res[i]%MOD; &#125; NTT(res,cnt,-1); for(register int i=fd;i&lt;cnt;++i) &#123; res[i]=0; &#125;&#125;inline void ln(ll fd,ll *f,ll *res)&#123; static ll pinv[MAXN],der[MAXN]; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; inv(fd,f,pinv); for(register int i=1;i&lt;fd;++i) &#123; der[i-1]=(li)f[i]*i%MOD; &#125; der[fd-1]=0; for(register int i=0;i&lt;cnt;++i) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(pinv,cnt,1),NTT(der,cnt,1); for(register int i=0;i&lt;cnt;++i) &#123; der[i]=(li)der[i]*pinv[i]%MOD; &#125; NTT(der,cnt,-1); for(register int i=1;i&lt;fd;++i) &#123; res[i]=(li)der[i-1]*qpow(i,MOD-2)%MOD; &#125; res[0]=0; for(register int i=0;i&lt;cnt;++i) &#123; der[i]=pinv[i]=0; &#125;&#125;inline void exp(ll fd,ll *f,ll *res)&#123; static ll texp[MAXN]; if(fd==1) &#123; res[0]=1; return; &#125; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; exp((fd+1)&gt;&gt;1,f,res),ln(fd,res,texp); for(register int i=0;i&lt;cnt;++i) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; texp[0]=(f[0]+1-texp[0]+MOD)%MOD; for(register int i=1;i&lt;fd;++i) &#123; texp[i]=(f[i]-texp[i]+MOD)%MOD; &#125; NTT(texp,cnt,1),NTT(res,cnt,1); for(register int i=0;i&lt;cnt;++i) &#123; res[i]=(li)res[i]*texp[i]%MOD; &#125; NTT(res,cnt,-1); for(register int i=0;i&lt;cnt;++i) &#123; texp[i]=0,res[i]=i&lt;fd?res[i]:0; &#125;&#125;int main()&#123; fd=read(),exponent=readm(); for(register int i=0;i&lt;fd;++i) &#123; f[i]=read(); &#125; ln(fd,f,g); for(register int i=0;i&lt;fd;++i) &#123; g[i]=(li)g[i]*exponent%MOD; &#125; exp(fd,g,res); for(register int i=0;i&lt;fd;++i) &#123; printf("%d ",res[i]); &#125;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 438E」The Child and Binary Tree]]></title>
    <url>%2F2019%2F03%2F22%2F%E3%80%8CCodeForces-438E%E3%80%8DThe-Child-and-Binary-Tree%2F</url>
    <content type="text"><![CDATA[给定一个元素个数为$n$的集合$c$和一个整数$m$，称一棵二叉树是好的当且仅当这棵二叉树的所有点的权值都属于$c$，规定一棵带点权二叉树的权值是该树中所有点权的总和。对于任意的整数$s$满足$1\leq s\leq m$，求出权值为$s$的好的二叉树的数量，答案对$998244353$取模。 $\texttt{Data Range:}1\leq n,m,c_i\leq 10^5$ 链接题解一道很好的计数$\texttt{dp}$多项式花样板子题。 首先考虑计数$\texttt{dp}$，其实这个应该不难想。 考虑根节点的点权，枚举一下左子树点权，那么有 dp_i=\begin{cases}1, & (n=0)\\ \sum\limits_{i=1}^{n}g_i\sum\limits_{j=0}^{n-i}dp_j dp_{n-i-j}, & (n\geq 1)\end{cases}这里，$g_i=[i\in c]$。 但是这个算法复杂度不对啊qwq，考虑使用生成函数优化一下。 设$F(x)$为序列$dp$的生成函数（很明显是$\texttt{OGF}$），$G(x)$为序列$g$的生成函数，那么很明显的可以看到，上面的式子是卷积的形式，于是就再搞一搞，就会有 F=GF^2+1再整理一下 GF^2-F+1=0解一下这样一个方程，得到两个根 F=\frac{2}{1\pm\sqrt{1-4G}}这个正负号看起来就觉得很不爽，所以考虑一下这个是加号还是减号。 题目保证了$1\leq c_i\leq 10^5$，所以可以知道$G_0=0$，代入一下是加号。 既然$F$是$dp$的生成函数，那么只需要输出$F_1,F_2,\cdots,F_m$就可以啦qwq。 时间复杂度$O(n\log n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef long long int li;const ll MAXN=3e5+51,MOD=998244353,G=3,INVG=332748118;ll cnt,ccnt=1,fd;ll f[MAXN],res[MAXN],g[MAXN],rev[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll qpow(ll base,ll exponent)&#123; li res=1; while(exponent) &#123; if(exponent&amp;1) &#123; res=(li)res*base%MOD; &#125; base=(li)base*base%MOD,exponent&gt;&gt;=1; &#125; return res;&#125;inline void NTT(ll *cp,ll cnt,ll inv)&#123; ll cur=0,res=0,omg=0; for(register int i=0;i&lt;cnt;++i) &#123; if(i&lt;rev[i]) &#123; swap(cp[i],cp[rev[i]]); &#125; &#125; for(register int i=2;i&lt;=cnt;i&lt;&lt;=1) &#123; cur=i&gt;&gt;1,res=qpow(inv==1?G:INVG,(MOD-1)/i); for(register ll *p=cp;p!=cp+cnt;p+=i) &#123; omg=1; for(register int j=0;j&lt;cur;++j) &#123; ll t=(li)omg*p[j+cur]%MOD,t2=p[j]; p[j+cur]=(t2-t+MOD)%MOD,p[j]=(t2+t)%MOD; omg=(li)omg*res%MOD; &#125; &#125; &#125; if(inv==-1) &#123; ll invl=qpow(cnt,MOD-2); for(register int i=0;i&lt;=cnt;++i) &#123; cp[i]=(li)cp[i]*invl%MOD; &#125; &#125;&#125;inline void deriv(ll fd,ll *f,ll *res)&#123; for(register int i=1;i&lt;fd;++i) &#123; res[i-1]=(li)f[i]*i%MOD; &#125; res[fd-1]=0;&#125;inline void integ(ll fd,ll *f,ll *res)&#123; for(register int i=1;i&lt;fd;++i) &#123; res[i]=(li)f[i-1]*qpow(i,MOD-2)%MOD; &#125; res[0]=0;&#125;inline void inv(ll fd,ll *f,ll *res)&#123; static ll tmp[MAXN]; if(fd==1) &#123; res[0]=qpow(f[0],MOD-2); return; &#125; inv((fd+1)&gt;&gt;1,f,res); ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;++i) &#123; tmp[i]=i&lt;fd?f[i]:0; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp,cnt,1),NTT(res,cnt,1); for(register int i=0;i&lt;cnt;++i) &#123; res[i]=(li)(2-(li)tmp[i]*res[i]%MOD+MOD)%MOD*res[i]%MOD; &#125; NTT(res,cnt,-1); for(register int i=fd;i&lt;cnt;++i) &#123; res[i]=0; &#125;&#125;inline void ln(ll fd,ll *f,ll *res)&#123; static ll pinv[MAXN],der[MAXN]; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; inv(fd,f,pinv),deriv(fd,f,der); for(register int i=0;i&lt;cnt;++i) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(pinv,cnt,1),NTT(der,cnt,1); for(register int i=0;i&lt;cnt;++i) &#123; der[i]=(li)der[i]*pinv[i]%MOD; &#125; NTT(der,cnt,-1),integ(fd,der,res); for(register int i=0;i&lt;cnt;++i) &#123; der[i]=pinv[i]=0; &#125;&#125;inline void exp(ll fd,ll *f,ll *res)&#123; static ll texp[MAXN]; if(fd==1) &#123; res[0]=1; return; &#125; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; exp((fd+1)&gt;&gt;1,f,res),ln(fd,res,texp); for(register int i=0;i&lt;cnt;++i) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; texp[0]=(f[0]+1-texp[0]+MOD)%MOD; for(register int i=1;i&lt;fd;++i) &#123; texp[i]=(f[i]-texp[i]+MOD)%MOD; &#125; NTT(texp,cnt,1),NTT(res,cnt,1); for(register int i=0;i&lt;cnt;++i) &#123; res[i]=(li)res[i]*texp[i]%MOD; &#125; NTT(res,cnt,-1); for(register int i=0;i&lt;cnt;++i) &#123; texp[i]=0,res[i]=i&lt;fd?res[i]:0; &#125;&#125;inline void sqrt(ll fd,ll *f,ll *res)&#123; static ll tsqrt[MAXN]; ln(fd,f,tsqrt); ll cnt=1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1; &#125; for(register int i=0;i&lt;=cnt;++i) &#123; tsqrt[i]=tsqrt[i]&amp;1?(tsqrt[i]+MOD)&gt;&gt;1:tsqrt[i]&gt;&gt;1; &#125; exp(fd,tsqrt,res); for(register int i=0;i&lt;cnt;i++) &#123; tsqrt[i]=0; &#125;&#125;int main()&#123; cnt=read(),fd=read()+1; for(register int i=0;i&lt;cnt;++i) &#123; ++f[read()]; &#125; while(ccnt&lt;(fd&lt;&lt;1)) &#123; ccnt&lt;&lt;=1; &#125; for(register int i=0;i&lt;ccnt;++i) &#123; f[i]=(MOD-((li)4*f[i]%MOD))%MOD; &#125; ++f[0],sqrt(fd,f,g); g[0]=(g[0]+1)%MOD,inv(fd,g,res); for(register int i=1;i&lt;fd;i++) &#123; printf("%d ",(res[i]&lt;&lt;1)%MOD); &#125;&#125;]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>多项式</tag>
        <tag>生成函数</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
        <tag>DP</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·多项式专题（二）]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%93%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一片文章讲的呢，都是一些板子。 前言以下代码多项式系数均对$998244353(7\times 17\times 2^{23}+1)$取膜，如果想对于$1004535809$等其他模数通用的话，请将原根，原根的逆和虚数单位，$\texttt{Cipolla}$中的$\texttt{exponent}$，以及三角函数代码里的$\texttt{inv2}$更改即可。 如果有什么比如说像链接有问题或者是别的问题，请在下面发评论。 多项式的求导与不定积分$\frac{\mathrm{d}}{\mathrm{d}x}x^n=nx^{n-1},\int x^n=\frac{x^{n+1}}{n+1}\,\mathrm{d}x$，所以直接套公式即可。12345678910111213141516inline void deriv(ll fd,ll *f,ll *res)&#123; for(register int i=1;i&lt;fd;++i) &#123; res[i-1]=(li)f[i]*i%MOD; &#125; res[fd-1]=0;&#125;inline void integ(ll fd,ll *f,ll *res)&#123; for(register int i=1;i&lt;fd;++i) &#123; res[i]=(li)f[i-1]*qpow(i,MOD-2)%MOD; &#125; res[0]=0;&#125; 多项式乘法略 多项式求逆Luogu P4238 Luogu P4239 如果$F(x)$只有一项，那么答案是它的逆元。 剩下的情况考虑递归做，假设已经求出了$\bmod{x^{\lceil\frac{n}{2}\rceil}}$意义下的答案$H(x)$，考虑推出$\bmod{x^n}$意义下的答案$G(x)$，于是有： F(x)H(x)\equiv 1\pmod{x^{\lceil\frac{n}{2}\rceil}}F(x)G(x)\equiv 1\pmod{x^n}\therefore F(x)(G(x)-H(x))\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\therefore G(x)-H(x)\equiv 0\pmod{x^{\lceil\frac{n}{2}\rceil}}\therefore G(x)^2-2G(x)H(x)+H(x)^2\equiv 0\pmod{x^n}\therefore G(x)\equiv 2H(x)-F(x)H(x)^2\pmod{x^n}于是可以快活地上板子啦qwq123456789101112131415161718192021222324252627282930inline void inv(ll fd,ll *f,ll *res)&#123; static ll tmp[MAXN]; if(fd==1) &#123; res[0]=qpow(f[0],MOD-2); return; &#125; inv((fd+1)&gt;&gt;1,f,res); ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;++i) &#123; tmp[i]=i&lt;fd?f[i]:0; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp,cnt,1),NTT(res,cnt,1); for(register int i=0;i&lt;cnt;++i) &#123; res[i]=(li)(2-(li)tmp[i]*res[i]%MOD+MOD)%MOD*res[i]%MOD; &#125; NTT(res,cnt,-1); for(register int i=fd;i&lt;cnt;++i) &#123; res[i]=0; &#125;&#125; 多项式除法Luogu P4512 首先定义$F_R(x)$是指$F(x)$系数反转后所得的多项式。 \texttt{e.g:}F(x)=x^2+2x+3,F_R(x)=3x^2+2x+1很显然，对于$n$次多项式$F(x),F_R(x)=x^nF(\frac{1}{x})$ 还有，对于一个$n$次的多项式$F(x)$和一个$m$次的多项式$G(x)$，它们的商$Q(x)$是$n-m$次的，余数$R(x)$是$m-1$次的。 所以，有了这些就可以愉快的推公式了qwq F(x)=G(x)Q(x)+R(x)把$\frac{1}{x}$代入 F(\frac{1}{x})=G(\frac{1}{x})Q(\frac{1}{x})+R(\frac{1}{x})两边乘个$x^n$ x^nF(\frac{1}{x})=x^{m}G(\frac{1}{x})x^{n-m}Q(\frac{1}{x})+x^{n-m+1}x^{m-1}R(\frac{1}{x})F_R(x)=G_R(x)Q_R(x)+x^{n-m+1}R_R(x)把它换成$\bmod {x^{n-m+1}}$意义下的式子 F_R(x)\equiv G_R(x)Q_R(x)\pmod {x^{n-m+1}}Q_R(x)\equiv F_R(x)G_R^{-1}(x)\pmod {x^{n-m+1}}通过这个式子求得$Q(x)$，再代入原来的式子求出$R(x)$即可。 精彩的上代码环节 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647inline void div(ll fd,ll gd,ll *f,ll *g,ll *q,ll *r)&#123; static ll tmpf[MAXN],tmpg[MAXN],tinv[MAXN]; for(register int i=0;i&lt;fd;i++) &#123; tmpf[i]=f[fd-1-i]; &#125; for(register int i=0;i&lt;gd;i++) &#123; tmpg[i]=g[gd-1-i]; &#125; inv(fd-gd+2,tmpg,tinv); ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmpf,cnt,1),NTT(tinv,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; q[i]=(li)tmpf[i]*tinv[i]%MOD; &#125; NTT(q,cnt,-1),reverse(q,q+fd-gd+1); for(register int i=0;i&lt;cnt;i++) &#123; tmpf[i]=0; q[i]=i&lt;fd-gd+1?q[i]:0,g[i]=i&lt;gd?g[i]:0; &#125; NTT(q,cnt,1),NTT(g,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; tmpf[i]=(li)q[i]*g[i]%MOD; &#125; NTT(q,cnt,-1),NTT(g,cnt,-1),NTT(tmpf,cnt,-1); for(register int i=0;i&lt;gd-1;i++) &#123; r[i]=(f[i]-tmpf[i]+MOD)%MOD; &#125; for(register int i=0;i&lt;cnt;i++) &#123; tmpf[i]=tmpg[i]=tinv[i]=0; &#125;&#125; 多项式对数函数Luogu P4725 大力推一波公式： G(x)=\ln F(x)\therefore G^\prime(x)=(\ln F(x))^\prime根据链式求导法则$\frac{\mathrm{d}y}{\mathrm{d}x}=\frac{\mathrm{d}y}{\mathrm{d}u}\frac{\mathrm{d}u}{\mathrm{d}x}$和基本公式$\frac{\mathrm{d}}{\mathrm{d}x}\ln x=\frac{1}{x}$，有 G^\prime(x)=\frac{F^\prime(x)}{F(x)}再积分回来 \therefore G(x)=\int\frac{F^\prime(x)}{F(x)}\,\mathrm{d}x于是又可以快活地上板子啦qwq123456789101112131415161718192021222324inline void ln(ll fd,ll *f,ll *res)&#123; static ll pinv[MAXN],der[MAXN]; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; inv(fd,f,pinv),deriv(fd,f,der); for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(pinv,cnt,1),NTT(der,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=(li)der[i]*pinv[i]%MOD; &#125; NTT(der,cnt,-1),integ(fd,der,res); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=pinv[i]=0; &#125;&#125; 多项式指数函数Luogu P4726 还是大力推公式： G(x)=e^{F(x)}先考虑求导，有 G^\prime(x)=F^\prime(x)e^F(x)指数函数还是没有消去，看来这种方法布星。 两边取个对数，再把$F(x)$移过去 \ln G(x)-F(x)=0强行解这个方程布星，考虑牛顿迭代。在膜$x^n$意义下的牛顿迭代式子是这样的（这里不证明） F(x)=F_0(x)-\frac{G(F_0(x))}{G^\prime(F_0(x))}\pmod {x^n}其中，$F_0(x)$是$\bmod x^{\lceil\frac{n}{2}\rceil}$意义下的答案 所以，设$H(x)=\ln x-F(x)$，有 G(x)\equiv G_0(x)-\frac{H(G_0(x))}{H^\prime(G_0(x))}G(x)\equiv G_0(x)(1-\ln G_0(x)+F(x))\pmod {x^n}又因为保证了$F(0)=0$，所以$G(x)$常数项为$1$ 于是可以愉快的上板子了qwq 12345678910111213141516171819202122232425262728293031323334inline void exp(ll fd,ll *f,ll *res)&#123; static ll texp[MAXN]; if(fd==1) &#123; res[0]=1; return; &#125; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; exp((fd+1)&gt;&gt;1,f,res),ln(fd,res,texp); for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; texp[0]=(f[0]+1-texp[0]+MOD)%MOD; for(register int i=1;i&lt;fd;i++) &#123; texp[i]=(f[i]-texp[i]+MOD)%MOD; &#125; NTT(texp,cnt,1),NTT(res,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; res[i]=(li)res[i]*texp[i]%MOD; &#125; NTT(res,cnt,-1); for(register int i=0;i&lt;cnt;i++) &#123; texp[i]=0,res[i]=i&lt;fd?res[i]:0; &#125;&#125; 多项式开根Luogu P5205 Luogu P5277（不要脸的宣传一发） 这里考虑两种做法。 第一种做法，两边取个对数 \ln G(x)=\frac{1}{2}\ln F(x)再取指数 G(x)=e^{\frac{1}{2}\ln F(x)}于是就完工啦qwq 另一种做法是用另一种方式推公式 设$H^2(x)\equiv F(x)\pmod {x^{\lceil\frac{n}{2}\rceil}}$，有 G(x)-H(x)\equiv 0 \pmod {x^{\lceil\frac{n}{2}\rceil}}(G(x)-H(x))^2\equiv 0 \pmod {x^n}G^2(x)-2G(x)H(x)+H^2(x)\equiv 0 \pmod {x^n}F(x)-2G(x)H(x)+H^2(x)\equiv 0 \pmod {x^n}G(x)=\frac{F(x)+H^2(x)}{2H(x)}接着考虑$F_0\neq 0$的情形。 由于第一种做法和下面的分析，可以很明显的知道$G(x)$的每一项都要乘$F_0$的二次剩余。 使用$\texttt{Cipolla}$求解即可。（这种好东西，两段代码都会写） 但是，考虑$\texttt{Cipolla}$的随机性，有些时候可能不会得到想要的结果，可以多试几次，找到那个结果。（我在造$\texttt{P5277}$的数据时出现了好多个常数项是$1$的情况，然后被迫改了十几个测试点的常数项，$\texttt{mmp}$） 由于一些原因，这里先放上第一种做法的代码qwq（很容易被卡）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859typedef pair&lt;ll,ll&gt; pii;inline ll rd()&#123; return rand()%MOD;&#125;inline bool chkx(ll num)&#123; return qpow(num,(MOD-1)&gt;&gt;1)==1;&#125;inline pii mul(pii x,pii y,ll k)&#123; ll x1=x.first,x2=x.second,y1=y.first,y2=y.second; ll res1=((li)x1*y1%MOD+(li)x2*y2%MOD*k)%MOD; ll res2=((li)x2*y1%MOD+(li)x1*y2%MOD)%MOD; return make_pair(res1,res2);&#125;inline ll qres(ll num)&#123; if(!chkx(num)) &#123; return 1; &#125; ll k=rd(); while(chkx(((li)k*k-num+MOD)%MOD)) &#123; k=rd(); &#125; ll kk=((li)k*k-num+MOD)%MOD,exponent=499122177; pii res=make_pair(1,0),base=make_pair(k,1); while(exponent) &#123; if(exponent&amp;1) &#123; res=mul(res,base,kk); &#125; base=mul(base,base,kk),exponent&gt;&gt;=1; &#125; return min(res.first,MOD-res.first);&#125;inline void sqrt(ll fd,ll *f,ll *res)&#123; static ll tsqrt[MAXN]; ll k=f[0],cnt=1; ln(fd,f,tsqrt); while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1; &#125; for(register int i=0;i&lt;=cnt;i++) &#123; tsqrt[i]=tsqrt[i]&amp;1?(tsqrt[i]+MOD)&gt;&gt;1:tsqrt[i]&gt;&gt;1; &#125; exp(fd,tsqrt,res),k=qres(k); for(register int i=0;i&lt;cnt;i++) &#123; res[i]=(li)res[i]*k%MOD; tsqrt[i]=0; &#125;&#125; 多项式快速幂Luogu P5245 Luogu P5273 最好不要用倍增快速幂，尽管大概率卡不掉，但是码量极大。 先推一波公式 G(x)=F^k(x)两边取对数 \ln G(x)=k\ln F(x)再取指数 G(x)=e^{k\ln F(x)}但是，如果$F(x)$的常数项不为$1$，那么代码中求$\ln$的地方会自动将$F(x)$转换成常数项为$1$的多项式，也就是除掉常数项。 这时，要考虑把结果乘上一个$F_0^k$ 可是$F_0$可以等于$0$，这时采用先把$0$删掉再补$0$的方法计算。 所以可以愉快的上代码了qwq 123456789101112131415161718192021222324inline void qpow(ll fd,ll *f,ll *res,ll exponent)&#123; ll k,flag=0; li zero=0; static ll tmpf[MAXN],tmp[MAXN],tmp2[MAXN]; for(register int i=0;i&lt;fd;i++) &#123; !(f[i]||flag)?zero++:flag=1,tmpf[i-zero]=f[i]; &#125; k=tmpf[0],ln(fd-zero,tmpf,tmp); for(register int i=0;i&lt;fd-zero;i++) &#123; tmp[i]=(li)tmp[i]*exponent%MOD; &#125; exp(fd-zero,tmp,tmp2),zero*=exponent,k=qpow(k,exponent); for(register li i=zero;i&lt;fd;i++) &#123; res[i]=(li)tmp2[i-zero]*k%MOD; &#125; for(register int i=0;i&lt;fd;i++) &#123; tmpf[i]=tmp[i]=tmp2[i]=0; &#125;&#125; 多项式三角函数Luogu P5264 像求导积分之类的肯定布星，因为 \frac{\mathrm{d}}{\mathrm{d}x}\sin x=\cos x,\frac{\mathrm{d}}{\mathrm{d}x}\cos x=-\sin x然后这里试一下求导。 G(x)=\sin F(x)G^\prime(x)=F^\prime(x)\cos F(x)G^{\prime\prime}(x)=-(F^\prime(x))^2)\sin F(x)+F^{\prime\prime}(x)\cos F(x)于是，求导很明显解决不了问题。 牛顿迭代也会把你劝退，因为式子也会很复杂，这里就不推导了。 $\texttt{So?}$ 考虑使用欧拉公式，将$F(x)$代入 e^{\mathrm{i}F(x)}=\cos F(x)+\mathrm{i}\sin F(x)再把$-F(x)$代入 e^{-\mathrm{i}F(x)}=\cos (-F(x))+\mathrm{i}\sin (-F(x))诱导公式搞一下 e^{-\mathrm{i}F(x)}=\cos F(x)-\mathrm{i}\sin F(x)两式相加相减 e^{\mathrm{i}F(x)}+e^{-\mathrm{i}F(x)}=2\cos F(x)e^{\mathrm{i}F(x)}-e^{-\mathrm{i}F(x)}=2\mathrm{i}\sin F(x)把那些系数除过去 \cos F(x)=\frac{e^{\mathrm{i}F(x)}+e^{-\mathrm{i}F(x)}}{2}\sin F(x)=\frac{e^{\mathrm{i}F(x)}-e^{-\mathrm{i}F(x)}}{2\mathrm{i}}等等，这个$\mathrm{i}$是怎么回事，乱搞一下 i^2\equiv -1\pmod {998244353}i^2\equiv 998244352\pmod {998244353}很明显蒯一个$\texttt{Cipolla}$的板子，算出来答案是$86583718$（$911660635$也是可以滴） 于是就可以考虑上代码啦qw，详细代码见这里 这里窝把$\sin$和$\cos$放在一起，为了节省空间123456789101112131415inline void trig(ll fd,ll *f,ll *res,ll type)&#123; ll inv2=499122177,inv2i=qpow(I&lt;&lt;1,MOD-2); static ll tmp[MAXN],tmp2[MAXN],texp[MAXN],texp2[MAXN]; for(register int i=0;i&lt;fd;i++) &#123; tmp[i]=(li)I*f[i]%MOD,tmp2[i]=MOD-tmp[i]; &#125; exp(fd,tmp,texp),exp(fd,tmp2,texp2); for(register int i=0;i&lt;fd;i++) &#123; res[i]=type?(texp[i]+texp2[i])%MOD:(texp[i]-texp2[i]+MOD)%MOD; res[i]=(li)res[i]*(type?inv2:inv2i)%MOD; &#125;&#125; 多项式反三角函数Luogu P5265 先讨论$G(x)=\sin^{-1}F(x)$的情形。 两边同时求个导 G^\prime(x)=\frac{F^\prime(x)}{\sqrt{1-F^2(x)}}再积分回来 G(x)=\int \frac{F^\prime(x)}{\sqrt{1-F^2(x)}}\,\mathrm{d}x同理，$G(x)=\tan^{-1}F(x)$就会有 G^\prime(x)=\frac{F^\prime(x)}{1+F^2(x)}积分回来 G^\prime(x)=\int \frac{F^\prime(x)}{1+F^2(x)}\,\mathrm{d}x所以上个板子qwq（这里$\sin^{-1}$和$\tan^{-1}$分开了） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970inline void asin(ll fd,ll *f,ll *res)&#123; static ll der[MAXN],tmp[MAXN],tmp2[MAXN],tmp3[MAXN]; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; deriv(fd,f,der); for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=MOD-f[i]; &#125; for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp,cnt,1),NTT(f,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=(li)tmp[i]*f[i]%MOD; &#125; NTT(tmp,cnt,-1),NTT(f,cnt,-1),tmp[0]=(tmp[0]+1)%MOD; sqrt(fd,tmp,tmp2),inv(fd,tmp2,tmp3); NTT(tmp3,cnt,1),NTT(der,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; tmp3[i]=(li)tmp3[i]*der[i]%MOD; &#125; NTT(tmp3,cnt,-1),integ(fd,tmp3,res); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=tmp[i]=tmp2[i]=tmp3[i]=0; &#125;&#125;inline void atan(ll fd,ll *f,ll *res)&#123; static ll der[MAXN],tmp[MAXN],tmp2[MAXN]; ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; deriv(fd,f,der); for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=f[i]; &#125; for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp,cnt,1),NTT(f,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=(li)tmp[i]*f[i]%MOD; &#125; NTT(tmp,cnt,-1),NTT(f,cnt,-1),tmp[0]=(tmp[0]+1)%MOD; inv(fd,tmp,tmp2); NTT(tmp2,cnt,1),NTT(der,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; tmp2[i]=(li)tmp2[i]*der[i]%MOD; &#125; NTT(tmp2,cnt,-1),integ(fd,tmp2,res); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=tmp[i]=tmp2[i]=0; &#125;&#125; 多项式多点求值Luogu P5050 把求值的点均分成两份，并构造多项式 G_0(x)=\prod\limits_{i=1}^{\lfloor\frac{n}{2}\rfloor}(x-x_i),G_1(x)=\prod\limits_{i=\lfloor\frac{n}{2}\rfloor+1}^{n}(x-x_i)显然，对于$\forall i\in [1,\lfloor\frac{n}{2}\rfloor]$，$G_0(x_i)=0$，$G_1$同理。 于是拿$F(x)$（也就是给定的多项式）暴力除$G_0(x)$，有 F(x)=G_0(x)Q_0(x)+R_0(x)这样，对于$\forall i\in [1,\lfloor\frac{n}{2}\rfloor]$，就有$F(x_i)=R_0(x_i)$。 同理，构造 F(x)=G_1(x)Q_1(x)+R_1(x)对于$\forall i\in [\lfloor\frac{n}{2}\rfloor+1,n]$，就有$F(x_i)=R_1(x_i)$。 所以，问题转化为前$\lfloor\frac{n}{2}\rfloor$个点对$G_0(x)$求值和后$n-\lfloor\frac{n}{2}\rfloor$个点对$G_1(x)$求值的问题，然后就可以愉快的分治啦qwq，分治的过程可以用类似线段树的方法维护（一定要开$4$倍内存） 这里有一个细节：如果$F(x)$的最高次数大于$\prod\limits_{i=0}^N(x-x_i)$要先对$\prod\limits_{i=0}^N(x-x_i)$模一下。 但是，毒瘤的出题人把时间给卡成了$\texttt{1s}$，这样做是没有分的。于是可以在分治到一个地方时循环展开秦九韶暴力算（$\texttt{wys}$在召唤）。经人肉二分可以算出来是$1024$。 可是，由于评测姬的不稳定性，交此题要避开评测高峰期，在一个夜深人静的时候交上去，才有可能$\texttt{AC}$啦（尽管我是在评测高峰期交的） 终于可以上代码啦qwq（写的又长又臭，包括了优化后的多项式取模），详细代码在这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156inline void mod(ll fd,ll gd,ll *f,ll *g,ll *r)&#123; static ll tmpf[MAXN],tmpg[MAXN],tinv[MAXN],q[MAXN]; if(fd&lt;gd) &#123; for(register int i=0;i&lt;gd-1;i++) &#123; r[i]=f[i]; &#125; return; &#125; for(register int i=0;i&lt;fd;i++) &#123; tmpf[i]=f[fd-1-i]; &#125; for(register int i=0;i&lt;gd;i++) &#123; tmpg[i]=g[gd-1-i]; &#125; inv(fd-gd+2,tmpg,tinv); ll cnt=1,limit=-1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmpf,cnt,1),NTT(tinv,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; q[i]=1ll*tmpf[i]*tinv[i]%MOD; &#125; NTT(q,cnt,-1),reverse(q,q+fd-gd+1); for(register int i=0;i&lt;cnt;i++) &#123; tmpf[i]=tinv[i]=tmpg[i]=0; q[i]=i&lt;fd-gd+1?q[i]:0,g[i]=i&lt;gd?g[i]:0; &#125; cnt&gt;&gt;=1,limit--; for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(q,cnt,1),NTT(g,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; tmpf[i]=1ll*q[i]*g[i]%MOD; &#125; NTT(g,cnt,-1),NTT(tmpf,cnt,-1); for(register int i=0;i&lt;gd-1;i++) &#123; r[i]=(f[i]-tmpf[i]+MOD)%MOD; &#125; for(register int i=0;i&lt;cnt;i++) &#123; q[i]=tmpf[i]=0; &#125;&#125;vector&lt;ll&gt; tmpf2[MAXN&lt;&lt;2];void dnc(ll *pts,ll l,ll r,ll node)&#123; static ll tmp[MAXN],tmp2[MAXN]; if(l==r) &#123; tmpf2[node].push_back((MOD-pts[l])%MOD),tmpf2[node].push_back(1); return; &#125; ll mid=(l+r)&gt;&gt;1,ls=node&lt;&lt;1,rs=ls|1; dnc(pts,l,mid,ls),dnc(pts,mid+1,r,rs); ll d=tmpf2[ls].size(),d2=tmpf2[rs].size(); for(register int i=0;i&lt;d;i++) &#123; tmp[i]=tmpf2[ls][i]; &#125; for(register int i=0;i&lt;d2;i++) &#123; tmp2[i]=tmpf2[rs][i]; &#125; ll cnt=1,limit=-1; while(cnt&lt;(d+d2)) &#123; cnt&lt;&lt;=1,limit++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;limit); &#125; NTT(tmp,cnt,1),NTT(tmp2,cnt,1); for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=1ll*tmp[i]*tmp2[i]%MOD; &#125; NTT(tmp,cnt,-1); for(register int i=0;i&lt;d+d2-1;i++) &#123; tmpf2[node].push_back(tmp[i]); &#125; for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=tmp2[i]=0; &#125;&#125;;ll tmpf3[17][MAXN];void dnc2(ll fd,ll *f,ll depth,ll l,ll r,ll node,ll *pts,ll *res)&#123; static ll tmp[MAXN],pw[17]; if(r-l&lt;=1024) &#123; for(register int i=l;i&lt;=r;i++) &#123; ll x=pts[i],cur=f[fd-1],v1,v2,v3,v4; pw[0]=1; for(register int j=1;j&lt;=16;j++) &#123; pw[j]=1ll*pw[j-1]*x%MOD; &#125; for(register int j=fd-2;j-15&gt;=0;j-=16) &#123; v1=(1ll*cur*pw[16]+1ll*f[j]*pw[15]+ 1ll*f[j-1]*pw[14]+1ll*f[j-2]*pw[13])%MOD; v2=(1ll*f[j-3]*pw[12]+1ll*f[j-4]*pw[11]+ 1ll*f[j-5]*pw[10]+1ll*f[j-6]*pw[9])%MOD; v3=(1ll*f[j-7]*pw[8]+1ll*f[j-8]*pw[7]+ 1ll*f[j-9]*pw[6]+1ll*f[j-10]*pw[5])%MOD; v4=(1ll*f[j-11]*pw[4]+1ll*f[j-12]*pw[3]+ 1ll*f[j-13]*pw[2]+1ll*f[j-14]*pw[1])%MOD; cur=(0ll+v1+v2+v3+v4+f[j-15])%MOD; &#125; for(register int j=((fd-1)&amp;15)-1;~j;j--) &#123; cur=(1ll*cur*x+f[j])%MOD; &#125; res[i]=cur; &#125; return; &#125; ll sz=tmpf2[node].size()-1; for(register int i=0;i&lt;sz+1;i++) &#123; tmp[i]=tmpf2[node][i]; &#125; mod(fd,sz+1,f,tmp,tmpf3[depth]); ll mid=(l+r)&gt;&gt;1; dnc2(sz,tmpf3[depth],depth+1,l,mid,node&lt;&lt;1,pts,res); dnc2(sz,tmpf3[depth],depth+1,mid+1,r,(node&lt;&lt;1)|1,pts,res); for(register int i=0;i&lt;sz;i++) &#123; tmpf3[depth][i]=0; &#125;&#125;inline void eval(ll fd,ll pcnt,ll *f,ll *pts,ll *res)&#123; dnc(pts,0,pcnt-1,1),dnc2(fd,f,0,0,pcnt-1,1,pts,res);&#125; 多项式快速插值（凑到$800$行啦。。。）]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
        <tag>数论，数学</tag>
        <tag>微积分初步</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4213」【模板】杜教筛（Sum）]]></title>
    <url>%2F2019%2F03%2F10%2F%E3%80%8CLuogu-P4213%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9D%9C%E6%95%99%E7%AD%9B%EF%BC%88Sum%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一共有$T$组数据，对于每组数据，求$\sum\limits_{i=1}^{n}\varphi(i)$和$\sum\limits_{i=1}^{n}\mu(i)$ $\texttt{Data Range:}T\leq 10,n\leq 2^{31}-1$ 链接前置知识积性函数对于一个数论函数$f$，如果对于任意的互质整数$i,j$，使得$f(ij)=f(i)f(j)$，那么说$f$是一个积性函数。 如果对于任意的整数$i,j$，使得$f(ij)=f(i)f(j)$，那么说$f$是一个完全积性函数。 常见的积性函数：$\varphi,\mu,\sigma,d$ 常见的完全积性函数：$\epsilon,id,I$ 这里解释一下完全积性函数下的三个函数。 $\epsilon(n)=[n=1],I(n)=1,id(n)=n$ 狄利克雷卷积对于两个数论函数$f,g$，它们的狄利克雷卷积是$\sum\limits_{d\vert n}f(d)g(\frac{n}{d})$，记作$(f\ast g)(n)$]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>数论，数学</tag>
        <tag>筛法</tag>
        <tag>线性筛</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4726」【模板】多项式指数函数]]></title>
    <url>%2F2019%2F02%2F18%2F%E3%80%8CLuogu-P4726%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个$n-1$次整系数多项式$F(x)$，求在$\bmod x^n$意义下的整系数多项式$G(x)$，使得$G(x)=e^{F(x)}$。 在$\bmod 998244353$下进行，且$F(x)$系数均在$[0,998244352]$范围内。首先考虑与多项式对数函数一样的做法，两边求导，会得到这样一个式子： G^\prime(x)=F^\prime(x)e^{F(x)}但是$e^{F(x)}$没有消去，所以这种方法就这样活生生地被搞掉了。 然后考虑与多项式求逆一样去倍增。假设知道$H(x)=e^{F(x)}\pmod x^{\lceil\frac{n}{2}\rceil}$，想推出$G(x)$，那么肿么办？ 一个常见的策略是牛顿迭代。]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
        <tag>洛谷</tag>
        <tag>模板</tag>
        <tag>数论，数学</tag>
        <tag>微积分初步</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4725」【模板】多项式对数函数]]></title>
    <url>%2F2019%2F02%2F18%2F%E3%80%8CLuogu-P4725%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个$n-1$次整系数多项式$F(x)$，求在$\bmod x^n$意义下的整系数多项式$G(x)$，使得$G(x)=\ln F(x)$。 在$\bmod 998244353$下进行，且$F(x)$系数均在$[0,998244352]$范围内。 链接Luogu P4725 题解首先声明，这题要使用微积分知识。（不会的可以看我的微积分初步的笔记（一个大坑）） 自然对数直接求感觉很不对劲，但是有这样一个好东西： \cfrac{\mathrm{d}}{\mathrm{d}x}\ln x=\cfrac{1}{x}所以说可以考虑将等式两边求导，右边用链式求导法则搞一下，会得到这个 G^\prime(x)=\cfrac{F^\prime(x)}{F(x)}右边很明显，是$F(x)$的逆乘上它的导数，使用多项式求导和求逆即可算出右边。左边是$G(x)$的导数，而右边是可以求出的多项式，所以可以对右边在膜意义下求不定积分求出$G(x)$，即 G(x)=\int \cfrac{F^\prime(x)}{F(x)}时间复杂度当然只有多项式求逆的$O(n\log n)$啦qwq 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=3e5+51,MOD=998244353,G=3;ll fd,gd;ll f[MAXN],res[MAXN],tmp[MAXN],pinv[MAXN],der[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll qadd(ll x,ll y,ll mod)&#123; return x+y&gt;mod?x+y-mod:x+y;&#125;inline ll qmin(ll x,ll y,ll mod)&#123; return x-y&lt;0?x-y+mod:x-y;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; if(!exponent) &#123; return 1; &#125; ll temp=qpow(base,exponent&gt;&gt;1,mod),res=temp*temp%mod; if(exponent&amp;1) &#123; res=res*base%mod; &#125; return res;&#125;inline void NTT(ll *cp,ll cnt,ll inv,ll mod)&#123; ll lim=0,cur=0,res=0,omg=0; while((1&lt;&lt;lim)&lt;cnt) &#123; lim++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; cur=0; for(register int j=0;j&lt;lim;j++) &#123; if((i&gt;&gt;j)&amp;1) &#123; cur|=(1&lt;&lt;(lim-j-1)); &#125; &#125; if(i&lt;cur) &#123; swap(cp[i],cp[cur]); &#125; &#125; for(register int i=2;i&lt;=cnt;i&lt;&lt;=1) &#123; cur=i&gt;&gt;1,res=qpow(G,(mod-1)/i,mod); for(register ll *p=cp;p!=cp+cnt;p+=i) &#123; omg=1; for(register int j=0;j&lt;cur;j++) &#123; ll t=omg*p[j+cur]%mod; p[j+cur]=qmin(p[j],t,mod); p[j]=qadd(p[j],t,mod); omg=omg*res%mod; &#125; &#125; &#125; if(inv==-1) &#123; ll invl=qpow(cnt,mod-2,mod); cp[0]=cp[0]*invl%mod; for(register int i=1;i&lt;=cnt&gt;&gt;1;i++) &#123; cp[i]=cp[i]*invl%mod; if(i!=cnt-i) &#123; cp[cnt-i]=cp[cnt-i]*invl%mod; &#125; swap(cp[i],cp[cnt-i]); &#125; &#125;&#125;inline void deriv(ll fd,ll *f,ll *res,ll mod)&#123; for(register int i=1;i&lt;fd;i++) &#123; res[i-1]=f[i]*i%mod; &#125; res[fd-1]=0;&#125;inline void integ(ll fd,ll *f,ll *res,ll mod)&#123; for(register int i=1;i&lt;fd;i++) &#123; res[i]=f[i-1]*qpow(i,mod-2,mod)%mod; &#125; res[0]=0;&#125;inline void inv(ll fd,ll *f,ll *res,ll mod)&#123; if(fd==1) &#123; res[0]=qpow(f[0],mod-2,mod); return; &#125; inv((fd+1)&gt;&gt;1,f,res,mod); ll cnt=1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1; &#125; for(register int i=0;i&lt;cnt;i++) &#123; tmp[i]=i&lt;fd?f[i]:0; &#125; NTT(tmp,cnt,1,mod),NTT(res,cnt,1,mod); for(register int i=0;i&lt;cnt;i++) &#123; res[i]=qmin(2,tmp[i]*res[i]%mod,mod)*res[i]%mod; &#125; NTT(res,cnt,-1,mod); for(register int i=fd;i&lt;cnt;i++) &#123; res[i]=0; &#125;&#125;inline void ln(ll fd,ll *f,ll *res,ll mod)&#123; ll cnt=1; while(cnt&lt;(fd&lt;&lt;1)) &#123; cnt&lt;&lt;=1; &#125; inv(fd,f,pinv,mod),deriv(fd,f,der,mod); NTT(pinv,cnt,1,mod),NTT(der,cnt,1,mod); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=der[i]*pinv[i]%mod; &#125; NTT(der,cnt,-1,mod),integ(fd,der,res,mod); for(register int i=0;i&lt;cnt;i++) &#123; der[i]=pinv[i]=0; &#125;&#125;int main()&#123; fd=read(); for(register int i=0;i&lt;fd;i++) &#123; f[i]=read(); &#125; ln(fd,f,res,MOD); for(register int i=0;i&lt;fd;i++) &#123; printf("%lld ",res[i]); &#125;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
        <tag>洛谷</tag>
        <tag>模板</tag>
        <tag>数论，数学</tag>
        <tag>微积分初步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ题解合集]]></title>
    <url>%2F2019%2F01%2F27%2FBZOJ%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[较慢更新ing…… 1001-19991001-10991001-10091002 [FJOI2007]轮状病毒 简单的$\texttt{Matrix-Tree}$定理的运用，找规律+高精。 题解 1011-10191012 [JSOI2008]最大数maxnumber 线段树裸题。 题解 1013 [JSOI2008]球形空间产生器sphere 构造二次方程组，相邻两项作差得到一次方程组，高斯消元即可。 题解 1015 [JSOI2008]星球大战starwar 考虑逆推加边，并查集即可。 题解 1040-10491041 [HAOI2008]圆上的整点 比较复杂的神仙数论题。 题解 1042 [HAOI2008]硬币购物 DP+容斥。 题解 今天暂时更到这里。]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>BZOJ</tag>
        <tag>合集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2144」[FJOI2007]轮状病毒]]></title>
    <url>%2F2019%2F01%2F27%2F%E3%80%8CLuogu-P2144%E3%80%8D-FJOI2007-%E8%BD%AE%E7%8A%B6%E7%97%85%E6%AF%92%2F</url>
    <content type="text"><![CDATA[有$n+1$个点组成一个无向图，其中$n$个点组成一个环，剩下一个点向这$n$个点各连一条边，求这个图不同的生成树个数。 Data Range：$n\leq 100$ 链接Luogu P2144BZOJ 1002CodeVS 2886 题解既然这个题要你生成树数量，那么就可以用$\texttt{Matrix-Tree}$定理乱搞了。 设$F_i$表示$n=i$时的答案，那么有： $F_1=1,F_2=5,F_3=16,F_4=45\cdots$ 好像看不出来啊，然而你可以打一个$O(n^3)$的高斯消元求行列式，所以又可以算出一下数据： $F_5=121,F_6=320$ 那么可以看到奇数项都是平方数，于是想把偶数项拆成有关平方数的式子。 那么$F_1=1^2,F_2=3^2-4,F_3=4^2,F_4=7^2-4,F_5=11^2,F_6=18^2-4$ 于是考虑怎么推出这些平方项的。把它们提出来，会是这样： $1,3,4,7,11,18\cdots$ 所以这一项会是前两项的和，于是就可以开开心心写了。 但是$n\leq 100$，所以要用到高精qwq。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=151;struct BigInt&#123; ll digit; ll num[MAXN]; BigInt() &#123; memset(num,0,sizeof(num)); &#125; inline void operator =(ll x) &#123; while(x) &#123; num[digit++]=x%100000000,x/=100000000; &#125; &#125; inline void op() &#123; printf("%lld",num[digit-1]); for(register int i=digit-2;i&gt;=0;i--) &#123; if(!num[i]) &#123; printf("00000000"); continue; &#125; ll rest=7-(ll)(log10(num[i])); for(register int j=rest;j;j--) &#123; putchar('0'); &#125; printf("%lld",num[i]); &#125; &#125;&#125;; BigInt res;BigInt sqr[151];ll num;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline BigInt operator +(BigInt x,BigInt y)&#123; BigInt res; ll carry=0; res.digit=max(x.digit,y.digit)+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]+y.num[i]+carry; carry=res.num[i]/100000000,res.num[i]%=100000000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator *(BigInt x,ll y)&#123; BigInt res; ll carry=0; res.digit=x.digit+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]*y+carry; carry=res.num[i]/100000000,res.num[i]%=100000000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator *(BigInt x,BigInt y)&#123; BigInt res; res.digit=x.digit+y.digit; for(register int i=0;i&lt;res.digit;i++) &#123; for(register int j=0,k=i;k&gt;=0;j++,k--) &#123; res.num[i]+=x.num[j]*y.num[k]; res.num[i+1]+=res.num[i]/100000000,res.num[i]%=100000000; &#125; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline void setup(ll num)&#123; sqr[1]=1,sqr[2]=3; for(register int i=3;i&lt;=num;i++) &#123; sqr[i]=sqr[i-1]+sqr[i-2]; &#125;&#125;int main()&#123; num=read(); setup(num); res=sqr[num]*sqr[num],res.num[0]-=(num&amp;1)?0:4; res.op();&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>CodeVS</tag>
        <tag>组合数学</tag>
        <tag>生成树</tag>
        <tag>Matrix-Tree定理</tag>
        <tag>高精</tag>
        <tag>打表</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4245」【模板】任意模数NTT]]></title>
    <url>%2F2019%2F01%2F26%2F%E3%80%8CLuogu-P4245%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0NTT%2F</url>
    <content type="text"><![CDATA[给定两个$n$次多项式$F(x),G(x)$的系数数列$a,b$和一个整数$p$，求$F(x)G(x)$在$\bmod p$意义下的值，不保证$p$可以分解成$a\cdot 2^k+1$的形式。 Data Range：$1\leq n\leq 10^5,0\leq a_i,b_i\leq 10^9,2\leq p\leq 10^9+9$ 链接Luogu P4245 题解如果$p$是形如$a\cdot 2^k+1$的质数，可以直接刚$\texttt{NTT}$，但是布星啊，样例中的$p$都不是质数，所以说怎么办呢？ 用$\texttt{NTT}$计算多项式乘法的最终结果是取模后的，所以考虑采用$\texttt{CRT}$合并答案。 但是，答案要在$\texttt{long long}$范围内唯一，所以取两个模数布星，要取三个，即所谓的三模数$\texttt{NTT}$。 这里我个人倾向于取$p_1=469762049$，$p_2=998244353$和$p_3=1004535809$，因为这三个数的原根是$3$。 于是可以通过$\texttt{NTT}$算出所给的多项式在模$p_1,p_2,p_3$意义下的乘积。 坑。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=4e5+51,G=3;const ll MOD1=469762049,MOD2=998244353,MOD3=1004535809;const ll MOD=468937312667959297;struct Polynomial&#123; ll deg; ll coeff[MAXN];&#125;;Polynomial x,y,res1,res2,res3;ll cnt,mod;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll qadd(ll x,ll y,ll mod)&#123; return x+y&gt;mod?x+y-mod:x+y;&#125;inline ll qmin(ll x,ll y,ll mod)&#123; return x-y&lt;0?x-y+mod:x-y;&#125;inline ll qmul(ll x,ll y,ll mod)&#123; x%=mod,y%=mod; return ((x*y-(ll)((ll)((long double)x/mod*y+0.5)*mod))%mod+mod)%mod;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; if(!exponent) &#123; return 1; &#125; ll temp=qpow(base,exponent&gt;&gt;1,mod),res=temp*temp%mod; if(exponent&amp;1) &#123; res=res*base%mod; &#125; return res;&#125;inline void NTT(ll *cp,ll cnt,ll inv,ll mod)&#123; ll lim=0,cur=0,res=0,omg=0; while((1&lt;&lt;lim)&lt;cnt) &#123; lim++; &#125; for(register int i=0;i&lt;cnt;i++) &#123; cur=0; for(register int j=0;j&lt;lim;j++) &#123; if((i&gt;&gt;j)&amp;1) &#123; cur|=(1&lt;&lt;(lim-j-1)); &#125; &#125; if(i&lt;cur) &#123; swap(cp[i],cp[cur]); &#125; &#125; for(register int i=2;i&lt;=cnt;i&lt;&lt;=1) &#123; cur=i&gt;&gt;1,res=qpow(G,(mod-1)/i,mod); for(register ll *p=cp;p!=cp+cnt;p+=i) &#123; omg=1; for(register int j=0;j&lt;cur;j++) &#123; ll t=omg*p[j+cur]%mod; p[j+cur]=qmin(p[j],t,mod); p[j]=qadd(p[j],t,mod); omg=omg*res%mod; &#125; &#125; &#125;&#125;inline Polynomial mul(Polynomial x,Polynomial y,ll mod)&#123; Polynomial res; ll cnt=1,inv; static ll cpx[MAXN],cpy[MAXN]; memset(cpx,0,sizeof(cpx)),memset(cpy,0,sizeof(cpy)); for(register int i=0;i&lt;=x.deg;i++) &#123; cpx[i]=x.coeff[i]; &#125; for(register int i=0;i&lt;=y.deg;i++) &#123; cpy[i]=y.coeff[i]; &#125; while(cnt&lt;=x.deg+y.deg) &#123; cnt&lt;&lt;=1; &#125; NTT(cpx,cnt,1,mod),NTT(cpy,cnt,1,mod); for(register int i=0;i&lt;=cnt;i++) &#123; cpx[i]=cpx[i]*cpy[i]%mod; &#125; NTT(cpx,cnt,-1,mod); res.deg=x.deg+y.deg,inv=qpow(cnt,mod-2,mod); cpx[0]=cpx[0]*inv%mod; for(register int i=1;i&lt;=cnt&gt;&gt;1;i++) &#123; cpx[i]=cpx[i]*inv%mod; if(i!=cnt-i) &#123; cpx[cnt-i]=cpx[cnt-i]*inv%mod; &#125; swap(cpx[i],cpx[cnt-i]); &#125; for(register int i=0;i&lt;=res.deg;i++) &#123; res.coeff[i]=qmin(cpx[i],0,mod); &#125; return res;&#125;inline ll CRT(ll r1,ll r2,ll r3,ll mod)&#123; ll inv1=208783132,inv2=395249030; ll r=qadd(qmul(qmul(qmin(r1,r2,MOD1),inv1,MOD1),MOD2,MOD),r2,MOD); ll k=qmul(qmin(r3,r,MOD3),inv2,MOD3); return ((k%mod)*(MOD%mod)%mod+r)%mod;&#125;int main()&#123; x.deg=read(),y.deg=read(),mod=read(); for(register int i=0;i&lt;=x.deg;i++) &#123; x.coeff[i]=read()%mod; &#125; for(register int i=0;i&lt;=y.deg;i++) &#123; y.coeff[i]=read()%mod; &#125; res1=mul(x,y,MOD1),res2=mul(x,y,MOD2),res3=mul(x,y,MOD3); for(register int i=0;i&lt;=res1.deg;i++) &#123; printf("%lld ",CRT(res1.coeff[i],res2.coeff[i],res3.coeff[i],mod)); &#125;&#125;]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
        <tag>洛谷</tag>
        <tag>模板</tag>
        <tag>数论，数学</tag>
        <tag>CRT</tag>
        <tag>MTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·多项式专题（一）]]></title>
    <url>%2F2019%2F01%2F20%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[多项式，爽！ FFT$\texttt{DFT,IDFT}$的思想$\texttt{FFT}$，即快速傅里叶变换（英文名$\texttt{Fast Fourier Transform}$），是一个用来求卷积的方法。 卷积这个词以后会经常用到，所以先普及一下这个词到底是什么意思。 形如$h_n=\sum\limits_{i}f_ig_{n-i}$的式子，将$h$称为$f$和$g$的卷积。 但是这个东西有一个更直观的名字：多项式乘法！ 为什么呢？这里解释一下。 比如说有两个$n$次的多项式$F(x)$和$G(x)$，它们乘起来为$H(x)$，这些多项式的系数数列依次为$f,g,h$，有 h_i=\sum\limits_{j}f_jg_{i-j}为什么呢？ 众所周知，$H(x)=\sum\limits_{i=0}^{n}h_ix^i$。 为了凑一个$x^i$，如果$F(x)$出$f_jx^j$的话，那么$G(x)$只能出$g_{i-j}x^{i-j}$。 所以，$h_ix^i=\sum\limits_{j=0}^{i}f_jx^j\cdot g_{i-j}x^{i-j}$ 把$x^i$约去，有 h_i=\sum\limits_{j}f_jg_{i-j}然而，普通的多项式乘法要对$F(x)$和$G(x)$每一项进行相乘，时间复杂度为$O(n^2)$，布星。 所以说，有没有更快一点的方法呢？ 还真有！！ 首先看一个问题。 给定有$n$个点$(a_i,F(a_i))$。$F(x)$是几次多项式呢？怎么求$F(x)$呢？ 先考虑一个简单的，比如说给出了两个点,$(0,1)$和$(1,3)$，怎么求$F(x)$？ 比如说，假设$F(x)$是一次的。那么设$F(x)=a_0x+a_1$，于是将$(0,1),(1,3)$代入$F(x)$，那么有： \begin{cases}a_1=1 \\ a_0+a_1=3\end{cases}解得 \begin{cases}a_0=2 \\ a_1=1\end{cases}而当$F(x)$为二次多项式时，即$F(x)=a_0x^2+a_1x+a_2$，那么可列出如下式子： \begin{cases}a_2=1 \\ a_0+a_1+a_2=3\end{cases}这样子我们最多得到 \begin{cases}a_0+a_1=2 \\ a_2=3\end{cases}$F(x)$为二次多项式就已经不能精确解出系数的值了，那么更高次多项式更不行了。 所以说给两个点的值能确定一个一次多项式。 可以尝试一下$3$个点，它是可以确定一个二次多项式的（可能不能确定一个一次多项式，因为方程组可能无解）。 根据以上的实验和常识可知，$n$个点最多确定一个$n-1$次多项式。 那么我们现在理论上证明一下。 首先看一个小问题。 给定$m$个值$a_i$和$n$次多项式$F(x)$，求$F(a_i)$。 考虑把它写成矩阵的形式，有 \begin{pmatrix}1 & \cdots & a_1^n\\ \vdots & \ddots & \vdots \\ 1 & \cdots & a_m^n \end{pmatrix}\times\begin{pmatrix}f_0 \\ \vdots \\ f_n \end{pmatrix}=\begin{pmatrix}F(a_1) \\ \vdots \\ F(a_n) \end{pmatrix}所以 \begin{pmatrix}f_0 \\ \vdots \\ f_n \end{pmatrix}=\begin{pmatrix}F(a_1) \\ \vdots \\ F(a_n) \end{pmatrix}\times \begin{pmatrix}1 & \cdots & a_1^n\\ \vdots & \ddots & \vdots \\ 1 & \cdots & a_m^n \end{pmatrix}^{-1}只有在右边的矩阵为方阵，即为范德蒙德矩阵时它才可能有逆。 所以$n+1=m$，即$n=m-1$，即确定的多项式为$m-1$次。 所以说，一个$n-1$次多项式与它的曲线上的$n$个点的集合是等价的，而这个集合，叫做多项式的点值表达。 下面说点值表达是怎么优化多项式乘法的。 两个多项式相乘，如果是用系数乘法，是$O(n^2)$的，但点值乘法只需对应的点值相乘，时间复杂度为$O(n)$。 但是你插值的时候会出问题。 两个$n$次多项式相乘，乘出来的多项式明摆的是$2n$次的，可是两个$n$次多项式给出的点值只有$n+1$个。在称完之后插不出确定的多项式。怎么办？ 考虑扔一些点上去凑即可。这些点只是起到附加作用，并没有对原来的多项式有影响。 所以点值表达有什么用？还不是加速多项式乘法。 于是自然的考虑先求点值，相乘后插值即可。这就是$\texttt{FFT}$的流程。 把系数表达转换为点值表达叫做$\texttt{DFT}$， 把点值表达转换为系数表达叫做$\texttt{IDFT}$。 什么鬼！！求值是$O(n^2)$的，插值是$O(n^3)$的，你跟我讲这个？？ 别着急。你只要代的数好的话就可以大大简化。 复数的性质以及单位根的引入先来回答上面的问题。 想我们这种小蒟蒻只会代入人畜无害的有理数，但这对计算无益。 但这时，有一位搞复数的$\texttt{dalao}$横空出世，他就是傅里叶。 这人啊，把单位根代入多项式想求点值表达，可是由于单位根有一些优秀的性质，就可以分治做到$O(n\log n)$。 接着，我们来介绍复数。]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FFT</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5160」WD与循环]]></title>
    <url>%2F2019%2F01%2F01%2F%E3%80%8CLuogu-P5160%E3%80%8DWD%E4%B8%8E%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[给定$n,m$，求以下代码的运行结果：12345678910111213int cnt=0;for(register int a_1=0;a_1&lt;=m;a_1++)&#123; for(register int a_2=0;a_1+a_2&lt;=m;a_2++) &#123; ... for(register int a_n=0;a_1+a_2+...+a_n&lt;=m;a_n++) &#123; cnt=(cnt+1)%19491001; &#125; &#125;&#125;printf("%d\n", cnt); Solution先声明：$19491001$是质数！质数的日子一般都会发生大事，比如说以1开头的某个8位质数如同第一题一样，可以考虑爆搜出小样例。（程序是个坑）还是一样，设$(n,m)$表示循环个数为$n$，上界为$m$时的答案]]></content>
      <tags>
        <tag>组合数学</tag>
        <tag>找规律</tag>
        <tag>Lucas定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5159」WD与矩阵]]></title>
    <url>%2F2018%2F12%2F31%2F%E3%80%8CLuogu-P5159%E3%80%8DWD%E4%B8%8E%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[求有多少个$n\times m$的矩阵，使得每行每列异或值都是$0$。 Data Range：$T\leq 10^5,1\leq n,m\leq 10^9$ Solution先声明一下，$(n,m)$表示$n\times m$矩阵的答案，这里假定$n\leq m$，因为$(n,m)=(m,n)$。 不知道有没有人在看到这题的时候想到了NOIP 2018的填数游戏，按照这个思路，可以写一个爆搜跑一下小数据，这里记录一下我得到的小数据的答案： $(2,2)=2,(2,3)=4,(2,4)=8,(2,5)=16,(2,6)=32\cdots$ $(3,3)=16,(3,4)=64,(3,5)=256,(3,6)=1024\cdots$ $(4,4)=512,(4,5)=4096,(4,6)=32768\cdots$ $(5,5)=65536\cdots$ 首先考虑$(n,m)\div (n,m-1)$，把这个值记为$\operatorname{grow}(n)$，于是有： $\operatorname{grow}(2)=2,\operatorname{grow}(3)=4,\operatorname{grow}(4)=8,\operatorname{grow}(5)=16\cdots$ 所以$\operatorname{grow}(n)=2^{n-1}$。 接下来算$(n,n)$，有： $(2,2)=2,(3,3)=16,(4,4)=512,(5,5)=65536$。 乍一看，没什么规律，所以将这些式子变个形： $(2,2)=2^1,(3,3)=2^4,(4,4)=2^9,(5,5)=2^{16}\cdots$ 啊哈！这样就有规律啦qwq！ 于是就有$(n,n)=2^{(n-1)^2}$ 综上，可以得出$(n,m)\equiv 2^{(n-1)^2}\times(2^{n-1})^{m-n}$。 于是就可以用快速幂做啦qwq。 但是这样子$\texttt{Subtask 3}$会TLE，所以考虑优化。 不是有欧拉定理吗？ 所以说可以把$(n-1)^2$模个$\varphi(998244353)=998244352$，就可以完结撒花啦qwq！ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MOD=998244353;ll test,length,width,base,grow;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; if(!exponent) &#123; return 1; &#125; ll temp=qpow(base,exponent&gt;&gt;1,mod),res=temp*temp%mod; if(exponent&amp;1) &#123; res=res*base%mod; &#125; return res;&#125;int main()&#123; test=read(); for(register int i=0;i&lt;test;i++) &#123; length=read(),width=read(); if(length&gt;width) &#123; swap(length,width); &#125; base=qpow(2,(length-1)*(length-1)%(MOD-1),MOD); grow=qpow(2,length-1,MOD); printf("%lld\n",base*qpow(grow,width-length,MOD)%MOD); &#125;&#125;]]></content>
      <tags>
        <tag>打表</tag>
        <tag>找规律</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5110」块速递推]]></title>
    <url>%2F2018%2F12%2F28%2F%E3%80%8CLuogu-P5110%E3%80%8D%E5%9D%97%E9%80%9F%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[给定一个数列$a$，满足如下递推式： $a_n=233a_{n-1}+666a_{n-2}$。 求出这个数列第$n$项$a_n\bmod 10^9+7$的值，一共有$T$组数据，为了减少输出量，请输出这些答案的异或和。 Data Range：$T\leq 5\times 10^7,0\leq n&lt;2^{64}$ 11 Solution首先求$a_n=233a_{n-1}+666a_{n-2}$的通项式。 考虑这个数列的特征方程，为$x^2=233x+666$，于是解出$x_1=\cfrac{233+\sqrt{56953}}{2},x_2=\cfrac{233-\sqrt{56953}}{2}$。 所以可以设这个数列的通项式为$a_n=p(\cfrac{233+\sqrt{56953}}{2})^n+q(\cfrac{233-\sqrt{56953}}{2})^n$。 可别忘了，$a_0=0,a_1=1$，所以解出$p=\cfrac{1}{\sqrt{56953}},q=-\cfrac{1}{\sqrt{56953}}$。 所以$a_n=\cfrac{1}{\sqrt{56953}}[(\cfrac{233+\sqrt{56953}}{2})^n-(\cfrac{233-\sqrt{56953}}{2})^n]$ 现在来解决除号以及根号。首先，枚举得$\sqrt{56953}\equiv 188305837\pmod {10^9+7}$。 所以说 a_n=\cfrac{1}{188305037}(94153035^n-905847205^n)$ 而$188305837^{-1}\equiv 233230706\pmod {10^9+7}所以，最终的通项式就是 a_n=233230706(94153035^n-905847205^n)。 但是，由于毒瘤出题人的毒瘤给分制度，前面六个点每点$1 pts$，所以用龟速幂只能水$6 pts$。我尝试用$O(1)$的按位龟速乘优化了一下后，还是只有$6 pts$。看来我们只能优化计算上面的两个幂的过程。 很明显可以先优化一下指数，由欧拉定理得： $a_{n+\varphi(10^9+7)}\equiv a_n\pmod {10^9+7}$ 于是可以把指数模$\varphi(10^9+7)=10^9+6$，但是还是只能得$6 pts$。 于是考虑$100 pts$的分块打表大法。由上面的结论可知，可以将指数控制在$10^9+6$以内，所以可以考虑分块打表。 可以知道，$\lceil\sqrt{10^9+6}\rceil=31623$，所以以这个数作为块长分块，将它记为$k$。 首先，预处理出 $94153035^0,94153035^1\cdots 94153035^{k-1}$ 和$905847205^0,905847205^1\cdots 905847205^{k-1}$ 然后，用龟速幂可算出 $94153035^k\equiv 37348318\pmod {10^9+7}$，$905847205^k\equiv 482464047\pmod {10^9+7}$ 最后，预处理出 $94153035^k,94153035^2k\cdots 94153035^{k(k-1)}$ 和$905847205^k,905847205^k\cdots 905847205^{k(k-1)}$ 显然，这些步骤的时间复杂度为$O(k)$的。 把询问$m$拆成$ak+b$的形式，其中$0\leq b\leq k-1$。用数学化的语言来讲，$a=\lfloor \frac{m}{k}\rfloor,b=m\bmod k$，所以可以拆成整块和散块来做到$O(1)$查询啦qwq。 时间复杂度为$O(T+\sqrt{10^9+6})$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long int ll;const ll MAXN=31651,MOD=1e9+7,blockSize=31623;ll test,num,res,resx,resy;ll blockx[MAXN],powx[MAXN],blocky[MAXN],powy[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void setup()&#123; blockx[0]=powx[0]=blocky[0]=powy[0]=1; for(register int i=1;i&lt;blockSize;i++) &#123; blockx[i]=blockx[i-1]*37348318ull%MOD; blocky[i]=blocky[i-1]*482464047ull%MOD; powx[i]=powx[i-1]*94153035ll%MOD; powy[i]=powy[i-1]*905847205ll%MOD; &#125;&#125;namespace maker&#123; ll sa,sb,sc; inline void setup() &#123; sa=read(),sb=read(),sc=read(); &#125; inline ll randInt() &#123; sa^=sa&lt;&lt;32,sa^=sa&gt;&gt;13,sa^=sa&lt;&lt;1; ll t=sa; sa=sb,sb=sc,sc^=t^sa; return sc; &#125;&#125;int main()&#123; test=read(); maker::setup(),setup(); for(register int i=0;i&lt;test;i++) &#123; num=maker::randInt()%(MOD-1); resx=blockx[num/blockSize]*powx[num%blockSize]%MOD; resy=blocky[num/blockSize]*powy[num%blockSize]%MOD; res^=(233230706*((resx-resy+MOD)%MOD)%MOD); &#125; printf("%llu",res);&#125;]]></content>
      <tags>
        <tag>打表</tag>
        <tag>数论，数学</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P5104」红包发红包]]></title>
    <url>%2F2018%2F12%2F27%2F%E3%80%8CLuogu-P5104%E3%80%8D%E7%BA%A2%E5%8C%85%E5%8F%91%E7%BA%A2%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一个$w$元钱的红包，有$n$个人抢，求第$k$个人抢的钱的期望。 题解先来看一个引理：$\mathbf{Lemma}\quad$在$l$到$r$中随机选一个实数的期望为$\frac{l+r}{2}$。$\mathbf{Proof:}$采用切片法。由于实数密度的均匀性，可以考虑做极限。考虑将$l$到$r$的实数区间均匀的切$i-1$片，出现$i$个端点，于是对这些数求期望。那么这些数的期望是：$\cfrac{nl+(r-l)\sum\limits_{i=0}^{n-1}\frac{i}{n-1}}{n}$$=l+\cfrac{(r-l)\frac{n}{2}}{n}$$=l+\cfrac{r-l}{2}$$=\cfrac{l+r}{2}$所以，这东西与$i$没任何关系，求极限还是这个值，证毕。回到本题。于是可以知道，第一个人抢的钱的期望是$\frac{w}{2}$，剩下$\frac{w}{2}$元。]]></content>
      <tags>
        <tag>数论，数学</tag>
        <tag>概率</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3690」【模板】Link Cut Tree （动态树）]]></title>
    <url>%2F2018%2F12%2F22%2F%E3%80%8CLuogu-P3690%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91Link-Cut-Tree-%EF%BC%88%E5%8A%A8%E6%80%81%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[给定$n$个点以及它们的点权，要求写一种数据结构支持以下操作：求$x$到$y$路径上点权的$operatorname{xor}$和，连接或删除一条边，以及修改某个点的点权。 链接题解一道LCT裸题。坑。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=3e5+51;ll cnt,qcnt,op,x,y;ll num[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;namespace LCT&#123; struct Node&#123; ll fa,val,tag; ll ch[2]; &#125;; struct LinkCutTree&#123; Node nd[MAXN]; ll st[MAXN]; inline bool nroot(ll x) &#123; return nd[nd[x].fa].ch[0]==x||nd[nd[x].fa].ch[1]==x; &#125; inline void update(ll x) &#123; nd[x].val=nd[nd[x].ch[0]].val^nd[nd[x].ch[1]].val^num[x]; &#125; inline void reverse(ll x) &#123; swap(nd[x].ch[0],nd[x].ch[1]),nd[x].tag^=1; &#125; inline void spread(ll x) &#123; if(nd[x].tag) &#123; if(nd[x].ch[0]) &#123; reverse(nd[x].ch[0]); &#125; if(nd[x].ch[1]) &#123; reverse(nd[x].ch[1]); &#125; nd[x].tag=0; &#125; &#125; inline void rotate(ll x) &#123; ll fa=nd[x].fa,gfa=nd[fa].fa; ll dir=nd[fa].ch[1]==x,son=nd[x].ch[!dir]; if(nroot(fa)) &#123; nd[gfa].ch[nd[gfa].ch[1]==fa]=x; &#125; nd[x].ch[!dir]=fa,nd[fa].ch[dir]=son; if(son) &#123; nd[son].fa=fa; &#125; nd[fa].fa=x,nd[x].fa=gfa; update(fa); &#125; inline void splay(ll x) &#123; ll fa=x,gfa,cur=0; st[++cur]=fa; while(nroot(fa)) &#123; st[++cur]=fa=nd[fa].fa; &#125; while(cur) &#123; spread(st[cur--]); &#125; while(nroot(x)) &#123; fa=nd[x].fa,gfa=nd[fa].fa; if(nroot(fa)) &#123; rotate((nd[fa].ch[0]==x)^(nd[gfa].ch[0]==fa)?x:fa); &#125; rotate(x); &#125; update(x); &#125; inline void access(ll x) &#123; for(register int i=0;x;x=nd[i=x].fa) &#123; splay(x),nd[x].ch[1]=i,update(x); &#125; &#125; inline void makeRoot(ll x) &#123; access(x),splay(x),reverse(x); &#125; inline ll findRoot(ll x) &#123; access(x),splay(x); while(nd[x].ch[0]) &#123; spread(x),x=nd[x].ch[0]; &#125; return x; &#125; inline void split(ll x,ll y) &#123; makeRoot(x),access(y),splay(y); &#125; inline void link(ll x,ll y) &#123; makeRoot(x); if(findRoot(y)!=x) &#123; nd[x].fa=y; &#125; &#125; inline void cut(ll x,ll y) &#123; makeRoot(x); if(findRoot(y)==x&amp;&amp;nd[x].fa==y&amp;&amp;!nd[x].ch[1]) &#123; nd[x].fa=nd[y].ch[0]=0; update(y); &#125; &#125; &#125;;&#125;LCT::LinkCutTree lct;int main()&#123; cnt=read(),qcnt=read(); for(register int i=1;i&lt;=cnt;i++) &#123; num[i]=read(); &#125; for(register int i=0;i&lt;qcnt;i++) &#123; op=read(),x=read(),y=read(); if(!op) &#123; lct.split(x,y); printf("%d\n",lct.nd[y].val); &#125; if(op==1) &#123; lct.link(x,y); &#125; if(op==2) &#123; lct.cut(x,y); &#125; if(op==3) &#123; lct.splay(x),num[x]=y; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
        <tag>树链剖分</tag>
        <tag>模板</tag>
        <tag>Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4289」[HAOI2008]移动玩具]]></title>
    <url>%2F2018%2F12%2F19%2F%E3%80%8CLuogu-P4289%E3%80%8D-HAOI2008-%E7%A7%BB%E5%8A%A8%E7%8E%A9%E5%85%B7%2F</url>
    <content type="text"><![CDATA[给定两个$4\times 4$的$01$矩阵，第一个是初始矩阵，另一个是目标矩阵，每一次可以交换两个相邻的元素，求最少的操作使得初始矩阵可以变换到目标矩阵。 链接Luogu P4289BZOJ 1054]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>各省省选</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2508」[HAOI2008]圆上的整点]]></title>
    <url>%2F2018%2F12%2F16%2F%E3%80%8CLuogu-P2508%E3%80%8D-HAOI2008-%E5%9C%86%E4%B8%8A%E7%9A%84%E6%95%B4%E7%82%B9%2F</url>
    <content type="text"><![CDATA[给定$r$，求满足$x^2+y^2=r^2$的整数对$(x,y)$个数量。 链接Luogu P2508BZOJ 1041CodeVS 1867 前置知识首先引入虚数单位$\mathrm{i}$，表示$\sqrt{-1}$，将$a+b\mathrm{i},a,b\in\mathbb{R}$型的数称为复数（其中$a\in\mathbb{R}$表示$a$为实数）。所以说可以规定一些运算。$a+b\mathrm{i}\pm c+d\mathrm{i}=(a\pm b)+(c\pm d)\mathrm{i}$$(a+b\mathrm{i})(c+d\mathrm{i})=(ac-bd)+(ad+bc)\mathrm{i}$其中，称$a+b\mathrm{i}$的复共轭为$a-b\mathrm{i}$。每一个坐标$(x,y)$，又可以唯一对应到一个复数$x+y\mathrm{i}$，于是将这种一个坐标表示一个复数的平面直角坐标系叫做复平面。对于复平面上的格点$(x,y)$，可以对应到复数$x+y\mathrm{i}$，将这类复数叫做高斯整数。说白了，高斯整数就是满足$a,b$是整数的$a+b\mathrm{i}$型数。而不能再次被分解的数就是高斯素数。比如说，$5$不是高斯素数，因为$5=5+0\mathrm{i}=(2+\mathrm{i})(2-\mathrm{i})$，而分解出的$2+\mathrm{i}$和$2-\mathrm{i}$都是高斯素数。 题解一道码量不长，但是数学知识需求挺多的一道题。先转换一下所给的方程，改成$x^2-(y\mathrm{i})^2=r^2$。拆开可得$(x+y\mathrm{i})(x-y\mathrm{i})=r^2$。而两个括号内互为复共轭，所以只需要解决这个问题，即有多少个$x+y\mathrm{i}$使得它成它的复共轭为$r^2$。这里举个栗子，比如说手玩$r=5$的情况，要先将$r^2$拆成高斯素数的乘积。$25=5^2=(2+\mathrm{i})(2-\mathrm{i})(2+\mathrm{i})(2-\mathrm{i})$在将这些高斯素数分成两列，其中第一列的第$n$个数和第二列的第$n$个数互为复共轭，最后算出来有多少种组合方式。但是这些组合方式满足左边的乘积与右边的乘积互为复共轭吗？答案是显然的，先证明两个高斯整数的乘积与它们的复共轭的乘积互为复共轭。考虑这两个数的乘积，$(a+b\mathrm{i})(c+d\mathrm{i})=(ac-bd)+(ad+bc)\mathrm{i}$。它们的复共轭的乘积，$(a-b\mathrm{i})(c-d\mathrm{i})=(ac-bd)-(ad+bc)\mathrm{i}$。啊哈！它们正好互为复共轭，所以左边的乘积与右边的乘积互为复共轭。但是，还不够。要把答案乘上$4$才行，因为两列数的乘积可以同时乘上$1$或$-1$，或一个乘以$\mathrm{i}$，另一个乘以$-\mathrm{i}$都不改变两列乘起来后两个数的乘积，所以有$4$种变换，所以算出来是$12$。现在来看一般情况。对$r^2$做质因数分解，有$r^2={p_1}^{r_1}{p_2}^{r_2}\cdots {p_k}^{r_k}$。假设现在考虑到$p_i$了（这个$i$与虚数单位的字体不一样），那么……如果$p_i\equiv 1\pmod 4$，那么这个可以分解成两个高斯素数的乘积。这个因子对格点数目点的影响为$r_i+1$，因为可以在左边放$0,1\cdots r_i$个分解后的高斯素数中的一种。如果$p_i\equiv 3\pmod 4$，那么$p_i$本身是高斯素数，对分解的贡献取决于$r_i$，如果$r_i$是奇数，那么这个多出来的因子没地方放，它会使得两边不平衡，没有格点，否则，它可以放两边，对格点个数没有贡献。如果$p_i$为$2$，那么有$2=(1+\mathrm{i})(1-\mathrm{i})$，而这两个复数刚好是旋转$90^{\circ}$的，所以变换少了$2$种，但是带来$2$中组合，对格点个数没有贡献。所以，这个算法只需要分解质因数，然后判断即可。不懂的可以看看这个视频 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=5e4+51;ll r,tot,res=1;ll factor[MAXN],cnt[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void getFact(ll num)&#123; for(register int i=2;i&lt;=num;i++) &#123; if(num==1) &#123; break; &#125; if(num%i==0) &#123; factor[tot]=i; while(num%i==0) &#123; cnt[tot]+=2,num/=i; &#125; tot++; &#125; &#125;&#125;int main()&#123; getFact(r=read()); for(register int i=0;i&lt;tot;i++) &#123; if((factor[i]&amp;3)==1) &#123; res*=(cnt[i]+1); &#125; if((factor[i]&amp;3)==3) &#123; res*=((cnt[i]&amp;1)^1); &#125; &#125; printf("%lld",res&lt;&lt;2);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>CodeVS</tag>
        <tag>各省省选</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4084」[USACO17DEC]Barn Painting]]></title>
    <url>%2F2018%2F12%2F13%2F%E3%80%8CLuogu-P4084%E3%80%8D-USACO17DEC-Barn-Painting%2F</url>
    <content type="text"><![CDATA[咕着先…… 前言开始写题解的今天，正是$12$月$13$日。今天，是南京大屠杀的$81$周年的纪念日。$81$年前，即$1937$年$12$月$13$日。日本侵略者在南京制造了震惊中外的南京大屠杀惨案。这是中华民族的血泪史，饱含着中华人民对日本侵略者的仇恨。现在，我们生活在伟大富强的新中国，与现代的日本作为隔海相望的邻邦，历史的悲剧已平和下来，但是我们不能忘记这次国家的耻辱。所以，我们要以史为鉴，吸取教训，努力学习，奋发图强，不让历史悲剧再次重演。 代码]]></content>
      <tags>
        <tag>DP</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2234」[HNOI2002]营业额统计]]></title>
    <url>%2F2018%2F12%2F03%2F%E3%80%8CLuogu-P2234%E3%80%8D-HNOI2002-%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[给定一个数列$a$，对于$a_i$，寻找一个$a_j$使得$i&gt;j$且$\vert a_i-a_j\vert$最小。 题解一道近乎Splay裸题的题。很显然可以将最小的$\vert a_i-a_j\vert$拆成$a_i$与其前驱的差和与其后继的差的最小值。所以说就可以用Splay维护啦qwq。论手贱，你是比不过我的，今天又把while打成if啦 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=4e4+51,inf=0x3f3f3f3f;ll cnt,num,res,prv,nxt;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;namespace Splay&#123; struct Node&#123; ll fa,val,size,temp; ll ch[2]; inline void reset(ll val=0,ll fa=0) &#123; this-&gt;fa=fa,this-&gt;val=val,this-&gt;temp=this-&gt;size=1; this-&gt;ch[0]=this-&gt;ch[1]=0; &#125; &#125;; struct Splay&#123; ll tot,root; Node nd[MAXN]; inline bool id(ll x) &#123; return nd[nd[x].fa].ch[1]==x; &#125; inline void update(ll x) &#123; nd[x].size=nd[nd[x].ch[0]].size+nd[nd[x].ch[1]].size+nd[x].temp; &#125; inline void connect(ll x,ll fa,ll dir) &#123; nd[x].fa=fa,nd[fa].ch[dir]=x; &#125; inline void rotate(ll x) &#123; ll fa=nd[x].fa,gfa=nd[fa].fa,dir=id(x); connect(x,gfa,id(fa)); connect(nd[x].ch[dir^1],fa,dir); connect(fa,x,dir^1); update(fa),update(x); &#125; inline void splay(ll cur,ll target) &#123; while(nd[cur].fa!=target) &#123; ll fa=nd[cur].fa,gfa=nd[fa].fa; if(gfa!=target) &#123; rotate(id(cur)^id(fa)?cur:fa); &#125; rotate(cur); &#125; if(!target) &#123; root=cur; &#125; &#125; inline void insert(ll val) &#123; ll cur=root,fa=0; while(cur&amp;&amp;nd[cur].val!=val) &#123; fa=cur,cur=nd[cur].ch[val&gt;nd[cur].val]; &#125; if(cur) &#123; nd[cur].temp++; &#125; else &#123; cur=++tot; if(fa) &#123; nd[fa].ch[val&gt;nd[fa].val]=cur; &#125; nd[cur].reset(val,fa); &#125; splay(cur,0); &#125; inline void find(ll val) &#123; ll cur=root; if(!cur) &#123; return; &#125; while(nd[cur].ch[val&gt;nd[cur].val]&amp;&amp;val!=nd[cur].val) &#123; cur=nd[cur].ch[val&gt;nd[cur].val]; &#125; splay(cur,0); &#125; inline ll prev(ll val) &#123; find(val); ll cur=root; if(nd[cur].val&lt;=val) &#123; return nd[cur].val; &#125; cur=nd[cur].ch[0]; while(nd[cur].ch[1]) &#123; cur=nd[cur].ch[1]; &#125; return nd[cur].val; &#125; inline ll next(ll val) &#123; find(val); ll cur=root; if(nd[cur].val&gt;=val) &#123; return nd[cur].val; &#125; cur=nd[cur].ch[1]; while(nd[cur].ch[0]) &#123; cur=nd[cur].ch[0]; &#125; return nd[cur].val; &#125; &#125;;&#125;Splay::Splay splay;int main()&#123; cnt=read(); splay.insert(inf),splay.insert(-inf); splay.insert(res=read()); for(register int i=1;i&lt;cnt;i++) &#123; num=read(); prv=splay.prev(num),nxt=splay.next(num); res+=min(num-prv,nxt-num); splay.insert(num); &#125; printf("%d",res);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
        <tag>各省省选</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·平衡树]]></title>
    <url>%2F2018%2F12%2F01%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡树是一种使用较为广泛的数据结构，代码比较长。 SplaySplay最主要的一点是它能反转区间，而Treap以及替罪羊不能，这也是为什么它作为Link Cut Tree的辅助树。 框架首先需要写一个这样的程序框架：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define DEBUG printf("In function %s, line %d\n",__FUNCTION__,__LINE__)using namespace std;typedef int ll;const ll MAXN=2e5+51;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;ll cnt,qcnt,l,r;namespace Splay&#123; struct Node&#123; ll fa,val,size,tag; ll ch[2]; &#125;; struct Splay&#123; ll tot,root; Node nd[MAXN]; //Code goes here &#125;;&#125; 以下代码片段全部接在注释处。 基本操作首先是$update$，用于更新节点的$size$。既然写过线段树，那么这个操作应该不难。1234inline void update(ll x)&#123;nd[x].size=nd[nd[x].ch[0]].size+nd[nd[x].ch[1]].size+1;&#125; 接下来是$id$，用于判断一个节点是它的父亲的哪一个孩子。这个很简单，只需要几行代码。1234inline bool id(ll x)&#123; return nd[nd[x].fa].ch[1]==x;&#125; 下一个是$connect$，用于建立新的父子关系，这个也不难。1234inline void connect(ll x,ll fa,ll dir)&#123; nd[x].fa=fa,nd[fa].ch[dir]=x;&#125; 关键操作以下两个操作是旋转操作，很关键，而且不好调。首先是$rotate$，用于平衡旋转。举个栗子，这是原来的平衡树。其中蓝色指向父亲，红色指向儿子。调用$rotate(y)$之后，平衡树就变成这个样子了：由于之前$connect$的实现，这个就变得不难了，因为旋转依次要改变$3$对父子关系。第一对，对照第二幅图可以发现，可以直接在$y$与$R$建立关系，就像这样第二对，在$B$与$x$之间建立父子关系，然后就变成了这个最后，在$x$与$y$建立父子关系就大功告成啦qwq。所以，上代码12345678inline void rotate(ll x)&#123; ll fa=nd[x].fa,gfa=nd[fa].fa,dir=id(x); connect(x,gfa,id(fa)); connect(nd[x].ch[dir^1],fa,dir); connect(fa,x,dir^1); update(fa),update(x);&#125; 还有一个是$splay$，这个尽管代码不长，但是很难调。我不推荐直接上旋，因为这样可能会很慢。12345678910111213141516inline void splay(ll cur,ll target)&#123; while(nd[cur].fa!=target) &#123; ll fa=nd[cur].fa,gfa=nd[fa].fa; if(gfa!=target) &#123; rotate(id(cur)^id(fa)?cur:fa); &#125; rotate(cur); &#125; if(!target) &#123; root=cur; &#125;&#125; 一些特例]]></content>
      <tags>
        <tag>平衡树</tag>
        <tag>Splay</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3391」【模板】文艺平衡树（Splay）]]></title>
    <url>%2F2018%2F11%2F30%2F%E3%80%8CLuogu-P3391%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88Splay%EF%BC%89%2F</url>
    <content type="text"><![CDATA[给一个$1$到$n$的排列，每一次能将区间$[l,r]$反转，求最后的排列 链接题解实测暴力能Rush\ 48pts，但是不能用暴力，只能老老实实写Splay。作为一道模板题，还是说一下我犯过的错误吧qwq。第一，$splay$函数中旋转完了一定要更新$fa$和$x$的信息，由于这个，我居然调了一下午+一晚上。第二，注意$reverse$中更新信息的语句，又调了一中午。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;#define DEBUG printf("In function %s, line %d\n",__FUNCTION__,__LINE__)using namespace std;typedef int ll;const ll MAXN=2e5+51;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;ll cnt,qcnt,l,r;namespace Splay&#123; struct Node&#123; ll fa,val,size,tag; ll ch[2]; inline void reset(ll val=0,ll fa=0) &#123; this-&gt;fa=fa,this-&gt;val=val,this-&gt;size=1; this-&gt;tag=this-&gt;ch[0]=this-&gt;ch[1]=0; &#125; &#125;; struct Splay&#123; ll tot,root; Node nd[MAXN]; inline bool id(ll x) &#123; return nd[nd[x].fa].ch[1]==x; &#125; inline void update(ll x) &#123; nd[x].size=nd[nd[x].ch[0]].size+nd[nd[x].ch[1]].size+1; &#125; inline void spread(ll x) &#123; if(nd[x].tag) &#123; nd[nd[x].ch[0]].tag^=1,nd[nd[x].ch[1]].tag^=1; nd[x].tag=0; swap(nd[x].ch[0],nd[x].ch[1]); &#125; &#125; inline void connect(ll x,ll fa,ll dir) &#123; nd[x].fa=fa,nd[fa].ch[dir]=x; &#125; inline void rotate(ll x) &#123; ll fa=nd[x].fa,gfa=nd[fa].fa,dir=id(x); connect(x,gfa,id(fa)); connect(nd[x].ch[dir^1],fa,dir); connect(fa,x,dir^1); update(fa),update(x); &#125; inline void splay(ll cur,ll target) &#123; while(nd[cur].fa!=target) &#123; ll fa=nd[cur].fa,gfa=nd[fa].fa; if(gfa!=target) &#123; rotate(id(cur)^id(fa)?cur:fa); &#125; rotate(cur); &#125; if(!target) &#123; root=cur; &#125; &#125; inline void insert(ll val) &#123; ll cur=root,fa=0; while(cur) &#123; fa=cur,cur=nd[cur].ch[val&gt;nd[cur].val]; &#125; cur=++tot; if(fa) &#123; nd[fa].ch[val&gt;nd[fa].val]=cur; &#125; nd[cur].reset(val,fa); splay(cur,0); &#125; inline ll findVal(ll rk) &#123; ll cur=root; while(1) &#123; spread(cur); if(nd[nd[cur].ch[0]].size&gt;=rk) &#123; cur=nd[cur].ch[0]; &#125; else &#123; if(nd[nd[cur].ch[0]].size+1==rk) &#123; return cur; &#125; else &#123; rk-=nd[nd[cur].ch[0]].size+1,cur=nd[cur].ch[1]; &#125; &#125; &#125; &#125; inline void reverse(ll l,ll r) &#123; l=findVal(l),r=findVal(r+2); splay(l,0),splay(r,l); nd[nd[nd[root].ch[1]].ch[0]].tag^=1; &#125; inline void op(ll cur) &#123; spread(cur); if(nd[cur].ch[0]) &#123; op(nd[cur].ch[0]); &#125; if(nd[cur].val&gt;1&amp;&amp;nd[cur].val&lt;cnt+2) &#123; printf("%d ",nd[cur].val-1); &#125; if(nd[cur].ch[1]) &#123; op(nd[cur].ch[1]); &#125; &#125; &#125;;&#125;Splay::Splay splay;int main()&#123; cnt=read(),qcnt=read(); for(register int i=1;i&lt;=cnt+2;i++) &#123; splay.insert(i); &#125; for(register int i=0;i&lt;qcnt;i++) &#123; l=read(),r=read(); splay.reverse(l,r); &#125; splay.op(splay.root);&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>洛谷</tag>
        <tag>平衡树</tag>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SP1043」Can you answer these queries I]]></title>
    <url>%2F2018%2F11%2F29%2F%E3%80%8CSP1043%E3%80%8DCan-you-answer-these-queries-I%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3701」「伪模板」主席树]]></title>
    <url>%2F2018%2F11%2F29%2F%E3%80%8CLuogu-P3701%E3%80%8D%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[A和B有五种不同的人物，共$n$个，两人之间要比$m$场。A的的$i$个人物的寿命为$hpA_i$，B的为$hpB_i$。每一次A和B选出不同的人物进行PK，每一次PK使得两边人物的寿命$-1s$，当寿命为$0$时就不能比赛了，两个人之间只能比一场。同时，当J的寿命为$0$时，同一棵树上的YYY可以为他$+1s$。每个YYY只能给每个J续一次，最大化A能赢的场次的数目。 题解一个比较巧妙的网络流建模题。首先打出人物之间输赢的表，然后考虑从源点像A的第$i$个人物连边，容量为$hpA_i$，从B的第$i$个人物像汇点连边，容量为$hpB_i$。以上连边，如果第$i$个人是J，则将容量增加本方YYY的数量。对于A的第$i$个人能赢B的第$j$个人，就从A的第$i$个人向B的第$j$个人A的人连边，容量为$1$。跑一边最大流即可。下面分析为什么这样连边是对的。先不考虑续命，这个人物不能出战即找不到经过这个人物的增广路，而通过这个人物的增广路只能是从源点直接到这个人物再到后面或是前面找到的增广路到这个人物再到汇点。以上这句话很重要，请仔细理解。所以，当源点到这个人物或这个人物到汇点的边为零流边就找不到增广路了，即这个人没命了。所以从源点发出或到汇点连边是正确的。由于两个人之间只能比一场，而题目要求只求胜利场次数，所以中间的连边也是正确的。现在考虑续命。对于一个J，无论YYY是死是活，总能在它死的时候续命，对于每一个J都是一样。所以将从源点连到J的边或是J连到汇点的边的容量增加本方YYY的个数。至此，连边的正确性就已经说明清楚了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e5+51,inf=0x7fffffff;struct Edge&#123; ll to,prev,flow;&#125;;Edge ed[MAXN&lt;&lt;1];map&lt;string,ll&gt;mp;ll nc,ec,source,sink,tot=1,from,to,flow,maxFlow;ll cnt,ccnt,life,xx,yy;ll last[MAXN],depth[MAXN],inQueue[MAXN];ll win[5][5]=&#123; 0,0,0,1,1, 1,0,1,0,0, 1,0,0,1,0, 0,1,0,0,1, 0,1,1,0,0&#125;;string x[151],y[151];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to,ll flow)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; ed[tot].flow=flow; last[from]=tot; &#125;inline ll Min(ll x,ll y)&#123; return x&lt;y?x:y;&#125;inline bool bfs()&#123; queue&lt;ll&gt;q; ll top,to; memset(depth,0x3f,sizeof(depth)); depth[source]=0,q.push(source); while(!q.empty()) &#123; top=q.front(); q.pop(),inQueue[top]=0; for(register int i=last[top];i;i=ed[i].prev) &#123; to=ed[i].to; if(depth[to]&gt;depth[top]+1&amp;&amp;ed[i].flow) &#123; depth[to]=depth[top]+1; if(!inQueue[to]) &#123; q.push(to),inQueue[to]=1; &#125; &#125; &#125; &#125; if(depth[sink]!=0x3f3f3f3f) &#123; return 1; &#125; return 0;&#125;inline ll dfs(ll cur,ll flow)&#123; ll low; if(cur==sink) &#123; return flow; &#125; for(register int i=last[cur];i;i=ed[i].prev) &#123; if(ed[i].flow&amp;&amp;depth[ed[i].to]==depth[cur]+1) &#123; if(low=dfs(ed[i].to,Min(flow,ed[i].flow))) &#123; ed[i].flow-=low,ed[i^1].flow+=low; return low; &#125; &#125; &#125; return 0;&#125;inline ll Dinic()&#123; ll flow; while(bfs()) &#123; while(flow=dfs(source,inf)) &#123; maxFlow+=flow; &#125; &#125; return maxFlow;&#125;int main()&#123; cnt=read(),ccnt=read(); nc=sink=(cnt+1)&lt;&lt;1,source=1; mp["J"]=0,mp["E"]=1,mp["YYY"]=2,mp["HK"]=3,mp["W"]=4; for(register int i=1;i&lt;=cnt;i++) &#123; cin&gt;&gt;x[i]; xx+=(x[i]=="YYY"); &#125; for(register int i=1;i&lt;=cnt;i++) &#123; cin&gt;&gt;y[i]; yy+=(y[i]=="YYY"); &#125; for(register int i=2;i&lt;=cnt+1;i++) &#123; life=read(); addEdge(source,i,life+(x[i-1]=="J"?xx:0)),addEdge(i,source,0); &#125; for(register int i=2;i&lt;=cnt+1;i++) &#123; life=read(); addEdge(i+cnt,sink,life+(y[i-1]=="J"?yy:0)),addEdge(sink,i+cnt,0); &#125; for(register int i=1;i&lt;=cnt;i++) &#123; xx=mp[x[i]]; for(register int j=1;j&lt;=cnt;j++) &#123; yy=mp[y[j]]; if(win[xx][yy]) &#123; addEdge(i+1,j+1+cnt,1),addEdge(j+1+cnt,i+1,0); &#125; &#125; &#125; printf("%d",min(ccnt,Dinic()));&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 558E」A Simple Task]]></title>
    <url>%2F2018%2F11%2F24%2F%E3%80%8CCodeForces-558E%E3%80%8DA-Simple-Task%2F</url>
    <content type="text"><![CDATA[给定一个字符串，每次将一个子串排序，问最后的字符串是什么。 链接题解一个比较好的思维题。用线段树维护区间内$26$个字母的出现次数。对于排序，将区间内每个字母出现的次数查出来，然后一个一个遍历就好了。如果是升序就从小往大覆盖，反之从大往小覆盖就好了。时间复杂度$O(26n\log n)$这里常数不能省还有，最坑爹的一点是，线段树开$4\times 10^5$过不去，会RE #9，要开$8\times 10^5$…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e5+51;struct Occur&#123; ll num[28]; Occur() &#123; memset(this-&gt;num,0,sizeof(this-&gt;num)); &#125; inline bool operator !=(const ll &amp;rhs)const &#123; for(register int i=1;i&lt;=26;i++) &#123; if(num[i]!=rhs) &#123; return 1; &#125; &#125; return 0; &#125; inline void clear() &#123; memset(num,0,sizeof(num)); &#125;&#125;;struct SegmentTree&#123; ll l,r; Occur sum,cover;&#125;;SegmentTree tree[MAXN&lt;&lt;2];ll cnt,qcnt,l,r,x;char str[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline Occur operator +(Occur x,Occur y)&#123; Occur res; for(register int i=1;i&lt;=26;i++) &#123; res.num[i]=x.num[i]+y.num[i]; &#125; return res;&#125;inline Occur operator *(Occur x,ll y)&#123; Occur res; for(register int i=1;i&lt;=26;i++) &#123; res.num[i]=x.num[i]*y; &#125; return res;&#125;inline void update(ll node)&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum.num[str[l-1]-'a'+1]=1; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void spread(ll node)&#123; ll ls=node&lt;&lt;1,rs=ls|1; if(tree[node].cover!=0) &#123; tree[ls].sum=tree[node].cover*(tree[ls].r-tree[ls].l+1); tree[rs].sum=tree[node].cover*(tree[rs].r-tree[rs].l+1); tree[ls].cover=tree[node].cover; tree[rs].cover=tree[node].cover; tree[node].cover.clear(); &#125;&#125;inline void cover(ll l,ll r,Occur val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum=val*(tree[node].r-tree[node].l+1); tree[node].cover=val; return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; spread(node); if(l&lt;=mid) &#123; cover(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; cover(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline Occur query(ll l,ll r,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; Occur res; spread(node); if(l&lt;=mid) &#123; res=res+query(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; res=res+query(l,r,(node&lt;&lt;1)|1); &#125; return res;&#125;inline void sorts(ll l,ll r,ll cmp)&#123; ll cur=l; Occur val=query(l,r,1),curr; if(!cmp) &#123; for(register int i=1;i&lt;=26;i++) &#123; curr.num[i]=1,curr.num[i-1]=0; if(val.num[i]) &#123; cover(l,l+val.num[i]-1,curr,1); l=l+val.num[i]; &#125; &#125; &#125; else &#123; for(register int i=26;i;i--) &#123; curr.num[i]=1,curr.num[i+1]=0; if(val.num[i]) &#123; cover(l,l+val.num[i]-1,curr,1); l=l+val.num[i]; &#125; &#125; &#125;&#125;inline void spreadAll(ll node)&#123; spread(node); if(tree[node].l==tree[node].r) &#123; return; &#125; spreadAll(node&lt;&lt;1); spreadAll((node&lt;&lt;1)|1); update(node);&#125;inline void preorder(ll node)&#123; if(tree[node].l==tree[node].r) &#123; for(register int i=1;i&lt;=26;i++) &#123; if(tree[node].sum.num[i]) &#123; putchar((char)(i+'a'-1)); break; &#125; &#125; return; &#125; preorder(node&lt;&lt;1); preorder((node&lt;&lt;1)|1);&#125;int main()&#123; cnt=read(),qcnt=read(); scanf("%s",&amp;str); create(1,cnt,1); for(register int i=0;i&lt;qcnt;i++) &#123; l=read(),r=read(),x=read(); sorts(l,r,!x); &#125; spreadAll(1),preorder(1);&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 501D」Misha and Permutations Summation]]></title>
    <url>%2F2018%2F11%2F19%2F%E3%80%8CCodeForces-501D%E3%80%8DMisha-and-Permutations-Summation%2F</url>
    <content type="text"><![CDATA[设$P$是一个长度为$n$的排列，定义$\operatorname{ord}P$为$P$在所有排列中的名次。给定两个长度为$n$的排列$P_1,P_2$，求第$\operatorname{ord}P_1+\operatorname{ord}P_2 \bmod n!$小的排列。 前置技能康托展开这里讲从排列映射到数的过程，还是假设这个排列长度为$n$。对于第$i$次操作，统计这个数后面有多少个比它小的数，记为$a_i$那么答案是$\sum_{i=1}^{n}a_i(n-i)!$ 题解这一个题和UVa 11525很像，不会做的可以参考一下本蒟蒻的题解，做法就是用一颗权值线段树维护全局没被放进排列中的第$k$小，所以做这个题可以先把它转化为上面那个题。首先把两个排列映射到整数，这里要统计后面有多少个比第$i$个数$a_i$小的数。如果暴力找的话是$O(n^2)$的。但是，可以发现排列是由$0,1\cdots n-1$组成的，那么排列里比这个数小的数的个数就是这个数。这句话不是很好懂，但是很重要。因为排列里比这个数$x$小的只有$0,1\cdots x-1$，共有$x$个，所以有$x$个数比$x$小。所以可以显然推出后面比$a_i$小的数的个$=$总共比$a_i$小的数$-$在$a_i$前面比$a_i$小的数。而排在前面比$a_i$小的数可以用树状数组维护。用一个树状数组维护第$i$个数是否出现过。对于当前的数，统计$1$到当前数$-1$中的和，就是在这个数前面比它小的数。所以说，可以用$O(n\log n)$的时间复杂度把$a_{P_1,i}$和$a_{P_2,i}$（$a$指的是前置技能里的$a$数组）求出来，记$S_i=a_{P_1,i}+a_{P_2,i}$。接下来化简$S$，由于$(x+1)\cdot x!=(x+1)!$，于是可以用这个性质化简$S_i$，使得$0\leq S_i\leq n-i$。具体方法是，对于$S_i$，$S_{i+1}+=S_i \% n-i,S_i\%=n-i$就可以简化$S$数组了。最后我们就把问题转化为上面的那个题了，用那个题的方法做就可以了qwq。时间复杂度$O(n\log n)$，常数不大除了权值线段树，跑了$2270$ms，拿了最优解qwq。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e5+51;struct BIT&#123; ll size; ll num[MAXN]; inline ll lowbit(ll x) &#123; return x&amp;-x; &#125; inline void add(ll pos,ll val) &#123; for(;pos&lt;=size;pos+=lowbit(pos)) &#123; num[pos]+=val; &#125; &#125; inline ll queryPrefix(ll pos) &#123; ll res=0; for(;pos;pos-=lowbit(pos)) &#123; res+=num[pos]; &#125; return res; &#125;&#125;;struct SegmentTree&#123; ll l,r,size;&#125;;BIT bit,bit2;SegmentTree tree[MAXN&lt;&lt;2];ll cnt,num;ll perm[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll node)&#123; tree[node].size=tree[node&lt;&lt;1].size+tree[(node&lt;&lt;1)|1].size;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].size=1; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline ll findVal(ll rk,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].size=0; return tree[node].l; &#125; ll res=0; if(rk&lt;=tree[node&lt;&lt;1].size) &#123; res=findVal(rk,node&lt;&lt;1); &#125; else &#123; res=findVal(rk-tree[node&lt;&lt;1].size,(node&lt;&lt;1)|1); &#125; update(node); return res;&#125;int main()&#123; bit.size=bit2.size=cnt=read(); for(register int i=1;i&lt;=cnt;i++) &#123; num=read(); perm[i]=num-bit.queryPrefix(num),bit.add(num+1,1); &#125; for(register int i=1;i&lt;=cnt;i++) &#123; num=read(); perm[i]+=num-bit2.queryPrefix(num),bit2.add(num+1,1); &#125; for(register int i=cnt,j=0;i;i--,j++) &#123; perm[i-1]+=perm[i]/(j+1),perm[i]%=(j+1); &#125; create(1,cnt,1); for(register int i=1;i&lt;=cnt;i++) &#123; printf("%d ",findVal(perm[i]+1,1)-1); &#125; &#125;]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11525」Permutation]]></title>
    <url>%2F2018%2F11%2F18%2F%E3%80%8CUVa-11525%E3%80%8DPermutation%2F</url>
    <content type="text"><![CDATA[给定$n$个数$x_1,x_2\cdots x_n$，已知$S=\sum^{n}_{i=1}x_i(n-i)!$，求第$S$个排列 前置技能康托展开是一个比较常用的哈希技巧，可以将一个排列$a_1,a_2\cdots a_n$映射到一个整数$k$，这个整数$k$就是这个排列在所有排列中的名次。由于它是双射的，所以也可以从一个整数还原这个整数所对应的全排列。假定这个排列是由$n$个数组成的，那么有从一个整数$k$映射到第$k$小的排列的方法：将$k$写成$\sum^{n}_{i=1}x_i(n-i)!$的形式，其中对于任意$x_i$，有$0\leq x_i\leq i$。对于第$i$次操作，选择当前没有选过的第$x_i$大的数加入排列。进行第二步$n$次，所得的排列即为所求。 题解注意到，题目已经完成了第一步，所以只需要完成第二步就可以了。而数据范围$k\leq 5\times10^4$，所以要写一种高效的数据结构，支持区间第$k$小和删除一个数。这里用权值线段树实现，由于$1\leq x_i\leq n$（这里的变量都是值上面的题意而言的），所以不用离散化。于是查询变得很简单了，但删除呢？可以将这个数置为$0$，意思是被删除了。如果这个节点的值为$0$，那么整个子树都不复存在。这份代码还是跑的蛮快的，$60$ms。可还是没有最优解跑的快最后，此题卡输出格式，要像我这么写才能AC 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=5e4+51;struct SegmentTree&#123; ll l,r,size;&#125;;ll test,cnt,num;SegmentTree tree[MAXN&lt;&lt;2];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll node)&#123; tree[node].size=tree[node&lt;&lt;1].size+tree[(node&lt;&lt;1)|1].size;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].size=1; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125; inline ll findVal(ll rk,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].size=0; return tree[node].l; &#125; ll res; if(rk&lt;=tree[node&lt;&lt;1].size) &#123; res=findVal(rk,node&lt;&lt;1); &#125; else &#123; res=findVal(rk-tree[node&lt;&lt;1].size,(node&lt;&lt;1)|1); &#125; update(node); return res;&#125;int main()&#123; test=read(); for(register int i=0;i&lt;test;i++) &#123; cnt=read(); create(1,cnt,1); for(register int j=0;j&lt;cnt;j++) &#123; num=read()+1; printf("%d",findVal(num,1)); putchar(j==cnt-1?'\n':' '); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>组合数学</tag>
        <tag>UVa</tag>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11297」Census]]></title>
    <url>%2F2018%2F11%2F16%2F%E3%80%8CUVa-11297%E3%80%8DCensus%2F</url>
    <content type="text"><![CDATA[给定一个$n\times n$的矩阵，支持单点修改，查询子矩阵最大值和子矩阵最小值。 链接UVa 11297 题解经典的二维带修RMQ问题。一个暴力的思想是建$500$棵线段树，对于修改就在对应的线段树上修改，对于查询的时候就一行一行的查询，每一次把答案与之前的答案合并一下就好了qwq。这样子做的时间复杂度是$O(qn\log n)$，不会TLE，但是跑的极慢，在测的时候跑了$1070$ms，没有树套树跑的快…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=551;struct SegmentTree&#123; ll l,r,minn,maxn; &#125;;SegmentTree tree[MAXN][MAXN&lt;&lt;2];ll size,qcnt,lx,ly,rx,ry,x,y,val,minn,maxn;char ch;ll num[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll dim,ll node)&#123; tree[dim][node].maxn=max(tree[dim][node&lt;&lt;1].maxn,tree[dim][(node&lt;&lt;1)|1].maxn); tree[dim][node].minn=min(tree[dim][node&lt;&lt;1].minn,tree[dim][(node&lt;&lt;1)|1].minn);&#125;inline void create(ll dim,ll l,ll r,ll node)&#123; tree[dim][node].l=l,tree[dim][node].r=r; if(l==r) &#123; tree[dim][node].minn=tree[dim][node].maxn=num[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(dim,l,mid,node&lt;&lt;1); create(dim,mid+1,r,(node&lt;&lt;1)|1); update(dim,node);&#125;inline void changePoint(ll dim,ll pos,ll val,ll node)&#123; if(tree[dim][node].l==tree[dim][node].r) &#123; tree[dim][node].minn=tree[dim][node].maxn=val; return; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1; if(pos&lt;=mid) &#123; changePoint(dim,pos,val,node&lt;&lt;1); &#125; else &#123; changePoint(dim,pos,val,(node&lt;&lt;1)|1); &#125; update(dim,node);&#125;inline ll queryMax(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].maxn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0; if(l&lt;=mid) &#123; res=max(res,queryMax(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=max(res,queryMax(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;inline ll queryMin(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].minn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0x7fffffff; if(l&lt;=mid) &#123; res=min(res,queryMin(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=min(res,queryMin(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;int main()&#123; size=read(); for(register int i=1;i&lt;=size;i++) &#123; for(register int j=1;j&lt;=size;j++) &#123; num[j]=read(); &#125; create(i,1,size,1); &#125; qcnt=read(); for(register int i=0;i&lt;qcnt;i++) &#123; cin&gt;&gt;ch; if(ch=='q') &#123; lx=read(),ly=read(),rx=read(),ry=read(); maxn=0,minn=0x7fffffff; for(register int j=lx;j&lt;=rx;j++) &#123; maxn=max(maxn,queryMax(j,ly,ry,1)); minn=min(minn,queryMin(j,ly,ry,1)); &#125; printf("%d %d\n",maxn,minn); &#125; else &#123; x=read(),y=read(),val=read(); changePoint(x,y,val,1); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11992」Fast Matrix Operations]]></title>
    <url>%2F2018%2F11%2F15%2F%E3%80%8CUVa-11992%E3%80%8DFast-Matrix-Operations%2F</url>
    <content type="text"><![CDATA[给定一个$r\times c$矩阵，支持子矩阵加某一个值，子矩阵覆盖为某一个值，查询某个子矩阵的值。 链接一如既往放洛谷的链接……UVa 11992 题解一个暴力的想法是由于$r$不超过$20$，所以可以开$20$棵线段树，修改和覆盖就不难啦qwq。至于查询，可以处理这一行的时候合并这一行的答案和原来的答案就好了qwq。所以我查询了$3$次这个时间复杂度是$O(r\log c)$，绝对不会T掉的 代码代码略丑，$233$行…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=5e4+51;struct SegmentTree&#123; ll l,r,sum,maxn,minn,tag,cover;&#125;; SegmentTree tree[21][MAXN&lt;&lt;2];ll length,width,qcnt,lx,rx,ly,ry,op,val,sum,maxn,minn;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll dim,ll node)&#123; tree[dim][node].sum=tree[dim][node&lt;&lt;1].sum+tree[dim][(node&lt;&lt;1)|1].sum; tree[dim][node].maxn=max(tree[dim][node&lt;&lt;1].maxn,tree[dim][(node&lt;&lt;1)|1].maxn); tree[dim][node].minn=min(tree[dim][node&lt;&lt;1].minn,tree[dim][(node&lt;&lt;1)|1].minn);&#125;inline void create(ll dim,ll l,ll r,ll node)&#123; tree[dim][node].l=l,tree[dim][node].r=r,tree[dim][node].cover=-1; if(l==r) &#123; tree[dim][node].sum=tree[dim][node].maxn=tree[dim][node].minn=0; return; &#125; ll mid=(l+r)&gt;&gt;1; create(dim,l,mid,node&lt;&lt;1); create(dim,mid+1,r,(node&lt;&lt;1)|1); update(dim,node);&#125;inline void spread(ll dim,ll node)&#123; ll ls=node&lt;&lt;1,rs=ls|1; ll lx=(tree[dim][ls].r-tree[dim][ls].l+1); ll rx=(tree[dim][rs].r-tree[dim][rs].l+1); if(tree[dim][node].cover!=-1) &#123; tree[dim][ls].maxn=tree[dim][node].cover; tree[dim][rs].maxn=tree[dim][node].cover; tree[dim][ls].minn=tree[dim][node].cover; tree[dim][rs].minn=tree[dim][node].cover; tree[dim][ls].sum=tree[dim][node].cover*lx; tree[dim][rs].sum=tree[dim][node].cover*rx; tree[dim][ls].cover=tree[dim][rs].cover=tree[dim][node].cover; tree[dim][ls].tag=tree[dim][rs].tag=0; tree[dim][node].cover=-1; &#125; if(tree[dim][node].tag) &#123; tree[dim][ls].maxn+=tree[dim][node].tag; tree[dim][rs].maxn+=tree[dim][node].tag; tree[dim][ls].minn+=tree[dim][node].tag; tree[dim][rs].minn+=tree[dim][node].tag; tree[dim][ls].sum+=tree[dim][node].tag*lx; tree[dim][rs].sum+=tree[dim][node].tag*rx; tree[dim][ls].tag+=tree[dim][node].tag; tree[dim][rs].tag+=tree[dim][node].tag; tree[dim][node].tag=0; &#125; &#125;inline void add(ll dim,ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; tree[dim][node].sum+=(tree[dim][node].r-tree[dim][node].l+1)*val; tree[dim][node].maxn+=val,tree[dim][node].minn+=val; tree[dim][node].tag+=val; return; &#125; spread(dim,node); ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(dim,l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(dim,l,r,val,(node&lt;&lt;1)|1); &#125; update(dim,node);&#125;inline void cover(ll dim,ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; tree[dim][node].sum=(tree[dim][node].r-tree[dim][node].l+1)*val; tree[dim][node].maxn=tree[dim][node].minn=val; tree[dim][node].cover=val; tree[dim][node].tag=0; return; &#125; spread(dim,node); ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1; if(l&lt;=mid) &#123; cover(dim,l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; cover(dim,l,r,val,(node&lt;&lt;1)|1); &#125; update(dim,node);&#125;inline ll query(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].sum; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0; spread(dim,node); if(l&lt;=mid) &#123; res+=query(dim,l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; res+=query(dim,l,r,(node&lt;&lt;1)|1); &#125; return res;&#125;inline ll queryMax(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].maxn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0; spread(dim,node); if(l&lt;=mid) &#123; res=max(res,queryMax(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=max(res,queryMax(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;inline ll queryMin(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].minn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0x7fffffff; spread(dim,node); if(l&lt;=mid) &#123; res=min(res,queryMin(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=min(res,queryMin(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;inline void solve()&#123; width=read(),qcnt=read(); for(register int i=1;i&lt;=length;i++) &#123; create(i,1,width,1); &#125; for(register int i=1;i&lt;=qcnt;i++) &#123; op=read(),lx=read(),ly=read(),rx=read(),ry=read(); if(op==1) &#123; val=read(); for(register int j=lx;j&lt;=rx;j++) &#123; add(j,ly,ry,val,1); &#125; &#125; if(op==2) &#123; val=read(); for(register int j=lx;j&lt;=rx;j++) &#123; cover(j,ly,ry,val,1); &#125; &#125; if(op==3) &#123; sum=maxn=0,minn=0x7fffffff; for(register int j=lx;j&lt;=rx;j++) &#123; sum+=query(j,ly,ry,1); maxn=max(maxn,queryMax(j,ly,ry,1)); minn=min(minn,queryMin(j,ly,ry,1)); &#125; printf("%d %d %d\n",sum,minn,maxn); &#125; &#125;&#125;int main()&#123; while(scanf("%d",&amp;length)!=EOF) &#123; solve(); memset(tree,0,sizeof(tree)); &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018滚粗记]]></title>
    <url>%2F2018%2F11%2F15%2FNOIP2018%E6%BB%9A%E7%B2%97%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[NOIP要咕咕了…… Day 0上午写模板,lca,Heap+Dijkstra,k短路,网络流，好像背不下来……下午与全机房的大佬颓slay，咕咕咕…… Day 1Task 1 road开始：先写个线段树再说吧……后来:这……这不是积木大赛吗？我怎么一开始就写的线段树…… Task 2 money开始：一脸茫然的样子……后来：可以乱搞诶，消掉其他货币组成的货币，剩下的直接选，标记一下，$O(Tn25000)$应该不会TLE…… Task 3 track开始：应该是个二分答案……后来：觉得$m=1$可做，好像有$10$分啊，后面的骗一下分吧，今天要$100+100+10=210$滚粗了…… Day 2Task 1 travel开始：树上$60$分真好做，基环树？不会……后来：好像可以找环，断边乱搞……（事实上这是非正解，咕咕，但是可以过咕咕F的数据） Task 2 game开始：先爆搜，打个表再说……后来：为什么$3\times3$不对，搜出$144$，为什么……骗一点分吧 Task 3 defense开始：好像是个$dp$……后来：我擦！$ddp$？不会做，今天是不是要$76+33+0=109$滚粗…… Day $log(n)$洛谷成绩$100+100+25+76+55+0=356$滚粗…… Day $n$咕咕F的成绩再一次咕掉了，我的博客也要咕掉…… Day $n\log(n)$成绩？呵呵……技不如人，被吊打]]></content>
      <tags>
        <tag>游记/考试</tag>
        <tag>待修改</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2532」[AHOI2012]树屋阶梯]]></title>
    <url>%2F2018%2F11%2F10%2F%E3%80%8CLuogu-P2532%E3%80%8D-AHOI2012-%E6%A0%91%E5%B1%8B%E9%98%B6%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[引言NOIP rp++! 链接Luogu P2532 题解考虑$f_i$表示搭$i$层高的阶梯的方案数，$g_{i,j}$表示最左下角的钢材上面有$i$层高，右边有$j$层高的方案数，那么如图$f_n=\sum^{n-1}_{i=1}g_{i,j}$而$i+j=n$且$g_{i,j}=f_if_j$$\therefore f_n=\sum^{n-1}_{i=1}f_if_{n-i}$显然是卡特兰的递推式，所以就可以用卡特兰数求，但是要用高精度…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e4+51; struct BigInt&#123; ll digit; ll num[MAXN]; BigInt() &#123; memset(num,0,sizeof(num)); &#125; inline void operator =(ll x) &#123; while(x) &#123; num[digit++]=x%10000,x/=10000; &#125; &#125; inline void op() &#123; printf("%d",num[digit-1]); for(register int i=digit-2;i&gt;=0;i--) &#123; if(!num[i]) &#123; printf("0000"); continue; &#125; ll rest=3-(ll)(log10(num[i])); for(register int j=rest;j;j--) &#123; putchar('0'); &#125; printf("%d",num[i]); &#125; &#125; inline bool operator &gt;(const BigInt &amp;rhs)const &#123; if(digit!=rhs.digit) &#123; return digit&gt;rhs.digit; &#125; for(register int i=digit-1;i&gt;=0;i--) &#123; if(num[i]!=rhs.num[i]) &#123; return num[i]&gt;rhs.num[i]; &#125; &#125; return 0; &#125;&#125;; ll num;BigInt res;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline BigInt operator +(BigInt x,BigInt y)&#123; BigInt res; ll carry=0; res.digit=max(x.digit,y.digit)+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]+y.num[i]+carry; carry=res.num[i]/10000,res.num[i]%=10000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator *(BigInt x,ll y)&#123; BigInt res; ll carry=0; res.digit=x.digit+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]*y+carry; carry=res.num[i]/10000,res.num[i]%=10000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator /(BigInt x,ll y)&#123; BigInt res; ll cur=0; res.digit=x.digit; for(register int i=x.digit-1;i&gt;=0;i--) &#123; cur=cur*10000+x.num[i]; if(cur&gt;=y) &#123; res.num[i]=cur/y,cur%=y; &#125; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;int main()&#123; num=read(); res=1; for(register int i=1;i&lt;=2*num;i++) &#123; res=res*i; &#125; res=res/(num+1); for(register int i=1;i&lt;=num;i++) &#123; res=res/i/i; &#125; res.op();&#125;]]></content>
      <tags>
        <tag>高精</tag>
        <tag>数论</tag>
        <tag>卡特兰</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3939」数颜色]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%8CLuogu-P3939%E3%80%8D%E6%95%B0%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[给定一个序列，支持交换两个元素和询问区间$(l,r)$内等于这个值的位置的数量。 链接Luogu P3939 题解肯定有人学数据结构学傻了吧，我们机房有写cdq的，有写主席树的，跑的都很快亲测这份代码不吸氧比上面两份代码吸氧还快……评测结果用vector记录每一种颜色的兔子出现在从左到右的哪几个位置，对于每个询问，二分查找出当前右端点$r$的位置和左端点$l-1$的位置，两个值相减即得答案，但是要注意边界处理。对于交换，找到两个兔子的位置，直接进行交换即可，注意要把所有的信息都交换…… 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=3e5+51;vector&lt;ll&gt;rabbit[MAXN];ll cnt,ccnt,op,l,r,x,lx,rx,maxn;vector&lt;ll&gt;::iterator bg,ed;ll color[MAXN],ind[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;int main()&#123; cnt=read(),ccnt=read(); for(register int i=1;i&lt;=cnt;i++) &#123; color[i]=read(); rabbit[color[i]].push_back(i); ind[i]=rabbit[color[i]].size()-1; &#125; for(register int i=1;i&lt;=ccnt;i++) &#123; op=read(); if(op==1) &#123; l=read()-1,r=read(),x=read(); bg=rabbit[x].begin(); ed=rabbit[x].end(); if(bg==ed) &#123; puts("0"); continue; &#125; lx=lower_bound(bg,ed,l)-bg,rx=lower_bound(bg,ed,r)-bg; if(rabbit[x][lx]==l) &#123; lx++; &#125; if(rabbit[x][rx]==r) &#123; rx++; &#125; printf("%d\n",rx-lx); &#125; else &#123; x=read(); if(color[x]!=color[x+1]) &#123; rabbit[color[x]][ind[x]]=x+1; rabbit[color[x+1]][ind[x+1]]=x; swap(color[x],color[x+1]); swap(ind[x],ind[x+1]); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>模拟</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1337」[JSOI2004]平衡点 / 吊打XXX]]></title>
    <url>%2F2018%2F11%2F05%2F%E3%80%8CLuogu-P1337%E3%80%8D-JSOI2004-%E5%B9%B3%E8%A1%A1%E7%82%B9-%E5%90%8A%E6%89%93XXX%2F</url>
    <content type="text"><![CDATA[给定一些带权点，求它们的带权费马点。 链接Luogu P1337BZOJ 3680 题解这题备选的解很多，所以采用猜答案的方法模拟退火来做此题。注意下一些常数吧……我是不会告诉你我卡了7次的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e4+51;const double delta=0.997;struct Node&#123; double x,y,weight; &#125;;Node nd[MAXN];ll cnt;double resx,resy,res=1e18,t; inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll randInt()&#123; return 2*rand()-RAND_MAX;&#125; inline double potentialEnergy(double x,double y)&#123; double sum=0,xx,yy; for(register int i=0;i&lt;cnt;i++) &#123; xx=x-nd[i].x,yy=y-nd[i].y; sum+=sqrt(xx*xx+yy*yy)*nd[i].weight; &#125; return sum;&#125; inline void simulatedAnnealing()&#123; double x=resx,y=resy,rd,xx,yy,dt; t=19260; while(t&gt;1e-18) &#123; xx=resx+randInt()*t,yy=resy+randInt()*t; rd=potentialEnergy(xx,yy),dt=rd-res; if(dt&lt;0) &#123; x=xx,y=yy,resx=x,resy=y,res=rd; &#125; else &#123; if(exp(-dt/t)*RAND_MAX&gt;rand()) &#123; x=xx,y=yy; &#125; &#125; t*=delta; &#125;&#125;inline void SA(ll times)&#123; for(register int i=0;i&lt;times;i++) &#123; simulatedAnnealing(); &#125;&#125;int main()&#123; srand(time(0)); cnt=read(); for(register int i=0;i&lt;cnt;i++) &#123; nd[i].x=read(),nd[i].y=read(),nd[i].weight=read(); &#125; SA(9); printf("%.3lf %.3lf",resx,resy);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>JSOI</tag>
        <tag>随机化</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2197」【模板】nim游戏]]></title>
    <url>%2F2018%2F11%2F02%2F%E3%80%8CLuogu-P2197%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91nim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[有$n$堆石子，第$i$堆有$a_i$个，$Alice$和$Bob$轮流取石子，$Alice$先取。每个游戏者只能取一堆石子，至少取一个，问哪个游戏者会赢。 链接Luogu P2197 题解最基础的Nim游戏，先手必赢当且仅当$a_1 \operatorname{xor} a_2 \operatorname{xor} \cdots \operatorname{xor} a_n \not = 0$，代码很短。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;ll test,cnt,res;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll solve()&#123; cnt=read(); for(register int i=0;i&lt;cnt;i++) &#123; res^=read(); &#125; puts(res!=0?"Yes":"No"); res=0;&#125; int main()&#123; test=read(); while(test--) &#123; solve(); &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>博弈论</tag>
        <tag>Nim游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4438」[HNOI/AHOI2018]道路]]></title>
    <url>%2F2018%2F11%2F01%2F%E3%80%8CLuogu-P4438%E3%80%8D-HNOI-AHOI2018-%E9%81%93%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[给你一颗有$2n-1$个节点的树，这一棵树的非叶节点均有两个儿子，左儿子与它连红边，右儿子与它连绿边，定义节点$i$的不便利值为$c_i\cdot(a_i+x)\cdot(b_i+y)$其中$x$表示根节点到节点$i$的未加粗红边数量，$y$表示根节点到节点$i$的未加粗绿边数量。求加粗边数量为$n-1$的所有叶节点的不便利值。 链接Luogu P4438 题解一道比较好的树形dp题。将每一个城市标号$1$到$n-1$，乡村标号$n$到$2n-1$，设$dp[i][j][k]$表示标号后的$i$号节点到根节点要走过$j$条没有翻修的公路和$k$条没有翻修的铁路最小的不便利值。设$l[i]$指的是通过公路连接$i$号结点的城市或乡村，$r[i]$指的是通过铁路连接$i$号结点的城市或乡村，那么如果$i$是乡村，直接暴力算不便利值即可，即$dp[i][j][k]=c_i\cdot(a_i+j)\cdot(b_i+k)$如果$i$是城市，因为最多翻修$n-1$条路，所以考虑对通向每一个城市的公路或铁路进行翻修。翻修通往城市$i$的公路的不便利值是$dp[l_i][j+1][k]+dp[r_i[j][k]$（因为通向$i$的铁路没翻修），铁路同理，即$dp[i][j][k]=\min(dp[l_i][j+1][k]+dp[r_i[j][k],dp[l_i[j][k]+dp[r_i][j][k+1])$所以就得到了转移方程。最后善意的提醒一句，本题卡空间，大佬们可以将$dp$的一维改成$dfn$，蒟蒻不会，只能暴力 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=4e4+51;ll cnt;ll l[MAXN],r[MAXN],lx[MAXN],rx[MAXN];ll x[MAXN],y[MAXN],z[MAXN];ll dp[MAXN][41][41];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void dfs(ll node)&#123; if(node&gt;=cnt) &#123; return; &#125; lx[l[node]]=lx[node]+1,lx[r[node]]=lx[node]; rx[r[node]]=rx[node]+1,rx[l[node]]=rx[node]; dfs(l[node]); dfs(r[node]);&#125;inline void ddp(ll node)&#123; ll lc,rc; if(node&gt;=cnt) &#123; for(register int i=0;i&lt;=lx[node];i++) &#123; for(register int j=0;j&lt;=rx[node];j++) &#123; dp[node][i][j]=1ll*(x[node]+i)*(y[node]+j)*z[node]; &#125; &#125; return; &#125; else &#123; ddp(l[node]); ddp(r[node]); for(register int i=0;i&lt;=lx[node];i++) &#123; for(register int j=0;j&lt;=rx[node];j++) &#123; lc=dp[l[node]][i][j]+dp[r[node]][i][j+1]; rc=dp[r[node]][i][j]+dp[l[node]][i+1][j]; dp[node][i][j]=min(lc,rc); &#125; &#125; &#125;&#125;int main()&#123; cnt=read(); for(register int i=1;i&lt;cnt;i++) &#123; l[i]=read(),r[i]=read(); l[i]=l[i]&lt;0?-l[i]+cnt-1:l[i],r[i]=r[i]&lt;0?-r[i]+cnt-1:r[i]; &#125; for(register int i=1;i&lt;=cnt;i++) &#123; x[i+cnt-1]=read(),y[i+cnt-1]=read(),z[i+cnt-1]=read(); &#125; dfs(1),ddp(1); printf("%lld",dp[1][0][0]);&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>洛谷</tag>
        <tag>各省省选</tag>
        <tag>HNOI</tag>
        <tag>树形DP</tag>
        <tag>AHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 2713」Can you answer these queries IV]]></title>
    <url>%2F2018%2F10%2F28%2F%E3%80%8CSPOJ-2713%E3%80%8DCan-you-answer-these-queries-IV%2F</url>
    <content type="text"><![CDATA[给一段正整数构成的区间，支持区间开平方以及询问区间和。 链接SPOJ 2713 题解考虑线段树，显然区间开平方是不能用lazy\ tag的，所以我们选择暴力修改。先证明一个引理，区间最大值为1的区间进行修改是没有意义的。（这个证明算是补了一个坑）证明：由于区间内所有数是正整数，所以区间最大值为1的区间内所有数均为1，而\sqrt{1}=1，故修改区间内的值没有意义，证毕。于是我们考虑在修改区间时判断一下当前区间最大值是不是1，如果是，就没有修改的必要。如果这个节点的左右端点重合，直接修改即可，这样可以少修改许多修改了也没用的区间，至于查询还是一样的。提醒大家有多组数据，记得初始化 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=1e5+51;struct SegmentTree&#123; ll l,r,sum,maxn;&#125;;SegmentTree tree[MAXN&lt;&lt;2];ll cnt,qcnt,op,l,r,ccnt;ll num[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll node)&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum; tree[node].maxn=max(tree[node&lt;&lt;1].maxn,tree[(node&lt;&lt;1)|1].maxn);&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=tree[node].maxn=num[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void change(ll l,ll r,ll node)&#123; if(tree[node].maxn&lt;=1) &#123; return; &#125; if(tree[node].l==tree[node].r) &#123; tree[node].sum=tree[node].maxn=sqrt(tree[node].sum); return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; change(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; change(l,r,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll querySum(ll l,ll r,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,res=0; if(l&lt;=mid) &#123; res+=querySum(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; res+=querySum(l,r,(node&lt;&lt;1)|1); &#125; return res;&#125;inline ll queryMax(ll l,ll r,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].maxn; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,res=0; if(l&lt;=mid) &#123; res=max(res,queryMax(l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=max(res,queryMax(l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;int main()&#123; while(scanf("%lld",&amp;cnt)!=EOF) &#123; printf("Case #%lld:\n",++ccnt); for(register int i=1;i&lt;=cnt;i++) &#123; num[i]=read(); &#125; create(1,cnt,1); qcnt=read(); for(register int i=0;i&lt;qcnt;i++) &#123; op=read(),l=read(),r=read(); if(l&gt;r) &#123; swap(l,r); &#125; if(op) &#123; printf("%lld\n",querySum(l,r,1)); &#125; else &#123; if(queryMax(l,r,1)&gt;1) &#123; change(l,r,1); &#125; &#125; &#125; memset(num,0,sizeof(num)); memset(tree,0,sizeof(tree)); puts(""); &#125;&#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2742」【模板】二维凸包]]></title>
    <url>%2F2018%2F10%2F21%2F%E3%80%8CLuogu-P2742%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[给定一个点集，求它的凸包的周长。 链接Luogu P2742 题解二维凸包的模板题，没有什么好说的。不会凸包的右转这里但是最后求周长是一定要算点的距离，而不是向量的长度。被卡了两次 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef double db;const ll MAXN=1e4+51;struct Point&#123; db x,y; Point(ll x=0,ll y=0) &#123; this-&gt;x=x,this-&gt;y=y; &#125; inline bool operator &lt;(const Point &amp;rhs)const &#123; return y==rhs.y?x&lt;rhs.x:y&lt;rhs.y; &#125; inline db polar() &#123; return atan2(y,x); &#125;&#125;;typedef Point Vector;Point p[MAXN];ll cnt,minn;db res;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline Vector operator +(Vector x,Vector y)&#123; return Vector(x.x+y.x,x.y+y.y);&#125;inline Vector operator -(Vector x,Vector y)&#123; return Vector(x.x-y.x,x.y-y.y);&#125;inline Vector operator *(Vector x,db y)&#123; return Vector(x.x*y,x.y*y);&#125;inline Vector operator /(Vector x,db y)&#123; return Vector(x.x/y,x.y/y);&#125;inline db dot(Vector x,Vector y)&#123; return x.x*y.x+x.y*y.y;&#125;inline db length(Vector x)&#123; return sqrt(dot(x,x));&#125;inline db angle(Vector x,Vector y)&#123; return acos(dot(x,y)/length(x)/length(y));&#125;inline db cross(Vector x,Vector y)&#123; return x.x*y.y-x.y*y.x;&#125;inline db dist(Vector x,Vector y)&#123; db xx=x.x-y.x,yy=x.y-y.y; return sqrt(xx*xx+yy*yy);&#125;inline bool cmp(Point x,Point y)&#123; double xx=cross(x-p[1],y-p[1]); if(xx&gt;0) &#123; return 1; &#125; if(!xx&amp;&amp;length(x-p[1])&lt;length(y-p[1])) &#123; return 1; &#125; return 0;&#125;inline deque&lt;Point&gt; convexHull(Point *p,ll size)&#123; Point top; deque&lt;Point&gt;vec; if(size==1) &#123; vec.push_back(p[1]); return vec; &#125; if(size==2) &#123; vec.push_back(p[1]),vec.push_back(p[2]); return vec; &#125; vec.push_back(p[1]),vec.push_back(p[2]); for(register int i=3;i&lt;=size;i++) &#123; top=vec.back(); while(cross(top-vec[vec.size()-2],p[i]-top)&lt;0) &#123; vec.pop_back(),top=vec.back(); &#125; vec.push_back(p[i]); &#125; return vec;&#125;int main()&#123; cnt=read(); p[0].x=p[0].y=100000000000.0; if(cnt==0) &#123; printf("0.00"); return 0; &#125; for(register int i=1;i&lt;=cnt;i++) &#123; scanf("%lf%lf",&amp;p[i].x,&amp;p[i].y); if(p[i]&lt;p[minn]) &#123; minn=i; &#125; &#125; swap(p[minn],p[1]),sort(p+2,p+cnt+1,cmp); deque&lt;Point&gt;pt=convexHull(p,cnt); if(pt.size()==1) &#123; printf("%.2lf",0.0); &#125; else &#123; for(register int i=1;i&lt;pt.size();i++) &#123; res+=dist(pt[i],pt[i-1]); &#125; res+=dist(pt[0],pt[pt.size()-1]); printf("%.2lf",res); &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>二维凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·二维凸包]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[二维凸包是指一个面积最小的凸多边形，使得一个给定的点集都分布在这个凸多边形的内部或者边上。 前置技能计算几何基础，这个大概不用说了。 过程咕咕咕，这里我们使用比较好想的Graham算法进行求解。前方大图警告。首先呢，是一个点集。因为y坐标最小的点肯定在这个凸包上，所以我们先找出y坐标最小的点,记为P_1。接着考虑把剩下的点对于P_1从右往左编号。PS:截图的锅，P_{11}上面那个点是P_{12}。预处理完毕，接下来我们需要一个栈。由于P_1和P_2在凸包边界上，考虑将P_1和P_2入栈。未完成的凸包用红色线条表示。考虑P_3，加入它之后红色边界仍然是凸的，P_3入栈。接下来考虑P_4，加入它之后边界是凹的，把当前栈顶P_3出栈。考虑加入P_4当前红色边界加入P_4仍然是凸的，所以P_4入栈。由于连续加入P_5，P_6，P_7后所得的红色边界仍然是凸的，所以将它们依次入栈。在考虑P_8时，发现边界是凹的，将栈顶P_7出栈，而P_8入栈。考虑P_9。在连续出栈P_8和P_6都不能满足红色边界为凸的，所以一出栈，将P_9入栈。依次进行以下操作，可以得到一个处理到最后一个点的图像，然后就完结撒花了！所以说，code呢？对不起，没有个鬼。出门右转看代码]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>二维凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 1060C」Maximum Subrectangle]]></title>
    <url>%2F2018%2F10%2F15%2F%E3%80%8CCodeForces-1060C%E3%80%8DMaximum-Subrectangle%2F</url>
    <content type="text"><![CDATA[给一个数x，序列a和另一个序列b，构造一个矩阵c使得c_{i,j}=a_{i}\times b_{j}。在矩阵中找出一个最大的矩形使得矩形内所有数的和小于x。因为要求子矩阵的和，所以考虑二维前缀和。但是由于矩阵的特殊性质c_{i,j}=a_{i}\times b_{j}，所以可以将二维前缀和转化为两个一维前缀和的乘积。]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>前缀和</tag>
        <tag>贪心</tag>
        <tag>two pointers</tag>
        <tag>数据结构</tag>
        <tag>未完待续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4315」月下“毛景树”]]></title>
    <url>%2F2018%2F10%2F15%2F%E3%80%8CLuogu-P4315%E3%80%8D%E6%9C%88%E4%B8%8B%E6%AF%9B%E6%99%AF%E6%A0%91%2F</url>
    <content type="text"><![CDATA[给一棵树，支持修改边上的权值，将两点间路经全部增加k或全部覆盖为k，多次求当前树上两点间路径上的边权最大值。 链接Luogu P4315 题解我不会告诉你这道毒瘤题我调了两个月吐槽一下毒瘤出题人，这份代码我足足写了297行，无语……好吧当时交题的时候并没有把求lca删掉此题一眼看过去是树剖+边权下放，把边权下放之后就是普通的树剖。这里还有个奇淫技巧，就是在最后修改与查询时，为了不统计LCA，将id[x]改成id[x]+1，具体看注释。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,maxn,tag,cover;&#125;;const ll MAXN=2e5+51; edge ed[MAXN];SegmentTree tree[MAXN&lt;&lt;2];ll last[MAXN],val[MAXN],depth[MAXN],fa[MAXN],size[MAXN],heavy[MAXN];ll id[MAXN],pre[MAXN],top[MAXN],from[MAXN],to[MAXN],dist[MAXN];ll tot,nc,ccnt,tx,x,y,z;string op;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;inline void update(ll node)&#123; tree[node].maxn=max(tree[node&lt;&lt;1].maxn,tree[(node&lt;&lt;1)|1].maxn);&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r,tree[node].cover=-1; if(l==r) &#123; tree[node].maxn=val[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void spread(ll node)&#123; if(tree[node].cover!=-1) &#123; tree[node&lt;&lt;1].maxn=tree[node].cover; tree[(node&lt;&lt;1)|1].maxn=tree[node].cover; tree[node&lt;&lt;1].cover=tree[node].cover; tree[(node&lt;&lt;1)|1].cover=tree[node].cover; tree[node&lt;&lt;1].tag=tree[(node&lt;&lt;1)|1].tag=0; tree[node].cover=-1; &#125; if(tree[node].tag) &#123; tree[node&lt;&lt;1].maxn+=tree[node].tag; tree[(node&lt;&lt;1)|1].maxn+=tree[node].tag; tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; tree[node].tag=0; &#125;&#125;inline void change(ll pos,ll val,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].maxn=val; return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; spread(node); if(pos&lt;=mid) &#123; change(pos,val,node&lt;&lt;1); &#125; else &#123; change(pos,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline void cover(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].maxn=val; tree[node].cover=val; tree[node].tag=0; return; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; cover(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; cover(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].maxn+=val; tree[node].tag+=val; return; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll queryMax(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].maxn; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=-(1&lt;&lt;30); if(l&lt;=mid) &#123; val=max(val,queryMax(l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; val=max(val,queryMax(l,r,(node&lt;&lt;1)|1)); &#125; return val;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1; ll maxn=-1; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f) &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to]; if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to]; &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link; if(!heavy[node]) &#123; return; &#125; ddfs(heavy[node],link); for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to); &#125; &#125;&#125;inline ll queryPathMax(ll x,ll y)&#123; ll ans=-(1&lt;&lt;30); while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans=max(ans,queryMax(id[top[x]],id[x],1)); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans=max(ans,queryMax(id[x]+1,id[y],1));// return ans;&#125;inline void changePoint(ll x,ll y)&#123; change(id[x],y,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x]+1,id[y],val,1);//&#125;inline void coverPath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; cover(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; cover(id[x]+1,id[y],val,1);//&#125;int main()&#123; nc=read(); for(register int i=0;i&lt;nc-1;i++) &#123; from[i]=read(),to[i]=read(),dist[i]=read(); addEdge(from[i],to[i]),addEdge(to[i],from[i]); &#125; dfs(1,0,1),ddfs(1,1),create(1,nc,1); for(register int i=0;i&lt;nc-1;i++) &#123; changePoint(depth[from[i]]&gt;depth[to[i]]?from[i]:to[i],dist[i]); &#125; while(cin&gt;&gt;op,op!="Stop") &#123; if(op=="Max") &#123; x=read(),y=read(); cout&lt;&lt;queryPathMax(x,y)&lt;&lt;endl; &#125; if(op=="Change") &#123; x=read(),y=read(); tx=depth[from[x-1]]&gt;depth[to[x-1]]?from[x-1]:to[x-1]; changePoint(tx,y); &#125; if(op=="Add") &#123; x=read(),y=read(),z=read(); changePath(x,y,z); &#125; if(op=="Cover") &#123; x=read(),y=read(),z=read(); coverPath(x,y,z); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018之前的琐记]]></title>
    <url>%2F2018%2F10%2F09%2FNOIP2018%E4%B9%8B%E5%89%8D%E7%9A%84%E7%90%90%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[既然$\texttt{Karry5307}$已经变成了初二的小蒟蒻了，那么还是写点$\texttt{NOIP2018}$之前的琐记吧。 考试2018.10.8：出题人xzy，毒瘤题。T1什么鬼，7合1，gg。T3辣鸡模拟，让你算空间，最后交卷时发现bitset没开long\ long，写了个快速乘\% 998244353，读入出锅了，居然没看到有个空格没搞好，0+0+10=10分滚粗。（我不会告诉你我是因为没看大样例而导致的） 2018.10.9：出题人Despair，毒瘤题。第一题什么鬼，yyb大佬说是迭代，结果还真的是迭代（顺便吐槽一句，题解写的矩乘看都没看懂）T3随手开了个10^7的数组，MLE了。 2018.10.10：出题人Tyher，这次我觉得海星。T1被卡精度原地爆炸，log_{10}改成log_2就会有35分的好成绩啦，T3良心，Task\ 4特判了一下，其余线段树乱搞还有40分，拿了20+40+25=85分滚粗，yyb大佬太强了，又阿克了。 2018.10.11：T1毒瘤三合一，布星啊，墙裂谴责，乱搞还没分，幸好T2乱搞有20分。T3全场切except\ me，告辞告辞，0+20+0=20滚粗。 2018.10.12：出题人DarkFire，题目海星，只是我太蒟蒻了，连T2都没切。Despair大佬又阿克了，%%%，我这个小蒟蒻继续0+20+0=20滚粗。 2018.10.13：上午初赛模拟，什么鬼，一个排完序后的水题硬是考递归，体验极差。(最近有点懒，没更) 2018.10.26：T1不会莫比乌斯反演，被吊打，只好拿20分滚粗。T2不会写，跳过。T3居然还下放了一个game，什么鬼，最后才知道这game考有限状态自动机，我太蒻了，居然没玩通关，苟且21分。总共20+0+21=41分滚粗。tbr大佬玩个游戏T3都拿了66分，我竟无言以对。我突然觉得我连游戏都不会玩了]]></content>
      <tags>
        <tag>游记/考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4884」多少个1？]]></title>
    <url>%2F2018%2F10%2F07%2F%E3%80%8CLuogu-P4884%E3%80%8D%E5%A4%9A%E5%B0%91%E4%B8%AA1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[给定p和模数yyb，保证yyb为质数，求最小的x使得$111\cdots 1$(x个)\equiv 1\pmod {yyb} 链接Luogu P4884 题解注意到111\cdots 1(x个)=\cfrac{10^x-1}{9},则 111\cdots 1\equiv (10^x-1)\times 9^{-1}\therefore (10^x-1)\times 9^{-1}\equiv yyb\therefore 10^x \equiv 9\times yyb+1然后这个方程就化为BSGS的标准形式了，由于模数yyb为质数，直接利用BSGS即可。由于yyb会很大，所以再次建议不要用自己写的哈希表，而使用map。我是不会告诉你我因为这个原因被洛谷的数据坑了好几次了 代码为了保险，这里开了int128，美中不足的是要自己写读写，顺便写了一个O(1)的龟速乘。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef __int128 ll;map&lt;ll,ll&gt;ht;ll mod,val;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void write(ll num)&#123; if(num&gt;9) &#123; write(num/10); &#125; putchar(num%10+'0');&#125;inline ll qmul(ll x,ll y,ll mod)&#123; ll l=(y&gt;&gt;25)*x%mod*((1&lt;&lt;25)%mod),r=(y&amp;((1&lt;&lt;25)-1))*x%mod; return (l+r)%mod;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; if(!exponent) &#123; return 1; &#125; ll temp=qpow(base,exponent&gt;&gt;1,mod); ll res=qmul(temp,temp,mod); if(exponent&amp;1) &#123; res=qmul(res,base,mod); &#125; return res;&#125;inline ll BSGS(ll base,ll res,ll mod)&#123; ht.clear(),res%=mod; ll temp,val,fail; temp=sqrt((long double)(mod))+1; for(register int i=0;i&lt;temp;i++) &#123; val=qmul(res,qpow(base,i,mod),mod); ht[val]=i; &#125; base=qpow(base,temp,mod); if(!base) &#123; return !res?1:-1; &#125; for(register int i=0;i&lt;=temp;i++) &#123; val=qpow(base,i,mod),fail=ht.find(val)==ht.end()?-1:ht[val]; if(fail&gt;=0&amp;&amp;i*temp-fail&gt;=0) &#123; return i*temp-fail; &#125; &#125; return -1;&#125;int main()&#123; val=read(),mod=read(); val=(qmul(9,val,mod)+1)%mod; write(BSGS(10,val,mod));&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>数论</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2756」飞行员配对方案问题]]></title>
    <url>%2F2018%2F09%2F24%2F%E3%80%8CLuogu-P2756%E3%80%8D%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这个题是网络流24题中的第1题。给一个二分图，求最大匹配以及匹配方案。 链接Luogu P2756 题解这个题目的模型是二分图最大匹配，有多个源点和汇点。所以可以增加一个超级源点和一个超级汇点。超级源点1与2-(m+1)连流量为1的边；(m+2)-(n+1)与超级汇点n+2连流量为1的边；所给的边全部连流量为1的边。最后，这个网络的最大流即为二分图的最大匹配。对于每一条在二分图内的边，即它和它的反向边不连向源点和汇点，如果反向边有流量，就输出这条边连向的两个点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e5+51,inf=0x7fffffff;struct Edge&#123; ll to,prev,flow;&#125;;Edge ed[MAXN&lt;&lt;1];ll l,nc,source,sink,tot=1,from,to,flow,maxFlow;ll last[MAXN],depth[MAXN],inQueue[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to,ll flow)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; ed[tot].flow=flow; last[from]=tot; &#125;inline ll Min(ll x,ll y)&#123; return x&lt;y?x:y;&#125;inline bool bfs()&#123; queue&lt;ll&gt;q; ll top,to; memset(depth,0x3f,sizeof(depth)); depth[source]=0,q.push(source); while(!q.empty()) &#123; top=q.front(); q.pop(),inQueue[top]=0; for(register int i=last[top];i;i=ed[i].prev) &#123; to=ed[i].to; if(depth[to]&gt;depth[top]+1&amp;&amp;ed[i].flow) &#123; depth[to]=depth[top]+1; if(!inQueue[to]) &#123; q.push(to),inQueue[to]=1; &#125; &#125; &#125; &#125; if(depth[sink]!=0x3f3f3f3f) &#123; return 1; &#125; return 0;&#125;inline ll dfs(ll cur,ll flow)&#123; ll low; if(cur==sink) &#123; return flow; &#125; for(register int i=last[cur];i;i=ed[i].prev) &#123; if(ed[i].flow&amp;&amp;depth[ed[i].to]==depth[cur]+1) &#123; if(low=dfs(ed[i].to,Min(flow,ed[i].flow))) &#123; ed[i].flow-=low,ed[i^1].flow+=low; return low; &#125; &#125; &#125; return 0;&#125;inline ll Dinic()&#123; ll flow; while(bfs()) &#123; while(flow=dfs(source,inf)) &#123; maxFlow+=flow; &#125; &#125; return maxFlow;&#125;int main()&#123; l=read(),nc=read(),source=1,sink=nc+2; while(1) &#123; from=read()+1,to=read()+1; if(!from||!to) &#123; break; &#125; addEdge(from,to,1),addEdge(to,from,0); &#125; for(register int i=2;i&lt;=l+1;i++) &#123; addEdge(source,i,1),addEdge(i,source,0); &#125; for(register int i=l+2;i&lt;=nc+1;i++) &#123; addEdge(i,sink,1),addEdge(sink,i,0); &#125; if(Dinic()==0) &#123; puts("No solution!"); &#125; else &#123; printf("%d\n",maxFlow); for(register int i=2;i&lt;=tot;i+=2) &#123; if(ed[i].to!=source&amp;&amp;ed[i^1].to!=source&amp;&amp;ed[i].to!=sink&amp;&amp;ed[i^1].to!=sink) &#123; if(ed[i^1].flow) &#123; printf("%d %d\n",ed[i^1].to-1,ed[i].to-1); &#125; &#125; &#125; &#125; &#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>二分图匹配</tag>
        <tag>Dinic</tag>
        <tag>网络流24题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3376」【模板】网络最大流]]></title>
    <url>%2F2018%2F09%2F24%2F%E3%80%8CLuogu-P3376%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"></content>
      <tags>
        <tag>未完待续</tag>
        <tag>洛谷</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·网络流]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[网络流是一种解决各种神仙问题的算法，通过合理地建图，可以解决各类神仙问题。网络流的概念也许会有点难懂，于是就先上几幅图，借助水流理解。众所周知，你家的水是从自来水厂通过管道流过来的，假设s是自来水厂，t是你家，1,2,3是中转节点，管道连接如图所示。每条边上的边权是该管道允许的最大流量，即容量，如果流进来的水流流量超过容量，管道就会炸掉，这既不是自来水厂所期望的事，也不是你家所期望的事。现在，你希望自来水厂到你家的水最多，所以尝试找出一条s-&gt;t路径，比如这个对于这条路径，可以通过的可行流为10，所以将这些边的可行流-10，像这样：对于这个网络，一次一次找s-&gt;t路径是可以得到最大流的，但对于别的网络呢？流错了怎么办？这里给一个神仙技巧——加反向边，像这样]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3950」部落冲突]]></title>
    <url>%2F2018%2F09%2F14%2F%E3%80%8CLuogu-P3950%E3%80%8D%E9%83%A8%E8%90%BD%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[给一棵树，每次可以使一条可以经过边设置为不可经过，也可以将不可经过的边设置成可以经过，多次询问两点间路径上的所有边是否都可以经过。 链接Luogu P3950 题解我不会告诉你这题我调了10天将可以经过转换成0，不可经过转换成1，然后树剖+边权下放。对于每次询问，考虑两点间路径上的点权和减去LCA的点权是否等于0即可。最近($2018.12.24$)数据加强了，存边数组开$7e5$过不了，要开$6e5$才能卡过。但是，换一种思路，也可以用LCT过。坑。 代码树剖：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct Edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,sum,tag;&#125;;struct Battle&#123; ll x,y;&#125;;const ll MAXN=700051;Battle bt[MAXN];Edge ed[MAXN];SegmentTree tree[MAXN&lt;&lt;1];ll last[MAXN],val[MAXN],depth[MAXN],fa[MAXN],size[MAXN],heavy[MAXN];ll id[MAXN],pre[MAXN],top[MAXN];ll tot,nc,cnt,ccnt,x,y,from,to,num,toto,tx;char op; inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;inline void update(ll node)&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=val[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void spread(ll node)&#123; if(tree[node].tag) &#123; tree[node&lt;&lt;1].sum+=tree[node].tag*(tree[node&lt;&lt;1].r-tree[node&lt;&lt;1].l+1); tree[(node&lt;&lt;1)|1].sum+=tree[node].tag*(tree[(node&lt;&lt;1)|1].r-tree[(node&lt;&lt;1)|1].l+1); tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; tree[node].tag=0; &#125;&#125;inline void change(ll pos,ll val,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].sum+=val; return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(pos&lt;=mid) &#123; change(pos,val,node&lt;&lt;1); &#125; else &#123; change(pos,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum+=val*(tree[node].r-tree[node].l+1); tree[node].tag+=val; return; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll query(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=0; if(l&lt;=mid) &#123; val+=query(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; val+=query(l,r,(node&lt;&lt;1)|1); &#125; return val;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1; ll maxn=-1; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f) &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to]; if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to]; &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link; if(!heavy[node]) &#123; return; &#125; ddfs(heavy[node],link); for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to); &#125; &#125;&#125;inline ll queryPath(ll x,ll y)&#123; ll ans=0; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans+=query(id[top[x]],id[x],1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans+=query(id[x],id[y],1); return ans;&#125;inline ll querySubtree(ll root)&#123; return query(id[root],id[root]+size[root]-1,1);&#125;inline void changePoint(ll x,ll val)&#123; change(id[x],val,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x],id[y],val,1);&#125;inline void changeSubtree(ll root,ll val)&#123; add(id[root],id[root]+size[root]-1,val,1);&#125;inline ll lca(ll x,ll y)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; x=fa[top[x]]; &#125; return depth[x]&lt;depth[y]?x:y;&#125;int main()&#123; nc=read(),cnt=read(); for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(); addEdge(from,to),addEdge(to,from); &#125; dfs(1,0,1),ddfs(1,1),create(1,nc,1); for(register int i=0;i&lt;cnt;i++) &#123; cin&gt;&gt;op; switch(op) &#123; case 'C':&#123; x=read(),y=read(); bt[++num].x=x,bt[num].y=y; tx=depth[x]&gt;depth[y]?x:y; changePoint(tx,1); break; &#125; case 'U':&#123; x=read(); y=bt[x].y,x=bt[x].x; tx=depth[x]&gt;depth[y]?x:y; changePoint(tx,-1); break; &#125; case 'Q':&#123; x=read(),y=read(); toto=queryPath(x,y)-queryPath(lca(x,y),lca(x,y)); toto?puts("No"):puts("Yes"); break; &#125; &#125; &#125;&#125; LCT：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=3e5+51;struct Battle&#123; ll x,y;&#125;;Battle bt[MAXN];ll cnt,qcnt,x,y,tot;char op;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;namespace LCT&#123; struct Node&#123; ll fa,val,tag; ll ch[2]; &#125;; struct LinkCutTree&#123; Node nd[MAXN]; ll st[MAXN]; inline bool nroot(ll x) &#123; return nd[nd[x].fa].ch[0]==x||nd[nd[x].fa].ch[1]==x; &#125; inline void update(ll x) &#123; nd[x].val=nd[nd[x].ch[0]].val^nd[nd[x].ch[1]].val; &#125; inline void reverse(ll x) &#123; swap(nd[x].ch[0],nd[x].ch[1]); &#125; inline void spread(ll x) &#123; if(nd[x].tag) &#123; reverse(x); nd[nd[x].ch[0]].tag^=1,nd[nd[x].ch[1]].tag^=1; nd[x].tag=0; &#125; &#125; inline void rotate(ll x) &#123; ll fa=nd[x].fa,gfa=nd[fa].fa; ll dir=nd[fa].ch[1]==x,son=nd[x].ch[!dir]; if(nroot(fa)) &#123; nd[gfa].ch[nd[gfa].ch[1]==fa]=x; &#125; nd[x].ch[!dir]=fa,nd[fa].ch[dir]=son; if(son) &#123; nd[son].fa=fa; &#125; nd[fa].fa=x,nd[x].fa=gfa; &#125; inline void splay(ll x) &#123; ll fa=x,gfa,cur=0; st[++cur]=fa; while(nroot(fa)) &#123; st[++cur]=fa=nd[fa].fa; &#125; while(cur) &#123; spread(st[cur--]); &#125; while(nroot(x)) &#123; fa=nd[x].fa,gfa=nd[fa].fa; if(nroot(fa)) &#123; rotate((nd[fa].ch[0]==x)^(nd[gfa].ch[0]==fa)?x:fa); &#125; rotate(x); &#125; &#125; inline void access(ll x) &#123; for(register int i=0;x;x=nd[i=x].fa) &#123; splay(x),nd[x].ch[1]=i; &#125; &#125; inline void makeRoot(ll x) &#123; access(x),splay(x),nd[x].tag^=1; &#125; inline ll findRoot(ll x) &#123; access(x),splay(x); while(nd[x].ch[0]) &#123; spread(x),x=nd[x].ch[0]; &#125; return x; &#125; inline void split(ll x,ll y) &#123; makeRoot(x),access(y),splay(y); &#125; inline void link(ll x,ll y) &#123; makeRoot(x),nd[x].fa=y; &#125; inline void cut(ll x,ll y) &#123; split(x,y),nd[x].fa=nd[y].ch[0]=0; &#125; &#125;;&#125;LCT::LinkCutTree lct;int main()&#123; cnt=read(),qcnt=read(); for(register int i=0;i&lt;cnt-1;i++) &#123; x=read(),y=read(); lct.link(x,y); &#125; for(register int i=0;i&lt;qcnt;i++) &#123; op=getchar(); while(op&lt;'-') &#123; op=getchar(); &#125; if(op=='Q') &#123; x=read(),y=read(); puts(lct.findRoot(x)==lct.findRoot(y)?"Yes":"No"); &#125; if(op=='C') &#123; x=read(),y=read(); lct.cut(x,y),bt[++tot].x=x,bt[tot].y=y; &#125; if(op=='U') &#123; x=read(); lct.link(bt[x].x,bt[x].y); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
        <tag>Link Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4114」Qtree1]]></title>
    <url>%2F2018%2F08%2F16%2F%E3%80%8CLuogu-P4114%E3%80%8DQtree1%2F</url>
    <content type="text"><![CDATA[怎么说呢，有点裸的树链剖分加上一些常用小技巧…… 链接Luogu P3950]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3178」[HAOI2015]树上操作]]></title>
    <url>%2F2018%2F08%2F14%2F%E3%80%8CHAOI2015%E3%80%8D%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[给定一棵树和多个操作，对于每一个操作3，回答该询问的答案。 链接Luogu P3178BZOJ 4034 题解树链剖分板子题。对于每一个1操作，直接将起点和终点设为这个点，执行路径修改。对于操作2和操作3，直接使用树剖板子。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,sum,tag;&#125;;edge ed[200051];SegmentTree tree[200051&lt;&lt;2];ll last[200051],val[200051],depth[200051],fa[200051],size[200051],heavy[200051];ll id[200051],pre[200051],top[200051];ll tot,nc,cnt,ccnt,op,x,y,from,to;inline ll read()//快读&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)//邻接表基本操作&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;//线段树基本操作inline void update(ll node)//更新节点值，用位运算优化&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum;&#125;inline void create(ll l,ll r,ll node)//建树&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=val[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1);//建左子树 create(mid+1,r,(node&lt;&lt;1)|1);//建右子树 update(node);//更新当前节点&#125;inline void spread(ll node)//下传懒标记&#123; if(tree[node].tag) &#123; //更新节点信息 tree[node&lt;&lt;1].sum+=tree[node].tag*(tree[node&lt;&lt;1].r-tree[node&lt;&lt;1].l+1); tree[(node&lt;&lt;1)|1].sum+=tree[node].tag*(tree[(node&lt;&lt;1)|1].r-tree[(node&lt;&lt;1)|1].l+1); //下传懒标记 tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; //清除当前节点懒标记 tree[node].tag=0; &#125;&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum+=val*(tree[node].r-tree[node].l+1); //做标记 tree[node].tag+=val; return; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll query(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=0; if(l&lt;=mid) &#123; val+=query(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; val+=query(l,r,(node&lt;&lt;1)|1); &#125; return val;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1;//更新节点深度，父节点，节点为根的子树大小 ll maxn=-1;//重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f)//遍历子节点 &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to];//更新子树大小 if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to];//标记重儿子 &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link;//标记节点新编号，赋初始值，更新节点所在重链的顶部 if(!heavy[node])//连重儿子都没有，肯定没有轻儿子，回溯 &#123; return; &#125; ddfs(heavy[node],link);//先遍历重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to);//遍历轻儿子，该节点所在重链顶部节点为自己 &#125; &#125;&#125;//无脑操作inline ll queryPath(ll x,ll y)//查询路径点权和&#123; ll ans=0; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans+=query(id[top[x]],id[x],1);//加上整个链的点权和 x=fa[top[x]];//爬到链顶 &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans+=query(id[x],id[y],1); return ans;&#125;inline ll querySubtree(ll root)&#123; return query(id[root],id[root]+size[root]-1,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x],id[y],val,1);&#125;inline void changeSubtree(ll root,ll val)&#123; add(id[root],id[root]+size[root]-1,val,1);&#125;int main()&#123; nc=read(),cnt=read(); for(register int i=1;i&lt;=nc;i++) &#123; pre[i]=read(); &#125; for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(); addEdge(from,to),addEdge(to,from); &#125; dfs(1,0,1),ddfs(1,1),create(1,nc,1); for(register int i=0;i&lt;cnt;i++) &#123; op=read(); switch(op) &#123; case 1:&#123; x=read(),y=read(); changePath(x,x,y); break; &#125; case 2:&#123; x=read(),y=read(); changeSubtree(x,y); break; &#125; case 3:&#123; x=read(); cout&lt;&lt;queryPath(x,1)&lt;&lt;endl; break; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>各省省选</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3384」【模板】树链剖分]]></title>
    <url>%2F2018%2F08%2F13%2F%E3%80%8CLuogu-P3384%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[模板题，裸的树链剖分，数组记得开大一倍，否则会WA3个点 链接Luogu P3384 代码代码有点长qwq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,sum,tag;&#125;;edge ed[200051];SegmentTree tree[200051&lt;&lt;2];ll last[200051],val[200051],depth[200051],fa[200051],size[200051],heavy[200051];ll id[200051],pre[200051],top[200051];ll tot,nc,cnt,root,ccnt,mod,op,x,y,z,from,to;inline ll read()//快读&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)//邻接表基本操作&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;//线段树基本操作inline void update(ll node)//更新节点值，用位运算优化&#123; tree[node].sum=(tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum)%mod;&#125;inline void create(ll l,ll r,ll node)//建树&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=val[l]%mod; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1);//建左子树 create(mid+1,r,(node&lt;&lt;1)|1);//建右子树 update(node);//更新当前节点&#125;inline void spread(ll node)//下传懒标记&#123; if(tree[node].tag) &#123; //更新节点信息 tree[node&lt;&lt;1].sum+=tree[node].tag*(tree[node&lt;&lt;1].r-tree[node&lt;&lt;1].l+1); tree[(node&lt;&lt;1)|1].sum+=tree[node].tag*(tree[(node&lt;&lt;1)|1].r-tree[(node&lt;&lt;1)|1].l+1); tree[node&lt;&lt;1].sum%=mod; tree[(node&lt;&lt;1)|1].sum%=mod; //下传懒标记 tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; tree[node&lt;&lt;1].tag%=mod; tree[(node&lt;&lt;1)|1].tag%=mod; //清除当前节点懒标记 tree[node].tag=0; &#125;&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum+=val*(tree[node].r-tree[node].l+1); //做标记 tree[node].tag+=val; return; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll query(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum%mod; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=0; if(l&lt;=mid) &#123; val+=query(l,r,node&lt;&lt;1); val%=mod; &#125; if(r&gt;mid) &#123; val+=query(l,r,(node&lt;&lt;1)|1); val%=mod; &#125; return val%mod;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1;//更新节点深度，父节点，节点为根的子树大小 ll maxn=-1;//重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f)//遍历子节点 &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to];//更新子树大小 if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to];//标记重儿子 &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link;//标记节点新编号，赋初始值，更新节点所在重链的顶部 if(!heavy[node])//连重儿子都没有，肯定没有轻儿子，回溯 &#123; return; &#125; ddfs(heavy[node],link);//先遍历重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to);//遍历轻儿子，该节点所在重链顶部节点为自己 &#125; &#125;&#125;//无脑操作inline ll queryPath(ll x,ll y)//查询路径点权和&#123; ll ans=0; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans+=query(id[top[x]],id[x],1)%mod;//加上整个链的点权和 x=fa[top[x]];//爬到链顶 &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans+=query(id[x],id[y],1)%mod; return ans;&#125;inline ll querySubtree(ll root)&#123; return query(id[root],id[root]+size[root]-1,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x],id[y],val,1);&#125;inline void changeSubtree(ll root,ll val)&#123; add(id[root],id[root]+size[root]-1,val,1);&#125;int main()&#123; nc=read(),cnt=read(),root=read(),mod=read(); for(register int i=1;i&lt;=nc;i++) &#123; pre[i]=read(); &#125; for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(); addEdge(from,to),addEdge(to,from); &#125; dfs(root,0,1),ddfs(root,root),create(1,nc,1); for(register int i=0;i&lt;cnt;i++) &#123; op=read(); switch(op) &#123; case 1:&#123; x=read(),y=read(),z=read(); changePath(x,y,z%mod); break; &#125; case 2:&#123; x=read(),y=read(); cout&lt;&lt;queryPath(x,y)%mod&lt;&lt;endl; break; &#125; case 3:&#123; x=read(),y=read(); changeSubtree(x,y%mod); break; &#125; case 4:&#123; x=read(); cout&lt;&lt;querySubtree(x)%mod&lt;&lt;endl; break; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·树链剖分]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[树链剖分是一种将一颗树通过划分不相交的来维护树上路径信息的算法。它保证每一个点仅在一个链上，并通过毒瘤数据结构来维护节点信息。树链剖分是干什么用的呢？很简单，借助树链剖分，可以任意修改树上两点最短路径的点权和子树点权，根本用不着树上差分。如果这棵树是一条链，支持修改和查询，那么我们可以重新按深度编号，这样子每棵子树上的编号都是连续的了，就可以用毒瘤数据结构来解决。但是，事实上，连洛谷模板的样例都不是一条链。尽管有人说可以用LCA+树上差分过，但你觉得数据可能是纯随机的么qwq。所以说，我们应该用树链剖分。 前置技能第一个是刚才标粗的毒瘤数据结构，树链剖分是依靠毒瘤数据结构，比如线段树，树状数组，平衡树等来修改和查询，否则就GG了……第二个是LCA，即最近公共祖先。第三个是树的DFS序，这个有什么用后面会讲。]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2002」消息扩散]]></title>
    <url>%2F2018%2F08%2F11%2F%E3%80%8CLuogu-P2002%E3%80%8D%E6%B6%88%E6%81%AF%E6%89%A9%E6%95%A3%2F</url>
    <content type="text"><![CDATA[给出一个有向图，消息沿着边扩散，求最少需要在几个点发消息才能使整个图所有点都得到消息。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[500001],scc[500001];ll test,tot,num,top,cnt,nc,ec,ans;ll last[500001],sccLast[500001],dfn[500001],low[500001],ins[500001],belong[500001];ll from[500001],to[500001],size[500001],in[500001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void addSCC(ll from,ll to)&#123; scc[++tot].to=to; scc[tot].prev=sccLast[from]; sccLast[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;inline void mergePoint()&#123; tot=0; for(register int i=0;i&lt;ec;i++) &#123; if(belong[from[i]]!=belong[to[i]]) &#123; addSCC(belong[from[i]],belong[to[i]]); in[belong[to[i]]]++; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;nc&gt;&gt;ec; for(register int i=0;i&lt;ec;i++) &#123; cin&gt;&gt;from[i]&gt;&gt;to[i]; addEdge(from[i],to[i]); &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; mergePoint(); for(register int i=1;i&lt;=cnt;i++) &#123; if(!in[i]) &#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 402E」Strictly Positive Matrix]]></title>
    <url>%2F2018%2F08%2F11%2F%E3%80%8CCodeForces-402E%E3%80%8DStrictly-Positive-Matrix%2F</url>
    <content type="text"><![CDATA[给你一个$n*n$大小的矩阵，问你是否有一个正整数$k$使得这个矩阵的$k$次幂均为正数。未完，贴代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[5000001];ll tot,num,dist,top,cnt,nc;ll last[5000001],dfn[5000001],low[5000001],ins[5000001],belong[5000001],size[5000001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;int main()&#123; scanf("%d",&amp;nc); for(register int i=0;i&lt;nc;i++) &#123; for(register int j=0;j&lt;nc;j++) &#123; scanf("%d",&amp;dist); if(dist) &#123; addEdge(i+1,j+1); &#125; &#125; &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; cnt==1?printf("YES\n"):printf("NO\n");&#125;]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>邻接矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2341」[HAOI2006]受欢迎的牛]]></title>
    <url>%2F2018%2F08%2F09%2F%E3%80%8CHAOI2006%E3%80%8D%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[给定一个有向图，找出与其他点均可达的点的个数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[150001],scc[150001];ll sccno,tot,num,top,cnt,nc,ec,ans;ll last[150001],sccLast[150001],dfn[150001],low[150001],ins[150001],belong[150001];ll from[150001],to[150001],size[150001],out[150001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void addSCC(ll from,ll to)&#123; scc[++tot].to=to; scc[tot].prev=sccLast[from]; sccLast[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;inline void mergePoint()&#123; tot=0; for(register int i=0;i&lt;ec;i++) &#123; if(belong[from[i]]!=belong[to[i]]) &#123; addSCC(belong[from[i]],belong[to[i]]); out[belong[from[i]]]++; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;nc&gt;&gt;ec; for(register int i=0;i&lt;ec;i++) &#123; cin&gt;&gt;from[i]&gt;&gt;to[i]; addEdge(from[i],to[i]); &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; mergePoint(); for(register int i=1;i&lt;=cnt;i++) &#123; if(!out[i]) &#123; ans++; sccno=i; &#125; &#125; if(ans!=1) &#123; cout&lt;&lt;0; &#125; else &#123; cout&lt;&lt;size[sccno]; &#125;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11324」The Largest Clique]]></title>
    <url>%2F2018%2F08%2F08%2F%E3%80%8CUVa-11324%E3%80%8DThe-Largest-Clique%2F</url>
    <content type="text"><![CDATA[给定一个有向图，找出一个子图使得对于该子图的任意两个点$u$,$v$,$u$可以到达$v$或$v$可以到达$u$,判断这样的最大子图的节点个数。 链接登不了UVa，只能用洛谷的链接惹qwqUVa 11324 题解求出图中的强连通分量，缩点，变成DAG。每一个点给一个权值，权值设为每个强连通分量的结点数。最后用记忆化搜索给出最长路。求最长路时写炸了，输入居然可以决定最长路的总权值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[150001],scc[150001];ll test,tot,num,top,cnt,nc,ec,ans;ll last[150001],sccLast[150001],dfn[150001],low[150001],ins[150001],belong[150001];ll from[150001],to[150001],size[150001],dp[150001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void addSCC(ll from,ll to)&#123; scc[++tot].to=to; scc[tot].prev=sccLast[from]; sccLast[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;inline void mergePoint()&#123; tot=0; for(register int i=0;i&lt;ec;i++) &#123; if(belong[from[i]]!=belong[to[i]]) &#123; addSCC(belong[from[i]],belong[to[i]]); &#125; &#125;&#125;inline void search(ll node)&#123; if(dp[node]) &#123; return; &#125; dp[node]=size[node]; ll maxn=0; for(register int i=sccLast[node];i;i=scc[i].prev) &#123; if(!dp[scc[i].to]) &#123; search(scc[i].to); &#125; maxn=max(maxn,dp[scc[i].to]); &#125; dp[node]+=maxn;&#125;int main()&#123; cin&gt;&gt;test; for(register int i=0;i&lt;test;i++) &#123; cin&gt;&gt;nc&gt;&gt;ec; for(register int i=0;i&lt;ec;i++) &#123; cin&gt;&gt;from[i]&gt;&gt;to[i]; addEdge(from[i],to[i]); &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; mergePoint(); for(register int i=1;i&lt;=cnt;i++) &#123; if(!dp[i]) &#123; search(i); ans=max(ans,dp[i]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; tot=num=top=cnt=nc=ec=ans=0; memset(last,0,sizeof(last)); memset(sccLast,0,sizeof(sccLast)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(ins,0,sizeof(ins)); memset(belong,0,sizeof(belong)); memset(from,0,sizeof(from)); memset(to,0,sizeof(to)); memset(size,0,sizeof(size)); memset(dp,0,sizeof(dp)); for(register int i=0;i&lt;150001;i++) &#123; ed[i].prev=ed[i].to=scc[i].prev=scc[i].to=0; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>UVa</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3128」最大流]]></title>
    <url>%2F2018%2F08%2F08%2F%E3%80%8CLuogu-P3128%E3%80%8D%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[给出一棵树和一些操作，每次操作都将两点间所有经过的点的点权+1，求出点权最大的点的权值。 链接Luogu P3128 题解怎么说呢，一道树上点差分模板题，当然树链剖分也可以做。定义$diff[i]$为点$i$的差分值，那么对于每一次修改的参数$start$和$end$，将$diff[start++,diff[end++,diff[\operatorname{lca}(start,end)—]$。为了不让路线修改蔓延到祖先，把LCA的父节点的差分值-1。最后用DFS求出子树差分数组的和就得到该节点修改后的点权啦。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev; &#125;;ll nc,ec,query,root,from,to;ll depth[500010],anc[500010][31],last[500010],diff[500010],LCA,maxn;edge ed[500010*2];inline void addEdge(ll from,ll to)&#123; ed[++ec].prev=last[from]; ed[ec].to=to; last[from]=ec;&#125;inline void dfs(ll node)&#123; ll son; for(register int i=last[node];i!=0;i=ed[i].prev) &#123; son=ed[i].to; if(!depth[son]) &#123; depth[son]=depth[node]+1; anc[son][0]=node; dfs(son); &#125; &#125;&#125;inline void LCASetup()&#123; depth[1]=1; anc[1][0]=0; dfs(1); for(register int i=1;i&lt;=21;i++) &#123; for(register int j=1;j&lt;=nc;j++) &#123; anc[j][i]=anc[anc[j][i-1]][i-1]; &#125; &#125;&#125;inline ll lca(ll x,ll y)&#123; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; for(register int i=21;i&gt;=0;i--) &#123; if(depth[anc[y][i]]&gt;=depth[x]) &#123; y=anc[y][i]; &#125; &#125; if(x==y) &#123; return x; &#125; for(register int i=21;i&gt;=0;i--) &#123; if(anc[x][i]!=anc[y][i]) &#123; x=anc[x][i]; y=anc[y][i]; &#125; &#125; return anc[x][0];&#125;inline ll ddfs(ll node)&#123; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to==anc[node][0]) &#123; continue; &#125; ddfs(ed[i].to); diff[node]+=diff[ed[i].to]; &#125; maxn=max(maxn,diff[node]);&#125;int main()&#123; scanf("%d%d",&amp;nc,&amp;query); for(register int i=0;i&lt;nc-1;i++) &#123; scanf("%d%d",&amp;from,&amp;to); addEdge(from,to); addEdge(to,from); &#125; LCASetup(); for(register int i=0;i&lt;query;i++) &#123; scanf("%d%d",&amp;from,&amp;to); LCA=lca(from,to); diff[from]++,diff[to]++,diff[LCA]--,diff[anc[LCA][0]]--; &#125; ddfs(1); cout&lt;&lt;maxn;&#125;]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>树上差分</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 191C」Fools and Roads]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8CCodeForces-191C%E3%80%8DFools-and-Roads%2F</url>
    <content type="text"><![CDATA[给一棵有根树和一些路线，路线上的边权都+1，求所有边的权值 链接CodeForces 191C 题解这个题目的输出是每一条边所经过的次数，所以想到树上边差分。在差分之后确实是晕了，没有想到好的方法，但是突然想到了DFS求树上前缀和，对于每一条边，只要计算深度小的前缀和-深度大的前缀和即得答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev; &#125;;ll nc,ec,query,root,from,to;ll depth[500010],anc[500010][31],last[500010],diff[500010],prefix[500010],LCA,maxn;ll From[500010],To[500010];edge ed[500010*2];inline void addEdge(ll from,ll to)&#123; ed[++ec].prev=last[from]; ed[ec].to=to; last[from]=ec;&#125;inline void dfs(ll node)&#123; ll son; for(register int i=last[node];i!=0;i=ed[i].prev) &#123; son=ed[i].to; if(!depth[son]) &#123; depth[son]=depth[node]+1; anc[son][0]=node; dfs(son); &#125; &#125;&#125;inline void LCASetup()&#123; depth[1]=1; anc[1][0]=0; dfs(1); for(register int i=1;i&lt;=21;i++) &#123; for(register int j=1;j&lt;=nc;j++) &#123; anc[j][i]=anc[anc[j][i-1]][i-1]; &#125; &#125;&#125;inline ll lca(ll x,ll y)&#123; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; for(register int i=21;i&gt;=0;i--) &#123; if(depth[anc[y][i]]&gt;=depth[x]) &#123; y=anc[y][i]; &#125; &#125; if(x==y) &#123; return x; &#125; for(register int i=21;i&gt;=0;i--) &#123; if(anc[x][i]!=anc[y][i]) &#123; x=anc[x][i]; y=anc[y][i]; &#125; &#125; return anc[x][0];&#125;inline void ddfs(ll node)&#123; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to==anc[node][0]) &#123; continue; &#125; ddfs(ed[i].to); diff[node]+=diff[ed[i].to]; &#125;&#125;inline void dffs(ll node,ll val)&#123; prefix[node]=diff[node]+val; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to==anc[node][0]) &#123; continue; &#125; dffs(ed[i].to,prefix[node]); &#125;&#125;int main()&#123; scanf("%d",&amp;nc); for(register int i=0;i&lt;nc-1;i++) &#123; scanf("%d%d",&amp;from,&amp;to); From[i]=from,To[i]=to; addEdge(from,to); addEdge(to,from); &#125; LCASetup(); scanf("%d",&amp;query); for(register int i=0;i&lt;query;i++) &#123; scanf("%d%d",&amp;from,&amp;to); LCA=lca(from,to); diff[from]++,diff[to]++,diff[LCA]-=2; &#125; ddfs(1); dffs(1,0); for(register int i=0;i&lt;nc-1;i++) &#123; if(depth[From[i]]&lt;depth[To[i]]) &#123; swap(From[i],To[i]); &#125; printf("%d ",prefix[From[i]]-prefix[To[i]]); &#125;&#125;]]></content>
      <tags>
        <tag>待修改</tag>
        <tag>CodeForces</tag>
        <tag>LCA</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
</search>
