<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「CodeForces 501D」Misha and Permutations Summation]]></title>
    <url>%2F2018%2F11%2F19%2F%E3%80%8CCodeForces-501D%E3%80%8DMisha-and-Permutations-Summation%2F</url>
    <content type="text"><![CDATA[设$P$是一个长度为$n$的排列，定义$\operatorname{ord}P$为$P$在所有排列中的名次。给定两个长度为$n$的排列$P_1,P_2$，求第$\operatorname{ord}P_1+\operatorname{ord}P_2 \bmod n!$小的排列。 前置技能康托展开这里讲从排列映射到数的过程，还是假设这个排列长度为$n$。对于第$i$次操作，统计这个数后面有多少个比它小的数，记为$a_i$那么答案是$\sum_{i=1}^{n}a_i(n-i)!$ 题解这一个题和UVa 11525很像，不会做的可以参考一下本蒟蒻的题解，做法就是用一颗权值线段树维护全局没被放进排列中的第$k$小，所以做这个题可以先把它转化为上面那个题。首先把两个排列映射到整数，这里要统计后面有多少个比第$i$个数$a_i$小的数。如果暴力找的话是$O(n^2)$的。但是，可以发现排列是由$0,1\cdots n-1$组成的，那么排列里比这个数小的数的个数就是这个数。这句话不是很好懂，但是很重要。因为排列里比这个数$x$小的只有$0,1\cdots x-1$，共有$x$个，所以有$x$个数比$x$小。所以可以显然推出后面比$a_i$小的数的个$=$总共比$a_i$小的数$-$在$a_i$前面比$a_i$小的数。而排在前面比$a_i$小的数可以用树状数组维护。用一个树状数组维护第$i$个数是否出现过。对于当前的数，统计$1$到当前数$-1$中的和，就是在这个数前面比它小的数。所以说，可以用$O(n\log n)$的时间复杂度把$a_{P_1,i}$和$a_{P_2,i}$（$a$指的是前置技能里的$a$数组）求出来，记$S_i=a_{P_1,i}+a_{P_2,i}$。接下来化简$S$，由于$(x+1)\cdot x!=(x+1)!$，于是可以用这个性质化简$S_i$，使得$0\leq S_i\leq n-i$。具体方法是，对于$S_i$，$S_{i+1}+=S_i \% n-i,S_i\%=n-i$就可以简化$S$数组了。最后我们就把问题转化为上面的那个题了，用那个题的方法做就可以了qwq。时间复杂度$O(n\log n)$，常数不大除了权值线段树，跑了$2270$ms，拿了最优解qwq。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e5+51;struct BIT&#123; ll size; ll num[MAXN]; inline ll lowbit(ll x) &#123; return x&amp;-x; &#125; inline void add(ll pos,ll val) &#123; for(;pos&lt;=size;pos+=lowbit(pos)) &#123; num[pos]+=val; &#125; &#125; inline ll queryPrefix(ll pos) &#123; ll res=0; for(;pos;pos-=lowbit(pos)) &#123; res+=num[pos]; &#125; return res; &#125;&#125;;struct SegmentTree&#123; ll l,r,size;&#125;;BIT bit,bit2;SegmentTree tree[MAXN&lt;&lt;2];ll cnt,num;ll perm[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll node)&#123; tree[node].size=tree[node&lt;&lt;1].size+tree[(node&lt;&lt;1)|1].size;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].size=1; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline ll findVal(ll rk,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].size=0; return tree[node].l; &#125; ll res=0; if(rk&lt;=tree[node&lt;&lt;1].size) &#123; res=findVal(rk,node&lt;&lt;1); &#125; else &#123; res=findVal(rk-tree[node&lt;&lt;1].size,(node&lt;&lt;1)|1); &#125; update(node); return res;&#125;int main()&#123; bit.size=bit2.size=cnt=read(); for(register int i=1;i&lt;=cnt;i++) &#123; num=read(); perm[i]=num-bit.queryPrefix(num),bit.add(num+1,1); &#125; for(register int i=1;i&lt;=cnt;i++) &#123; num=read(); perm[i]+=num-bit2.queryPrefix(num),bit2.add(num+1,1); &#125; for(register int i=cnt,j=0;i;i--,j++) &#123; perm[i-1]+=perm[i]/(j+1),perm[i]%=(j+1); &#125; create(1,cnt,1); for(register int i=1;i&lt;=cnt;i++) &#123; printf("%d ",findVal(perm[i]+1,1)-1); &#125; &#125;]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11525」Permutation]]></title>
    <url>%2F2018%2F11%2F18%2F%E3%80%8CUVa-11525%E3%80%8DPermutation%2F</url>
    <content type="text"><![CDATA[给定$n$个数$x_1,x_2\cdots x_n$，已知$S=\sum^{n}_{i=1}x_i(n-i)!$，求第$S$个排列 前置技能康托展开是一个比较常用的哈希技巧，可以将一个排列$a_1,a_2\cdots a_n$映射到一个整数$k$，这个整数$k$就是这个排列在所有排列中的名次。由于它是双射的，所以也可以从一个整数还原这个整数所对应的全排列。假定这个排列是由$n$个数组成的，那么有从一个整数$k$映射到第$k$小的排列的方法：将$k$写成$\sum^{n}_{i=1}x_i(n-i)!$的形式，其中对于任意$x_i$，有$0\leq x_i\leq i$。对于第$i$次操作，选择当前没有选过的第$x_i$大的数加入排列。进行第二步$n$次，所得的排列即为所求。 题解注意到，题目已经完成了第一步，所以只需要完成第二步就可以了。而数据范围$k\leq 5\times10^4$，所以要写一种高效的数据结构，支持区间第$k$小和删除一个数。这里用权值线段树实现，由于$1\leq x_i\leq n$（这里的变量都是值上面的题意而言的），所以不用离散化。于是查询变得很简单了，但删除呢？可以将这个数置为$0$，意思是被删除了。如果这个节点的值为$0$，那么整个子树都不复存在。这份代码还是跑的蛮快的，$60$ms。可还是没有最优解跑的快最后，此题卡输出格式，要像我这么写才能AC 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=5e4+51;struct SegmentTree&#123; ll l,r,size;&#125;;ll test,cnt,num;SegmentTree tree[MAXN&lt;&lt;2];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll node)&#123; tree[node].size=tree[node&lt;&lt;1].size+tree[(node&lt;&lt;1)|1].size;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].size=1; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125; inline ll findVal(ll rk,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].size=0; return tree[node].l; &#125; ll res; if(rk&lt;=tree[node&lt;&lt;1].size) &#123; res=findVal(rk,node&lt;&lt;1); &#125; else &#123; res=findVal(rk-tree[node&lt;&lt;1].size,(node&lt;&lt;1)|1); &#125; update(node); return res;&#125;int main()&#123; test=read(); for(register int i=0;i&lt;test;i++) &#123; cnt=read(); create(1,cnt,1); for(register int j=0;j&lt;cnt;j++) &#123; num=read()+1; printf("%d",findVal(num,1)); putchar(j==cnt-1?'\n':' '); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>UVa</tag>
        <tag>组合数学</tag>
        <tag>康托展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11297」Census]]></title>
    <url>%2F2018%2F11%2F16%2F%E3%80%8CUVa-11297%E3%80%8DCensus%2F</url>
    <content type="text"><![CDATA[给定一个$n\times n$的矩阵，支持单点修改，查询子矩阵最大值和子矩阵最小值。 链接UVa 11297 题解经典的二维带修RMQ问题。一个暴力的思想是建$500$棵线段树，对于修改就在对应的线段树上修改，对于查询的时候就一行一行的查询，每一次把答案与之前的答案合并一下就好了qwq。这样子做的时间复杂度是$O(qn\log n)$，不会TLE，但是跑的极慢，在测的时候跑了$1070$ms，没有树套树跑的快…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=551;struct SegmentTree&#123; ll l,r,minn,maxn; &#125;;SegmentTree tree[MAXN][MAXN&lt;&lt;2];ll size,qcnt,lx,ly,rx,ry,x,y,val,minn,maxn;char ch;ll num[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll dim,ll node)&#123; tree[dim][node].maxn=max(tree[dim][node&lt;&lt;1].maxn,tree[dim][(node&lt;&lt;1)|1].maxn); tree[dim][node].minn=min(tree[dim][node&lt;&lt;1].minn,tree[dim][(node&lt;&lt;1)|1].minn);&#125;inline void create(ll dim,ll l,ll r,ll node)&#123; tree[dim][node].l=l,tree[dim][node].r=r; if(l==r) &#123; tree[dim][node].minn=tree[dim][node].maxn=num[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(dim,l,mid,node&lt;&lt;1); create(dim,mid+1,r,(node&lt;&lt;1)|1); update(dim,node);&#125;inline void changePoint(ll dim,ll pos,ll val,ll node)&#123; if(tree[dim][node].l==tree[dim][node].r) &#123; tree[dim][node].minn=tree[dim][node].maxn=val; return; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1; if(pos&lt;=mid) &#123; changePoint(dim,pos,val,node&lt;&lt;1); &#125; else &#123; changePoint(dim,pos,val,(node&lt;&lt;1)|1); &#125; update(dim,node);&#125;inline ll queryMax(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].maxn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0; if(l&lt;=mid) &#123; res=max(res,queryMax(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=max(res,queryMax(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;inline ll queryMin(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].minn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0x7fffffff; if(l&lt;=mid) &#123; res=min(res,queryMin(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=min(res,queryMin(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;int main()&#123; size=read(); for(register int i=1;i&lt;=size;i++) &#123; for(register int j=1;j&lt;=size;j++) &#123; num[j]=read(); &#125; create(i,1,size,1); &#125; qcnt=read(); for(register int i=0;i&lt;qcnt;i++) &#123; cin&gt;&gt;ch; if(ch=='q') &#123; lx=read(),ly=read(),rx=read(),ry=read(); maxn=0,minn=0x7fffffff; for(register int j=lx;j&lt;=rx;j++) &#123; maxn=max(maxn,queryMax(j,ly,ry,1)); minn=min(minn,queryMin(j,ly,ry,1)); &#125; printf("%d %d\n",maxn,minn); &#125; else &#123; x=read(),y=read(),val=read(); changePoint(x,y,val,1); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11992」Fast Matrix Operations]]></title>
    <url>%2F2018%2F11%2F15%2F%E3%80%8CUVa-11992%E3%80%8DFast-Matrix-Operations%2F</url>
    <content type="text"><![CDATA[给定一个$r\times c$矩阵，支持子矩阵加某一个值，子矩阵覆盖为某一个值，查询某个子矩阵的值。 链接一如既往放洛谷的链接……UVa 11992 题解一个暴力的想法是由于$r$不超过$20$，所以可以开$20$棵线段树，修改和覆盖就不难啦qwq。至于查询，可以处理这一行的时候合并这一行的答案和原来的答案就好了qwq。所以我查询了$3$次这个时间复杂度是$O(r\log c)$，绝对不会T掉的 代码代码略丑，$233$行…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=5e4+51;struct SegmentTree&#123; ll l,r,sum,maxn,minn,tag,cover;&#125;; SegmentTree tree[21][MAXN&lt;&lt;2];ll length,width,qcnt,lx,rx,ly,ry,op,val,sum,maxn,minn;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll dim,ll node)&#123; tree[dim][node].sum=tree[dim][node&lt;&lt;1].sum+tree[dim][(node&lt;&lt;1)|1].sum; tree[dim][node].maxn=max(tree[dim][node&lt;&lt;1].maxn,tree[dim][(node&lt;&lt;1)|1].maxn); tree[dim][node].minn=min(tree[dim][node&lt;&lt;1].minn,tree[dim][(node&lt;&lt;1)|1].minn);&#125;inline void create(ll dim,ll l,ll r,ll node)&#123; tree[dim][node].l=l,tree[dim][node].r=r,tree[dim][node].cover=-1; if(l==r) &#123; tree[dim][node].sum=tree[dim][node].maxn=tree[dim][node].minn=0; return; &#125; ll mid=(l+r)&gt;&gt;1; create(dim,l,mid,node&lt;&lt;1); create(dim,mid+1,r,(node&lt;&lt;1)|1); update(dim,node);&#125;inline void spread(ll dim,ll node)&#123; ll ls=node&lt;&lt;1,rs=ls|1; ll lx=(tree[dim][ls].r-tree[dim][ls].l+1); ll rx=(tree[dim][rs].r-tree[dim][rs].l+1); if(tree[dim][node].cover!=-1) &#123; tree[dim][ls].maxn=tree[dim][node].cover; tree[dim][rs].maxn=tree[dim][node].cover; tree[dim][ls].minn=tree[dim][node].cover; tree[dim][rs].minn=tree[dim][node].cover; tree[dim][ls].sum=tree[dim][node].cover*lx; tree[dim][rs].sum=tree[dim][node].cover*rx; tree[dim][ls].cover=tree[dim][rs].cover=tree[dim][node].cover; tree[dim][ls].tag=tree[dim][rs].tag=0; tree[dim][node].cover=-1; &#125; if(tree[dim][node].tag) &#123; tree[dim][ls].maxn+=tree[dim][node].tag; tree[dim][rs].maxn+=tree[dim][node].tag; tree[dim][ls].minn+=tree[dim][node].tag; tree[dim][rs].minn+=tree[dim][node].tag; tree[dim][ls].sum+=tree[dim][node].tag*lx; tree[dim][rs].sum+=tree[dim][node].tag*rx; tree[dim][ls].tag+=tree[dim][node].tag; tree[dim][rs].tag+=tree[dim][node].tag; tree[dim][node].tag=0; &#125; &#125;inline void add(ll dim,ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; tree[dim][node].sum+=(tree[dim][node].r-tree[dim][node].l+1)*val; tree[dim][node].maxn+=val,tree[dim][node].minn+=val; tree[dim][node].tag+=val; return; &#125; spread(dim,node); ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(dim,l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(dim,l,r,val,(node&lt;&lt;1)|1); &#125; update(dim,node);&#125;inline void cover(ll dim,ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; tree[dim][node].sum=(tree[dim][node].r-tree[dim][node].l+1)*val; tree[dim][node].maxn=tree[dim][node].minn=val; tree[dim][node].cover=val; tree[dim][node].tag=0; return; &#125; spread(dim,node); ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1; if(l&lt;=mid) &#123; cover(dim,l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; cover(dim,l,r,val,(node&lt;&lt;1)|1); &#125; update(dim,node);&#125;inline ll query(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].sum; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0; spread(dim,node); if(l&lt;=mid) &#123; res+=query(dim,l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; res+=query(dim,l,r,(node&lt;&lt;1)|1); &#125; return res;&#125;inline ll queryMax(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].maxn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0; spread(dim,node); if(l&lt;=mid) &#123; res=max(res,queryMax(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=max(res,queryMax(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;inline ll queryMin(ll dim,ll l,ll r,ll node)&#123; if(l&lt;=tree[dim][node].l&amp;&amp;r&gt;=tree[dim][node].r) &#123; return tree[dim][node].minn; &#125; ll mid=(tree[dim][node].l+tree[dim][node].r)&gt;&gt;1,res=0x7fffffff; spread(dim,node); if(l&lt;=mid) &#123; res=min(res,queryMin(dim,l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=min(res,queryMin(dim,l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;inline void solve()&#123; width=read(),qcnt=read(); for(register int i=1;i&lt;=length;i++) &#123; create(i,1,width,1); &#125; for(register int i=1;i&lt;=qcnt;i++) &#123; op=read(),lx=read(),ly=read(),rx=read(),ry=read(); if(op==1) &#123; val=read(); for(register int j=lx;j&lt;=rx;j++) &#123; add(j,ly,ry,val,1); &#125; &#125; if(op==2) &#123; val=read(); for(register int j=lx;j&lt;=rx;j++) &#123; cover(j,ly,ry,val,1); &#125; &#125; if(op==3) &#123; sum=maxn=0,minn=0x7fffffff; for(register int j=lx;j&lt;=rx;j++) &#123; sum+=query(j,ly,ry,1); maxn=max(maxn,queryMax(j,ly,ry,1)); minn=min(minn,queryMin(j,ly,ry,1)); &#125; printf("%d %d %d\n",sum,minn,maxn); &#125; if(op==4) &#123; for(register int j=1;j&lt;=length;j++) &#123; for(register int k=1;k&lt;=width;k++) &#123; printf("%d ",query(j,k,k,1)); &#125; puts(""); &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d",&amp;length)!=EOF) &#123; solve(); memset(tree,0,sizeof(tree)); &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018滚粗记]]></title>
    <url>%2F2018%2F11%2F15%2FNOIP2018%E6%BB%9A%E7%B2%97%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[NOIP要咕咕了…… Day 0上午写模板,lca,Heap+Dijkstra,k短路,网络流，好像背不下来……下午与全机房的大佬颓slay，咕咕咕…… Day 1Task 1 road开始：先写个线段树再说吧……后来:这……这不是积木大赛吗？我怎么一开始就写的线段树…… Task 2 money开始：一脸茫然的样子……后来：可以乱搞诶，消掉其他货币组成的货币，剩下的直接选，标记一下，$O(Tn25000)$应该不会TLE…… Task 3 track开始：应该是个二分答案……后来：觉得$m=1$可做，好像有$10$分啊，后面的骗一下分吧，今天要$100+100+10=210$滚粗了…… Day 2Task 1 travel开始：树上$60$分真好做，基环树？不会……后来：好像可以找环，断边乱搞……（事实上这是非正解，咕咕，但是可以过咕咕F的数据） Task 2 game开始：先爆搜，打个表再说……后来：为什么$3\times3$不对，搜出$144$，为什么……骗一点分吧 Task 3 defense开始：好像是个$dp$……后来：我擦！$ddp$？不会做，今天是不是要$76+33+0=109$滚粗…… Day $log(n)$洛谷成绩$100+100+25+76+55+0=356$滚粗…… Day $n$咕咕F的成绩再一次咕掉了，我的博客也要咕掉…… Day $n\log(n)$成绩？呵呵……技不如人，被吊打]]></content>
      <tags>
        <tag>游记/考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2532」[AHOI2012]树屋阶梯]]></title>
    <url>%2F2018%2F11%2F10%2F%E3%80%8CLuogu-P2532%E3%80%8D-AHOI2012-%E6%A0%91%E5%B1%8B%E9%98%B6%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[引言NOIP rp++! 链接Luogu P2532 题解考虑$f_i$表示搭$i$层高的阶梯的方案数，$g_{i,j}$表示最左下角的钢材上面有$i$层高，右边有$j$层高的方案数，那么如图$f_n=\sum^{n-1}_{i=1}g_{i,j}$而$i+j=n$且$g_{i,j}=f_if_j$$\therefore f_n=\sum^{n-1}_{i=1}f_if_{n-i}$显然是卡特兰的递推式，所以就可以用卡特兰数求，但是要用高精度…… 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=2e4+51; struct BigInt&#123; ll digit; ll num[MAXN]; BigInt() &#123; memset(num,0,sizeof(num)); &#125; inline void operator =(ll x) &#123; while(x) &#123; num[digit++]=x%10000,x/=10000; &#125; &#125; inline void op() &#123; printf("%d",num[digit-1]); for(register int i=digit-2;i&gt;=0;i--) &#123; if(!num[i]) &#123; printf("0000"); continue; &#125; ll rest=3-(ll)(log10(num[i])); for(register int j=rest;j;j--) &#123; putchar('0'); &#125; printf("%d",num[i]); &#125; &#125; inline bool operator &gt;(const BigInt &amp;rhs)const &#123; if(digit!=rhs.digit) &#123; return digit&gt;rhs.digit; &#125; for(register int i=digit-1;i&gt;=0;i--) &#123; if(num[i]!=rhs.num[i]) &#123; return num[i]&gt;rhs.num[i]; &#125; &#125; return 0; &#125;&#125;; ll num;BigInt res;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline BigInt operator +(BigInt x,BigInt y)&#123; BigInt res; ll carry=0; res.digit=max(x.digit,y.digit)+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]+y.num[i]+carry; carry=res.num[i]/10000,res.num[i]%=10000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator *(BigInt x,ll y)&#123; BigInt res; ll carry=0; res.digit=x.digit+1; for(register int i=0;i&lt;=res.digit;i++) &#123; res.num[i]=x.num[i]*y+carry; carry=res.num[i]/10000,res.num[i]%=10000; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;inline BigInt operator /(BigInt x,ll y)&#123; BigInt res; ll cur=0; res.digit=x.digit; for(register int i=x.digit-1;i&gt;=0;i--) &#123; cur=cur*10000+x.num[i]; if(cur&gt;=y) &#123; res.num[i]=cur/y,cur%=y; &#125; &#125; if(!res.num[res.digit-1]) &#123; res.digit--; &#125; return res;&#125;int main()&#123; num=read(); res=1; for(register int i=1;i&lt;=2*num;i++) &#123; res=res*i; &#125; res=res/(num+1); for(register int i=1;i&lt;=num;i++) &#123; res=res/i/i; &#125; res.op();&#125;]]></content>
      <tags>
        <tag>高精</tag>
        <tag>数论</tag>
        <tag>卡特兰</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3939」数颜色]]></title>
    <url>%2F2018%2F11%2F08%2F%E3%80%8CLuogu-P3939%E3%80%8D%E6%95%B0%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[给定一个序列，支持交换两个元素和询问区间$(l,r)$内等于这个值的位置的数量。 链接Luogu P3939 题解肯定有人学数据结构学傻了吧，我们机房有写cdq的，有写主席树的，跑的都很快亲测这份代码不吸氧比上面两份代码吸氧还快……评测结果用vector记录每一种颜色的兔子出现在从左到右的哪几个位置，对于每个询问，二分查找出当前右端点$r$的位置和左端点$l-1$的位置，两个值相减即得答案，但是要注意边界处理。对于交换，找到两个兔子的位置，直接进行交换即可，注意要把所有的信息都交换…… 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=3e5+51;vector&lt;ll&gt;rabbit[MAXN];ll cnt,ccnt,op,l,r,x,lx,rx,maxn;vector&lt;ll&gt;::iterator bg,ed;ll color[MAXN],ind[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;int main()&#123; cnt=read(),ccnt=read(); for(register int i=1;i&lt;=cnt;i++) &#123; color[i]=read(); rabbit[color[i]].push_back(i); ind[i]=rabbit[color[i]].size()-1; &#125; for(register int i=1;i&lt;=ccnt;i++) &#123; op=read(); if(op==1) &#123; l=read()-1,r=read(),x=read(); bg=rabbit[x].begin(); ed=rabbit[x].end(); if(bg==ed) &#123; puts("0"); continue; &#125; lx=lower_bound(bg,ed,l)-bg,rx=lower_bound(bg,ed,r)-bg; if(rabbit[x][lx]==l) &#123; lx++; &#125; if(rabbit[x][rx]==r) &#123; rx++; &#125; printf("%d\n",rx-lx); &#125; else &#123; x=read(); if(color[x]!=color[x+1]) &#123; rabbit[color[x]][ind[x]]=x+1; rabbit[color[x+1]][ind[x+1]]=x; swap(color[x],color[x+1]); swap(ind[x],ind[x+1]); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>模拟</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我们做过的模板 I]]></title>
    <url>%2F2018%2F11%2F08%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E5%81%9A%E8%BF%87%E7%9A%84%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
        <tag>模板</tag>
        <tag>最短路</tag>
        <tag>DijkStra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1337」[JSOI2004]平衡点 / 吊打XXX]]></title>
    <url>%2F2018%2F11%2F05%2F%E3%80%8CLuogu-P1337%E3%80%8D-JSOI2004-%E5%B9%B3%E8%A1%A1%E7%82%B9-%E5%90%8A%E6%89%93XXX%2F</url>
    <content type="text"><![CDATA[给定一些带权点，求它们的带权费马点。 链接Luogu P1337BZOJ 3680 题解这题备选的解很多，所以采用猜答案的方法模拟退火来做此题。注意下一些常数吧……我是不会告诉你我卡了7次的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e4+51;const double delta=0.997;struct Node&#123; double x,y,weight; &#125;;Node nd[MAXN];ll cnt;double resx,resy,res=1e18,t; inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll randInt()&#123; return 2*rand()-RAND_MAX;&#125; inline double potentialEnergy(double x,double y)&#123; double sum=0,xx,yy; for(register int i=0;i&lt;cnt;i++) &#123; xx=x-nd[i].x,yy=y-nd[i].y; sum+=sqrt(xx*xx+yy*yy)*nd[i].weight; &#125; return sum;&#125; inline void simulatedAnnealing()&#123; double x=resx,y=resy,rd,xx,yy,dt; t=19260; while(t&gt;1e-18) &#123; xx=resx+randInt()*t,yy=resy+randInt()*t; rd=potentialEnergy(xx,yy),dt=rd-res; if(dt&lt;0) &#123; x=xx,y=yy,resx=x,resy=y,res=rd; &#125; else &#123; if(exp(-dt/t)*RAND_MAX&gt;rand()) &#123; x=xx,y=yy; &#125; &#125; t*=delta; &#125;&#125;inline void SA(ll times)&#123; for(register int i=0;i&lt;times;i++) &#123; simulatedAnnealing(); &#125;&#125;int main()&#123; srand(time(0)); cnt=read(); for(register int i=0;i&lt;cnt;i++) &#123; nd[i].x=read(),nd[i].y=read(),nd[i].weight=read(); &#125; SA(9); printf("%.3lf %.3lf",resx,resy);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>JSOI</tag>
        <tag>随机化</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2197」【模板】nim游戏]]></title>
    <url>%2F2018%2F11%2F02%2F%E3%80%8CLuogu-P2197%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91nim%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[有$n$堆石子，第$i$堆有$a_i$个，$Alice$和$Bob$轮流取石子，$Alice$先取。每个游戏者只能取一堆石子，至少取一个，问哪个游戏者会赢。 链接Luogu P2197 题解最基础的Nim游戏，先手必赢当且仅当$a_1 \operatorname{xor} a_2 \operatorname{xor} \cdots \operatorname{xor} a_n \not = 0$，代码很短。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;ll test,cnt,res;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline ll solve()&#123; cnt=read(); for(register int i=0;i&lt;cnt;i++) &#123; res^=read(); &#125; puts(res!=0?"Yes":"No"); res=0;&#125; int main()&#123; test=read(); while(test--) &#123; solve(); &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>博弈论</tag>
        <tag>Nim游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4438」[HNOI/AHOI2018]道路]]></title>
    <url>%2F2018%2F11%2F01%2F%E3%80%8CLuogu-P4438%E3%80%8D-HNOI-AHOI2018-%E9%81%93%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[给你一颗有$2n-1$个节点的树，这一棵树的非叶节点均有两个儿子，左儿子与它连红边，右儿子与它连绿边，定义节点$i$的不便利值为$c_i\cdot(a_i+x)\cdot(b_i+y)$其中$x$表示根节点到节点$i$的未加粗红边数量，$y$表示根节点到节点$i$的未加粗绿边数量。求加粗边数量为$n-1$的所有叶节点的不便利值。 链接Luogu P4438 题解一道比较好的树形dp题。将每一个城市标号$1$到$n-1$，乡村标号$n$到$2n-1$，设$dp[i][j][k]$表示标号后的$i$号节点到根节点要走过$j$条没有翻修的公路和$k$条没有翻修的铁路最小的不便利值。设$l[i]$指的是通过公路连接$i$号结点的城市或乡村，$r[i]$指的是通过铁路连接$i$号结点的城市或乡村，那么如果$i$是乡村，直接暴力算不便利值即可，即$dp[i][j][k]=c_i\cdot(a_i+j)\cdot(b_i+k)$如果$i$是城市，因为最多翻修$n-1$条路，所以考虑对通向每一个城市的公路或铁路进行翻修。翻修通往城市$i$的公路的不便利值是$dp[l_i][j+1][k]+dp[r_i[j][k]$（因为通向$i$的铁路没翻修），铁路同理，即$dp[i][j][k]=\min(dp[l_i][j+1][k]+dp[r_i[j][k],dp[l_i[j][k]+dp[r_i][j][k+1])$所以就得到了转移方程。最后善意的提醒一句，本题卡空间，大佬们可以将$dp$的一维改成$dfn$，蒟蒻不会，只能暴力 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=4e4+51;ll cnt;ll l[MAXN],r[MAXN],lx[MAXN],rx[MAXN];ll x[MAXN],y[MAXN],z[MAXN];ll dp[MAXN][41][41];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void dfs(ll node)&#123; if(node&gt;=cnt) &#123; return; &#125; lx[l[node]]=lx[node]+1,lx[r[node]]=lx[node]; rx[r[node]]=rx[node]+1,rx[l[node]]=rx[node]; dfs(l[node]); dfs(r[node]);&#125;inline void ddp(ll node)&#123; ll lc,rc; if(node&gt;=cnt) &#123; for(register int i=0;i&lt;=lx[node];i++) &#123; for(register int j=0;j&lt;=rx[node];j++) &#123; dp[node][i][j]=1ll*(x[node]+i)*(y[node]+j)*z[node]; &#125; &#125; return; &#125; else &#123; ddp(l[node]); ddp(r[node]); for(register int i=0;i&lt;=lx[node];i++) &#123; for(register int j=0;j&lt;=rx[node];j++) &#123; lc=dp[l[node]][i][j]+dp[r[node]][i][j+1]; rc=dp[r[node]][i][j]+dp[l[node]][i+1][j]; dp[node][i][j]=min(lc,rc); &#125; &#125; &#125;&#125;int main()&#123; cnt=read(); for(register int i=1;i&lt;cnt;i++) &#123; l[i]=read(),r[i]=read(); l[i]=l[i]&lt;0?-l[i]+cnt-1:l[i],r[i]=r[i]&lt;0?-r[i]+cnt-1:r[i]; &#125; for(register int i=1;i&lt;=cnt;i++) &#123; x[i+cnt-1]=read(),y[i+cnt-1]=read(),z[i+cnt-1]=read(); &#125; dfs(1),ddp(1); printf("%lld",dp[1][0][0]);&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>各省省选</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>HNOI</tag>
        <tag>AHOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SPOJ 2713」Can you answer these queries IV]]></title>
    <url>%2F2018%2F10%2F28%2F%E3%80%8CSPOJ-2713%E3%80%8DCan-you-answer-these-queries-IV%2F</url>
    <content type="text"><![CDATA[给一段正整数构成的区间，支持区间开平方以及询问区间和。 链接SPOJ 2713 题解考虑线段树，显然区间开平方是不能用lazy\ tag的，所以我们选择暴力修改。先证明一个引理，区间最大值为1的区间进行修改是没有意义的。（这个证明算是补了一个坑）证明：由于区间内所有数是正整数，所以区间最大值为1的区间内所有数均为1，而\sqrt{1}=1，故修改区间内的值没有意义，证毕。于是我们考虑在修改区间时判断一下当前区间最大值是不是1，如果是，就没有修改的必要。如果这个节点的左右端点重合，直接修改即可，这样可以少修改许多修改了也没用的区间，至于查询还是一样的。提醒大家有多组数据，记得初始化 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;const ll MAXN=1e5+51;struct SegmentTree&#123; ll l,r,sum,maxn;&#125;;SegmentTree tree[MAXN&lt;&lt;2];ll cnt,qcnt,op,l,r,ccnt;ll num[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void update(ll node)&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum; tree[node].maxn=max(tree[node&lt;&lt;1].maxn,tree[(node&lt;&lt;1)|1].maxn);&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=tree[node].maxn=num[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void change(ll l,ll r,ll node)&#123; if(tree[node].maxn&lt;=1) &#123; return; &#125; if(tree[node].l==tree[node].r) &#123; tree[node].sum=tree[node].maxn=sqrt(tree[node].sum); return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; change(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; change(l,r,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll querySum(ll l,ll r,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,res=0; if(l&lt;=mid) &#123; res+=querySum(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; res+=querySum(l,r,(node&lt;&lt;1)|1); &#125; return res;&#125;inline ll queryMax(ll l,ll r,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].maxn; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,res=0; if(l&lt;=mid) &#123; res=max(res,queryMax(l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; res=max(res,queryMax(l,r,(node&lt;&lt;1)|1)); &#125; return res;&#125;int main()&#123; while(scanf("%lld",&amp;cnt)!=EOF) &#123; printf("Case #%lld:\n",++ccnt); for(register int i=1;i&lt;=cnt;i++) &#123; num[i]=read(); &#125; create(1,cnt,1); qcnt=read(); for(register int i=0;i&lt;qcnt;i++) &#123; op=read(),l=read(),r=read(); if(l&gt;r) &#123; swap(l,r); &#125; if(op) &#123; printf("%lld\n",querySum(l,r,1)); &#125; else &#123; if(queryMax(l,r,1)&gt;1) &#123; change(l,r,1); &#125; &#125; &#125; memset(num,0,sizeof(num)); memset(tree,0,sizeof(tree)); puts(""); &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2742」【模板】二维凸包]]></title>
    <url>%2F2018%2F10%2F21%2F%E3%80%8CLuogu-P2742%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[给定一个点集，求它的凸包的周长。 链接Luogu P2742 题解二维凸包的模板题，没有什么好说的。不会凸包的右转这里但是最后求周长是一定要算点的距离，而不是向量的长度。被卡了两次 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef double db;const ll MAXN=1e4+51;struct Point&#123; db x,y; Point(ll x=0,ll y=0) &#123; this-&gt;x=x,this-&gt;y=y; &#125; inline bool operator &lt;(const Point &amp;rhs)const &#123; return y==rhs.y?x&lt;rhs.x:y&lt;rhs.y; &#125; inline db polar() &#123; return atan2(y,x); &#125;&#125;;typedef Point Vector;Point p[MAXN];ll cnt,minn;db res;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline Vector operator +(Vector x,Vector y)&#123; return Vector(x.x+y.x,x.y+y.y);&#125;inline Vector operator -(Vector x,Vector y)&#123; return Vector(x.x-y.x,x.y-y.y);&#125;inline Vector operator *(Vector x,db y)&#123; return Vector(x.x*y,x.y*y);&#125;inline Vector operator /(Vector x,db y)&#123; return Vector(x.x/y,x.y/y);&#125;inline db dot(Vector x,Vector y)&#123; return x.x*y.x+x.y*y.y;&#125;inline db length(Vector x)&#123; return sqrt(dot(x,x));&#125;inline db angle(Vector x,Vector y)&#123; return acos(dot(x,y)/length(x)/length(y));&#125;inline db cross(Vector x,Vector y)&#123; return x.x*y.y-x.y*y.x;&#125;inline db dist(Vector x,Vector y)&#123; db xx=x.x-y.x,yy=x.y-y.y; return sqrt(xx*xx+yy*yy);&#125;inline bool cmp(Point x,Point y)&#123; double xx=cross(x-p[1],y-p[1]); if(xx&gt;0) &#123; return 1; &#125; if(!xx&amp;&amp;length(x-p[1])&lt;length(y-p[1])) &#123; return 1; &#125; return 0;&#125;inline deque&lt;Point&gt; convexHull(Point *p,ll size)&#123; Point top; deque&lt;Point&gt;vec; if(size==1) &#123; vec.push_back(p[1]); return vec; &#125; if(size==2) &#123; vec.push_back(p[1]),vec.push_back(p[2]); return vec; &#125; vec.push_back(p[1]),vec.push_back(p[2]); for(register int i=3;i&lt;=size;i++) &#123; top=vec.back(); while(cross(top-vec[vec.size()-2],p[i]-top)&lt;0) &#123; vec.pop_back(),top=vec.back(); &#125; vec.push_back(p[i]); &#125; return vec;&#125;int main()&#123; cnt=read(); p[0].x=p[0].y=100000000000.0; if(cnt==0) &#123; printf("0.00"); return 0; &#125; for(register int i=1;i&lt;=cnt;i++) &#123; scanf("%lf%lf",&amp;p[i].x,&amp;p[i].y); if(p[i]&lt;p[minn]) &#123; minn=i; &#125; &#125; swap(p[minn],p[1]),sort(p+2,p+cnt+1,cmp); deque&lt;Point&gt;pt=convexHull(p,cnt); if(pt.size()==1) &#123; printf("%.2lf",0.0); &#125; else &#123; for(register int i=1;i&lt;pt.size();i++) &#123; res+=dist(pt[i],pt[i-1]); &#125; res+=dist(pt[0],pt[pt.size()-1]); printf("%.2lf",res); &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>二维凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·二维凸包]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85%2F</url>
    <content type="text"><![CDATA[二维凸包是指一个面积最小的凸多边形，使得一个给定的点集都分布在这个凸多边形的内部或者边上。 前置技能计算几何基础，这个大概不用说了。 过程咕咕咕，这里我们使用比较好想的Graham算法进行求解。前方大图警告。首先呢，是一个点集。因为y坐标最小的点肯定在这个凸包上，所以我们先找出y坐标最小的点,记为P_1。接着考虑把剩下的点对于P_1从右往左编号。PS:截图的锅，P_{11}上面那个点是P_{12}。预处理完毕，接下来我们需要一个栈。由于P_1和P_2在凸包边界上，考虑将P_1和P_2入栈。未完成的凸包用红色线条表示。考虑P_3，加入它之后红色边界仍然是凸的，P_3入栈。接下来考虑P_4，加入它之后边界是凹的，把当前栈顶P_3出栈。考虑加入P_4当前红色边界加入P_4仍然是凸的，所以P_4入栈。由于连续加入P_5，P_6，P_7后所得的红色边界仍然是凸的，所以将它们依次入栈。在考虑P_8时，发现边界是凹的，将栈顶P_7出栈，而P_8入栈。考虑P_9。在连续出栈P_8和P_6都不能满足红色边界为凸的，所以一出栈，将P_9入栈。依次进行以下操作，可以得到一个处理到最后一个点的图像，然后就完结撒花了！所以说，code呢？对不起，没有个鬼。出门右转看代码]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>二维凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 1060C」Maximum Subrectangle]]></title>
    <url>%2F2018%2F10%2F15%2F%E3%80%8CCodeForces-1060C%E3%80%8DMaximum-Subrectangle%2F</url>
    <content type="text"><![CDATA[给一个数x，序列a和另一个序列b，构造一个矩阵c使得c_{i,j}=a_{i}\times b_{j}。在矩阵中找出一个最大的矩形使得矩形内所有数的和小于x。因为要求子矩阵的和，所以考虑二维前缀和。但是由于矩阵的特殊性质c_{i,j}=a_{i}\times b_{j}，所以可以将二维前缀和转化为两个一维前缀和的乘积。]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>前缀和</tag>
        <tag>贪心</tag>
        <tag>two pointers</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4315」月下“毛景树”]]></title>
    <url>%2F2018%2F10%2F15%2F%E3%80%8CLuogu-P4315%E3%80%8D%E6%9C%88%E4%B8%8B%E6%AF%9B%E6%99%AF%E6%A0%91%2F</url>
    <content type="text"><![CDATA[给一棵树，支持修改边上的权值，将两点间路经全部增加k或全部覆盖为k，多次求当前树上两点间路径上的边权最大值。 链接Luogu P4315 题解我不会告诉你这道毒瘤题我调了两个月吐槽一下毒瘤出题人，这份代码我足足写了297行，无语……好吧当时交题的时候并没有把求lca删掉此题一眼看过去是树剖+边权下放，把边权下放之后就是普通的树剖。这里还有个奇淫技巧，就是在最后修改与查询时，为了不统计LCA，将id[x]改成id[x]+1，具体看注释。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,maxn,tag,cover;&#125;;const ll MAXN=2e5+51; edge ed[MAXN];SegmentTree tree[MAXN&lt;&lt;2];ll last[MAXN],val[MAXN],depth[MAXN],fa[MAXN],size[MAXN],heavy[MAXN];ll id[MAXN],pre[MAXN],top[MAXN],from[MAXN],to[MAXN],dist[MAXN];ll tot,nc,ccnt,tx,x,y,z;string op;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;inline void update(ll node)&#123; tree[node].maxn=max(tree[node&lt;&lt;1].maxn,tree[(node&lt;&lt;1)|1].maxn);&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r,tree[node].cover=-1; if(l==r) &#123; tree[node].maxn=val[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void spread(ll node)&#123; if(tree[node].cover!=-1) &#123; tree[node&lt;&lt;1].maxn=tree[node].cover; tree[(node&lt;&lt;1)|1].maxn=tree[node].cover; tree[node&lt;&lt;1].cover=tree[node].cover; tree[(node&lt;&lt;1)|1].cover=tree[node].cover; tree[node&lt;&lt;1].tag=tree[(node&lt;&lt;1)|1].tag=0; tree[node].cover=-1; &#125; if(tree[node].tag) &#123; tree[node&lt;&lt;1].maxn+=tree[node].tag; tree[(node&lt;&lt;1)|1].maxn+=tree[node].tag; tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; tree[node].tag=0; &#125;&#125;inline void change(ll pos,ll val,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].maxn=val; return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; spread(node); if(pos&lt;=mid) &#123; change(pos,val,node&lt;&lt;1); &#125; else &#123; change(pos,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline void cover(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].maxn=val; tree[node].cover=val; tree[node].tag=0; return; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; cover(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; cover(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].maxn+=val; tree[node].tag+=val; return; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll queryMax(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].maxn; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=-(1&lt;&lt;30); if(l&lt;=mid) &#123; val=max(val,queryMax(l,r,node&lt;&lt;1)); &#125; if(r&gt;mid) &#123; val=max(val,queryMax(l,r,(node&lt;&lt;1)|1)); &#125; return val;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1; ll maxn=-1; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f) &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to]; if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to]; &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link; if(!heavy[node]) &#123; return; &#125; ddfs(heavy[node],link); for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to); &#125; &#125;&#125;inline ll queryPathMax(ll x,ll y)&#123; ll ans=-(1&lt;&lt;30); while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans=max(ans,queryMax(id[top[x]],id[x],1)); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans=max(ans,queryMax(id[x]+1,id[y],1));// return ans;&#125;inline void changePoint(ll x,ll y)&#123; change(id[x],y,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x]+1,id[y],val,1);//&#125;inline void coverPath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; cover(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; cover(id[x]+1,id[y],val,1);//&#125;int main()&#123; nc=read(); for(register int i=0;i&lt;nc-1;i++) &#123; from[i]=read(),to[i]=read(),dist[i]=read(); addEdge(from[i],to[i]),addEdge(to[i],from[i]); &#125; dfs(1,0,1),ddfs(1,1),create(1,nc,1); for(register int i=0;i&lt;nc-1;i++) &#123; changePoint(depth[from[i]]&gt;depth[to[i]]?from[i]:to[i],dist[i]); &#125; while(cin&gt;&gt;op,op!="Stop") &#123; if(op=="Max") &#123; x=read(),y=read(); cout&lt;&lt;queryPathMax(x,y)&lt;&lt;endl; &#125; if(op=="Change") &#123; x=read(),y=read(); tx=depth[from[x-1]]&gt;depth[to[x-1]]?from[x-1]:to[x-1]; changePoint(tx,y); &#125; if(op=="Add") &#123; x=read(),y=read(),z=read(); changePath(x,y,z); &#125; if(op=="Cover") &#123; x=read(),y=read(),z=read(); coverPath(x,y,z); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018之前的琐记]]></title>
    <url>%2F2018%2F10%2F09%2FNOIP2018%E4%B9%8B%E5%89%8D%E7%9A%84%E7%90%90%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[既然Karry5307已经变成了初二的小蒟蒻了，那么还是写点NOIP2018之前的琐记吧。 考试2018.10.8：出题人xzy，毒瘤题。T1什么鬼，7合1，gg。T3辣鸡模拟，让你算空间，最后交卷时发现bitset没开long\ long，写了个快速乘\% 998244353，读入出锅了，居然没看到有个空格没搞好，0+0+10=10分滚粗。（我不会告诉你我是因为没看大样例而导致的） 2018.10.9：出题人Despair，毒瘤题。第一题什么鬼，yyb大佬说是迭代，结果还真的是迭代（顺便吐槽一句，题解写的矩乘看都没看懂）T3随手开了个10^7的数组，MLE了。 2018.10.10：出题人Tyher，这次我觉得海星。T1被卡精度原地爆炸，log_{10}改成log_2就会有35分的好成绩啦，T3良心，Task\ 4特判了一下，其余线段树乱搞还有40分，拿了20+40+25=85分滚粗，yyb大佬太强了，又阿克了。 2018.10.11：T1毒瘤三合一，布星啊，墙裂谴责，乱搞还没分，幸好T2乱搞有20分。T3全场切except\ me，告辞告辞，0+20+0=20滚粗。 2018.10.12：出题人DarkFire，题目海星，只是我太蒟蒻了，连T2都没切。Despair大佬又阿克了，%%%，我这个小蒟蒻继续0+20+0=20滚粗。 2018.10.13：上午初赛模拟，什么鬼，一个排完序后的水题硬是考递归，体验极差。(最近有点懒，没更) 2018.10.26：T1不会莫比乌斯反演，被吊打，只好拿20分滚粗。T2不会写，跳过。T3居然还下放了一个game，什么鬼，最后才知道这game考有限状态自动机，我太蒻了，居然没玩通关，苟且21分。总共20+0+21=41分滚粗。tbr大佬玩个游戏T3都拿了66分，我竟无言以对。我突然觉得我连游戏都不会玩了]]></content>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4884」多少个1？]]></title>
    <url>%2F2018%2F10%2F07%2F%E3%80%8CLuogu-P4884%E3%80%8D%E5%A4%9A%E5%B0%91%E4%B8%AA1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[给定p和模数yyb，保证yyb为质数，求最小的x使得$111\cdots 1$(x个)\equiv 1\pmod {yyb} 链接Luogu P4884 题解注意到111\cdots 1(x个)=\cfrac{10^x-1}{9},则 111\cdots 1\equiv (10^x-1)\times 9^{-1}\therefore (10^x-1)\times 9^{-1}\equiv yyb\therefore 10^x \equiv 9\times yyb+1然后这个方程就化为BSGS的标准形式了，由于模数yyb为质数，直接利用BSGS即可。由于yyb会很大，所以再次建议不要用自己写的哈希表，而使用map。我是不会告诉你我因为这个原因被洛谷的数据坑了好几次了 代码为了保险，这里开了int128，美中不足的是要自己写读写，顺便写了一个O(1)的龟速乘。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef __int128 ll;map&lt;ll,ll&gt;ht;ll mod,val;inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void write(ll num)&#123; if(num&gt;9) &#123; write(num/10); &#125; putchar(num%10+'0');&#125;inline ll qmul(ll x,ll y,ll mod)&#123; ll l=(y&gt;&gt;25)*x%mod*((1&lt;&lt;25)%mod),r=(y&amp;((1&lt;&lt;25)-1))*x%mod; return (l+r)%mod;&#125;inline ll qpow(ll base,ll exponent,ll mod)&#123; if(!exponent) &#123; return 1; &#125; ll temp=qpow(base,exponent&gt;&gt;1,mod); ll res=qmul(temp,temp,mod); if(exponent&amp;1) &#123; res=qmul(res,base,mod); &#125; return res;&#125;inline ll BSGS(ll base,ll res,ll mod)&#123; ht.clear(),res%=mod; ll temp,val,fail; temp=sqrt((long double)(mod))+1; for(register int i=0;i&lt;temp;i++) &#123; val=qmul(res,qpow(base,i,mod),mod); ht[val]=i; &#125; base=qpow(base,temp,mod); if(!base) &#123; return !res?1:-1; &#125; for(register int i=0;i&lt;=temp;i++) &#123; val=qpow(base,i,mod),fail=ht.find(val)==ht.end()?-1:ht[val]; if(fail&gt;=0&amp;&amp;i*temp-fail&gt;=0) &#123; return i*temp-fail; &#125; &#125; return -1;&#125;int main()&#123; val=read(),mod=read(); val=(qmul(9,val,mod)+1)%mod; write(BSGS(10,val,mod));&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>数论</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2756」飞行员配对方案问题]]></title>
    <url>%2F2018%2F09%2F24%2F%E3%80%8CLuogu-P2756%E3%80%8D%E9%A3%9E%E8%A1%8C%E5%91%98%E9%85%8D%E5%AF%B9%E6%96%B9%E6%A1%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这个题是网络流24题中的第1题。给一个二分图，求最大匹配以及匹配方案。 链接Luogu P2756 题解这个题目的模型是二分图最大匹配，有多个源点和汇点。所以可以增加一个超级源点和一个超级汇点。超级源点1与2-(m+1)连流量为1的边；(m+2)-(n+1)与超级汇点n+2连流量为1的边；所给的边全部连流量为1的边。最后，这个网络的最大流即为二分图的最大匹配。对于每一条在二分图内的边，即它和它的反向边不连向源点和汇点，如果反向边有流量，就输出这条边连向的两个点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll MAXN=1e5+51,inf=0x7fffffff;struct Edge&#123; ll to,prev,flow;&#125;;Edge ed[MAXN&lt;&lt;1];ll l,nc,source,sink,tot=1,from,to,flow,maxFlow;ll last[MAXN],depth[MAXN],inQueue[MAXN];inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to,ll flow)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; ed[tot].flow=flow; last[from]=tot; &#125;inline ll Min(ll x,ll y)&#123; return x&lt;y?x:y;&#125;inline bool bfs()&#123; queue&lt;ll&gt;q; ll top,to; memset(depth,0x3f,sizeof(depth)); depth[source]=0,q.push(source); while(!q.empty()) &#123; top=q.front(); q.pop(),inQueue[top]=0; for(register int i=last[top];i;i=ed[i].prev) &#123; to=ed[i].to; if(depth[to]&gt;depth[top]+1&amp;&amp;ed[i].flow) &#123; depth[to]=depth[top]+1; if(!inQueue[to]) &#123; q.push(to),inQueue[to]=1; &#125; &#125; &#125; &#125; if(depth[sink]!=0x3f3f3f3f) &#123; return 1; &#125; return 0;&#125;inline ll dfs(ll cur,ll flow)&#123; ll low; if(cur==sink) &#123; return flow; &#125; for(register int i=last[cur];i;i=ed[i].prev) &#123; if(ed[i].flow&amp;&amp;depth[ed[i].to]==depth[cur]+1) &#123; if(low=dfs(ed[i].to,Min(flow,ed[i].flow))) &#123; ed[i].flow-=low,ed[i^1].flow+=low; return low; &#125; &#125; &#125; return 0;&#125;inline ll Dinic()&#123; ll flow; while(bfs()) &#123; while(flow=dfs(source,inf)) &#123; maxFlow+=flow; &#125; &#125; return maxFlow;&#125;int main()&#123; l=read(),nc=read(),source=1,sink=nc+2; while(1) &#123; from=read()+1,to=read()+1; if(!from||!to) &#123; break; &#125; addEdge(from,to,1),addEdge(to,from,0); &#125; for(register int i=2;i&lt;=l+1;i++) &#123; addEdge(source,i,1),addEdge(i,source,0); &#125; for(register int i=l+2;i&lt;=nc+1;i++) &#123; addEdge(i,sink,1),addEdge(sink,i,0); &#125; if(Dinic()==0) &#123; puts("No solution!"); &#125; else &#123; printf("%d\n",maxFlow); for(register int i=2;i&lt;=tot;i+=2) &#123; if(ed[i].to!=source&amp;&amp;ed[i^1].to!=source&amp;&amp;ed[i].to!=sink&amp;&amp;ed[i^1].to!=sink) &#123; if(ed[i^1].flow) &#123; printf("%d %d\n",ed[i^1].to-1,ed[i].to-1); &#125; &#125; &#125; &#125; &#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>二分图匹配</tag>
        <tag>Dinic</tag>
        <tag>网络流24题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3376」【模板】网络最大流]]></title>
    <url>%2F2018%2F09%2F24%2F%E3%80%8CLuogu-P3376%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"></content>
      <tags>
        <tag>未完待续</tag>
        <tag>洛谷</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·网络流]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[网络流是一种解决各种神仙问题的算法，通过合理地建图，可以解决各类神仙问题。网络流的概念也许会有点难懂，于是就先上几幅图，借助水流理解。众所周知，你家的水是从自来水厂通过管道流过来的，假设s是自来水厂，t是你家，1,2,3是中转节点，管道连接如图所示。每条边上的边权是该管道允许的最大流量，即容量，如果流进来的水流流量超过容量，管道就会炸掉，这既不是自来水厂所期望的事，也不是你家所期望的事。现在，你希望自来水厂到你家的水最多，所以尝试找出一条s-&gt;t路径，比如这个对于这条路径，可以通过的可行流为10，所以将这些边的可行流-10，像这样：对于这个网络，一次一次找s-&gt;t路径是可以得到最大流的，但对于别的网络呢？流错了怎么办？这里给一个神仙技巧——加反向边，像这样]]></content>
      <tags>
        <tag>未完待续</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>Dinic</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3950」部落冲突]]></title>
    <url>%2F2018%2F09%2F14%2F%E3%80%8CLuogu-P3950%E3%80%8D%E9%83%A8%E8%90%BD%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[给一棵树，每次可以使一条可以经过边设置为不可经过，也可以将不可经过的边设置成可以经过，多次询问两点间路径上的所有边是否都可以经过。 链接Luogu P3950 题解我不会告诉你这题我调了10天将可以经过转换成0，不可经过转换成1，然后树剖+边权下放。对于每次询问，考虑两点间路径上的点权和减去LCA的点权是否等于0即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,sum,tag;&#125;;struct battle&#123; ll x,y;&#125;;const ll MAXN=700051;battle bt[MAXN];edge ed[MAXN];SegmentTree tree[MAXN&lt;&lt;1];ll last[MAXN],val[MAXN],depth[MAXN],fa[MAXN],size[MAXN],heavy[MAXN];ll id[MAXN],pre[MAXN],top[MAXN];ll tot,nc,cnt,ccnt,x,y,from,to,num,toto,tx;char op; inline ll read()&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;inline void update(ll node)&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum;&#125;inline void create(ll l,ll r,ll node)&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=val[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1); create(mid+1,r,(node&lt;&lt;1)|1); update(node);&#125;inline void spread(ll node)&#123; if(tree[node].tag) &#123; tree[node&lt;&lt;1].sum+=tree[node].tag*(tree[node&lt;&lt;1].r-tree[node&lt;&lt;1].l+1); tree[(node&lt;&lt;1)|1].sum+=tree[node].tag*(tree[(node&lt;&lt;1)|1].r-tree[(node&lt;&lt;1)|1].l+1); tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; tree[node].tag=0; &#125;&#125;inline void change(ll pos,ll val,ll node)&#123; if(tree[node].l==tree[node].r) &#123; tree[node].sum+=val; return; &#125; ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(pos&lt;=mid) &#123; change(pos,val,node&lt;&lt;1); &#125; else &#123; change(pos,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum+=val*(tree[node].r-tree[node].l+1); tree[node].tag+=val; return; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll query(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; spread(node); ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=0; if(l&lt;=mid) &#123; val+=query(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; val+=query(l,r,(node&lt;&lt;1)|1); &#125; return val;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1; ll maxn=-1; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f) &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to]; if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to]; &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link; if(!heavy[node]) &#123; return; &#125; ddfs(heavy[node],link); for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to); &#125; &#125;&#125;inline ll queryPath(ll x,ll y)&#123; ll ans=0; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans+=query(id[top[x]],id[x],1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans+=query(id[x],id[y],1); return ans;&#125;inline ll querySubtree(ll root)&#123; return query(id[root],id[root]+size[root]-1,1);&#125;inline void changePoint(ll x,ll val)&#123; change(id[x],val,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x],id[y],val,1);&#125;inline void changeSubtree(ll root,ll val)&#123; add(id[root],id[root]+size[root]-1,val,1);&#125;inline ll lca(ll x,ll y)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; x=fa[top[x]]; &#125; return depth[x]&lt;depth[y]?x:y;&#125;int main()&#123; nc=read(),cnt=read(); for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(); addEdge(from,to),addEdge(to,from); &#125; dfs(1,0,1),ddfs(1,1),create(1,nc,1); for(register int i=0;i&lt;cnt;i++) &#123; cin&gt;&gt;op; switch(op) &#123; case 'C':&#123; x=read(),y=read(); bt[++num].x=x,bt[num].y=y; tx=depth[x]&gt;depth[y]?x:y; changePoint(tx,1); break; &#125; case 'U':&#123; x=read(); y=bt[x].y,x=bt[x].x; tx=depth[x]&gt;depth[y]?x:y; changePoint(tx,-1); break; &#125; case 'Q':&#123; x=read(),y=read(); toto=queryPath(x,y)-queryPath(lca(x,y),lca(x,y)); toto?puts("No"):puts("Yes"); break; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P4114」Qtree1]]></title>
    <url>%2F2018%2F08%2F16%2F%E3%80%8CLuogu-P4114%E3%80%8DQtree1%2F</url>
    <content type="text"><![CDATA[怎么说呢，有点裸的树链剖分加上一些常用小技巧…… 链接Luogu P3950]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>未完待续</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3178」[HAOI2015]树上操作]]></title>
    <url>%2F2018%2F08%2F14%2F%E3%80%8CHAOI2015%E3%80%8D%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[给定一棵树和多个操作，对于每一个操作3，回答该询问的答案。 链接Luogu P3178BZOJ 4034 题解树链剖分板子题。对于每一个1操作，直接将起点和终点设为这个点，执行路径修改。对于操作2和操作3，直接使用树剖板子。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,sum,tag;&#125;;edge ed[200051];SegmentTree tree[200051&lt;&lt;2];ll last[200051],val[200051],depth[200051],fa[200051],size[200051],heavy[200051];ll id[200051],pre[200051],top[200051];ll tot,nc,cnt,ccnt,op,x,y,from,to;inline ll read()//快读&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)//邻接表基本操作&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;//线段树基本操作inline void update(ll node)//更新节点值，用位运算优化&#123; tree[node].sum=tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum;&#125;inline void create(ll l,ll r,ll node)//建树&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=val[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1);//建左子树 create(mid+1,r,(node&lt;&lt;1)|1);//建右子树 update(node);//更新当前节点&#125;inline void spread(ll node)//下传懒标记&#123; if(tree[node].tag) &#123; //更新节点信息 tree[node&lt;&lt;1].sum+=tree[node].tag*(tree[node&lt;&lt;1].r-tree[node&lt;&lt;1].l+1); tree[(node&lt;&lt;1)|1].sum+=tree[node].tag*(tree[(node&lt;&lt;1)|1].r-tree[(node&lt;&lt;1)|1].l+1); //下传懒标记 tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; //清除当前节点懒标记 tree[node].tag=0; &#125;&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum+=val*(tree[node].r-tree[node].l+1); //做标记 tree[node].tag+=val; return; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll query(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=0; if(l&lt;=mid) &#123; val+=query(l,r,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; val+=query(l,r,(node&lt;&lt;1)|1); &#125; return val;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1;//更新节点深度，父节点，节点为根的子树大小 ll maxn=-1;//重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f)//遍历子节点 &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to];//更新子树大小 if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to];//标记重儿子 &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link;//标记节点新编号，赋初始值，更新节点所在重链的顶部 if(!heavy[node])//连重儿子都没有，肯定没有轻儿子，回溯 &#123; return; &#125; ddfs(heavy[node],link);//先遍历重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to);//遍历轻儿子，该节点所在重链顶部节点为自己 &#125; &#125;&#125;//无脑操作inline ll queryPath(ll x,ll y)//查询路径点权和&#123; ll ans=0; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans+=query(id[top[x]],id[x],1);//加上整个链的点权和 x=fa[top[x]];//爬到链顶 &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans+=query(id[x],id[y],1); return ans;&#125;inline ll querySubtree(ll root)&#123; return query(id[root],id[root]+size[root]-1,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x],id[y],val,1);&#125;inline void changeSubtree(ll root,ll val)&#123; add(id[root],id[root]+size[root]-1,val,1);&#125;int main()&#123; nc=read(),cnt=read(); for(register int i=1;i&lt;=nc;i++) &#123; pre[i]=read(); &#125; for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(); addEdge(from,to),addEdge(to,from); &#125; dfs(1,0,1),ddfs(1,1),create(1,nc,1); for(register int i=0;i&lt;cnt;i++) &#123; op=read(); switch(op) &#123; case 1:&#123; x=read(),y=read(); changePath(x,x,y); break; &#125; case 2:&#123; x=read(),y=read(); changeSubtree(x,y); break; &#125; case 3:&#123; x=read(); cout&lt;&lt;queryPath(x,1)&lt;&lt;endl; break; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>各省省选</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3384」【模板】树链剖分]]></title>
    <url>%2F2018%2F08%2F13%2F%E3%80%8CLuogu-P3384%E3%80%8D%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[模板题，裸的树链剖分，数组记得开大一倍，否则会WA3个点 链接Luogu P3384 代码代码有点长qwq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long int ll;struct edge&#123; ll to,prev;&#125;;struct SegmentTree&#123; ll l,r,sum,tag;&#125;;edge ed[200051];SegmentTree tree[200051&lt;&lt;2];ll last[200051],val[200051],depth[200051],fa[200051],size[200051],heavy[200051];ll id[200051],pre[200051],top[200051];ll tot,nc,cnt,root,ccnt,mod,op,x,y,z,from,to;inline ll read()//快读&#123; register ll num=0,neg=1; register char ch=getchar(); while(!isdigit(ch)&amp;&amp;ch!='-') &#123; ch=getchar(); &#125; if(ch=='-') &#123; neg=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;3)+(num&lt;&lt;1)+(ch-'0'); ch=getchar(); &#125; return num*neg;&#125;inline void addEdge(ll from,ll to)//邻接表基本操作&#123; ed[++tot].prev=last[from]; ed[tot].to=to; last[from]=tot;&#125;//线段树基本操作inline void update(ll node)//更新节点值，用位运算优化&#123; tree[node].sum=(tree[node&lt;&lt;1].sum+tree[(node&lt;&lt;1)|1].sum)%mod;&#125;inline void create(ll l,ll r,ll node)//建树&#123; tree[node].l=l,tree[node].r=r; if(l==r) &#123; tree[node].sum=val[l]%mod; return; &#125; ll mid=(l+r)&gt;&gt;1; create(l,mid,node&lt;&lt;1);//建左子树 create(mid+1,r,(node&lt;&lt;1)|1);//建右子树 update(node);//更新当前节点&#125;inline void spread(ll node)//下传懒标记&#123; if(tree[node].tag) &#123; //更新节点信息 tree[node&lt;&lt;1].sum+=tree[node].tag*(tree[node&lt;&lt;1].r-tree[node&lt;&lt;1].l+1); tree[(node&lt;&lt;1)|1].sum+=tree[node].tag*(tree[(node&lt;&lt;1)|1].r-tree[(node&lt;&lt;1)|1].l+1); tree[node&lt;&lt;1].sum%=mod; tree[(node&lt;&lt;1)|1].sum%=mod; //下传懒标记 tree[node&lt;&lt;1].tag+=tree[node].tag; tree[(node&lt;&lt;1)|1].tag+=tree[node].tag; tree[node&lt;&lt;1].tag%=mod; tree[(node&lt;&lt;1)|1].tag%=mod; //清除当前节点懒标记 tree[node].tag=0; &#125;&#125;inline void add(ll l,ll r,ll val,ll node)&#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; tree[node].sum+=val*(tree[node].r-tree[node].l+1); //做标记 tree[node].tag+=val; return; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1; if(l&lt;=mid) &#123; add(l,r,val,node&lt;&lt;1); &#125; if(r&gt;mid) &#123; add(l,r,val,(node&lt;&lt;1)|1); &#125; update(node);&#125;inline ll query(ll l,ll r,ll node) &#123; if(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r) &#123; return tree[node].sum%mod; &#125; spread(node);//标记下传 ll mid=(tree[node].l+tree[node].r)&gt;&gt;1,val=0; if(l&lt;=mid) &#123; val+=query(l,r,node&lt;&lt;1); val%=mod; &#125; if(r&gt;mid) &#123; val+=query(l,r,(node&lt;&lt;1)|1); val%=mod; &#125; return val%mod;&#125;inline void dfs(ll node,ll f,ll dep)&#123; depth[node]=dep,fa[node]=f,size[node]=1;//更新节点深度，父节点，节点为根的子树大小 ll maxn=-1;//重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=f)//遍历子节点 &#123; dfs(ed[i].to,node,dep+1); size[node]+=size[ed[i].to];//更新子树大小 if(size[ed[i].to]&gt;maxn) &#123; heavy[node]=ed[i].to,maxn=size[ed[i].to];//标记重儿子 &#125; &#125; &#125;&#125;inline void ddfs(ll node,ll link)&#123; id[node]=++ccnt,val[ccnt]=pre[node],top[node]=link;//标记节点新编号，赋初始值，更新节点所在重链的顶部 if(!heavy[node])//连重儿子都没有，肯定没有轻儿子，回溯 &#123; return; &#125; ddfs(heavy[node],link);//先遍历重儿子 for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to!=fa[node]&amp;&amp;ed[i].to!=heavy[node]) &#123; ddfs(ed[i].to,ed[i].to);//遍历轻儿子，该节点所在重链顶部节点为自己 &#125; &#125;&#125;//无脑操作inline ll queryPath(ll x,ll y)//查询路径点权和&#123; ll ans=0; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; ans+=query(id[top[x]],id[x],1)%mod;//加上整个链的点权和 x=fa[top[x]];//爬到链顶 &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; ans+=query(id[x],id[y],1)%mod; return ans;&#125;inline ll querySubtree(ll root)&#123; return query(id[root],id[root]+size[root]-1,1);&#125;inline void changePath(ll x,ll y,ll val)&#123; while(top[x]!=top[y]) &#123; if(depth[top[x]]&lt;depth[top[y]]) &#123; swap(x,y); &#125; add(id[top[x]],id[x],val,1); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; add(id[x],id[y],val,1);&#125;inline void changeSubtree(ll root,ll val)&#123; add(id[root],id[root]+size[root]-1,val,1);&#125;int main()&#123; nc=read(),cnt=read(),root=read(),mod=read(); for(register int i=1;i&lt;=nc;i++) &#123; pre[i]=read(); &#125; for(register int i=0;i&lt;nc-1;i++) &#123; from=read(),to=read(); addEdge(from,to),addEdge(to,from); &#125; dfs(root,0,1),ddfs(root,root),create(1,nc,1); for(register int i=0;i&lt;cnt;i++) &#123; op=read(); switch(op) &#123; case 1:&#123; x=read(),y=read(),z=read(); changePath(x,y,z%mod); break; &#125; case 2:&#123; x=read(),y=read(); cout&lt;&lt;queryPath(x,y)%mod&lt;&lt;endl; break; &#125; case 3:&#123; x=read(),y=read(); changeSubtree(x,y%mod); break; &#125; case 4:&#123; x=read(); cout&lt;&lt;querySubtree(x)%mod&lt;&lt;endl; break; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记·树链剖分]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B7%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[树链剖分是一种将一颗树通过划分不相交的来维护树上路径信息的算法。它保证每一个点仅在一个链上，并通过毒瘤数据结构来维护节点信息。树链剖分是干什么用的呢？很简单，借助树链剖分，可以任意修改树上两点最短路径的点权和子树点权，根本用不着树上差分。如果这棵树是一条链，支持修改和查询，那么我们可以重新按深度编号，这样子每棵子树上的编号都是连续的了，就可以用毒瘤数据结构来解决。但是，事实上，连洛谷模板的样例都不是一条链。尽管有人说可以用LCA+树上差分过，但你觉得数据可能是纯随机的么qwq。所以说，我们应该用树链剖分。 前置技能第一个是刚才标粗的毒瘤数据结构，树链剖分是依靠毒瘤数据结构，比如线段树，树状数组，平衡树等来修改和查询，否则就GG了……第二个是LCA，即最近公共祖先。第三个是树的DFS序，这个有什么用后面会讲。]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>未完待续</tag>
        <tag>树链剖分</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2002」消息扩散]]></title>
    <url>%2F2018%2F08%2F11%2F%E3%80%8CLuogu-P2002%E3%80%8D%E6%B6%88%E6%81%AF%E6%89%A9%E6%95%A3%2F</url>
    <content type="text"><![CDATA[给出一个有向图，消息沿着边扩散，求最少需要在几个点发消息才能使整个图所有点都得到消息。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[500001],scc[500001];ll test,tot,num,top,cnt,nc,ec,ans;ll last[500001],sccLast[500001],dfn[500001],low[500001],ins[500001],belong[500001];ll from[500001],to[500001],size[500001],in[500001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void addSCC(ll from,ll to)&#123; scc[++tot].to=to; scc[tot].prev=sccLast[from]; sccLast[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;inline void mergePoint()&#123; tot=0; for(register int i=0;i&lt;ec;i++) &#123; if(belong[from[i]]!=belong[to[i]]) &#123; addSCC(belong[from[i]],belong[to[i]]); in[belong[to[i]]]++; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;nc&gt;&gt;ec; for(register int i=0;i&lt;ec;i++) &#123; cin&gt;&gt;from[i]&gt;&gt;to[i]; addEdge(from[i],to[i]); &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; mergePoint(); for(register int i=1;i&lt;=cnt;i++) &#123; if(!in[i]) &#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>未完待续</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 402E」Strictly Positive Matrix]]></title>
    <url>%2F2018%2F08%2F11%2F%E3%80%8CCodeForces-402E%E3%80%8DStrictly-Positive-Matrix%2F</url>
    <content type="text"><![CDATA[给你一个$n*n$大小的矩阵，问你是否有一个正整数$k$使得这个矩阵的$k$次幂均为正数。未完，贴代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[5000001];ll tot,num,dist,top,cnt,nc;ll last[5000001],dfn[5000001],low[5000001],ins[5000001],belong[5000001],size[5000001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;int main()&#123; scanf("%d",&amp;nc); for(register int i=0;i&lt;nc;i++) &#123; for(register int j=0;j&lt;nc;j++) &#123; scanf("%d",&amp;dist); if(dist) &#123; addEdge(i+1,j+1); &#125; &#125; &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; cnt==1?printf("YES\n"):printf("NO\n");&#125;]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>邻接矩阵</tag>
        <tag>未完待续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P2341」[HAOI2006]受欢迎的牛]]></title>
    <url>%2F2018%2F08%2F09%2F%E3%80%8CHAOI2006%E3%80%8D%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[给定一个有向图，找出与其他点均可达的点的个数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[150001],scc[150001];ll sccno,tot,num,top,cnt,nc,ec,ans;ll last[150001],sccLast[150001],dfn[150001],low[150001],ins[150001],belong[150001];ll from[150001],to[150001],size[150001],out[150001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void addSCC(ll from,ll to)&#123; scc[++tot].to=to; scc[tot].prev=sccLast[from]; sccLast[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;inline void mergePoint()&#123; tot=0; for(register int i=0;i&lt;ec;i++) &#123; if(belong[from[i]]!=belong[to[i]]) &#123; addSCC(belong[from[i]],belong[to[i]]); out[belong[from[i]]]++; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;nc&gt;&gt;ec; for(register int i=0;i&lt;ec;i++) &#123; cin&gt;&gt;from[i]&gt;&gt;to[i]; addEdge(from[i],to[i]); &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; mergePoint(); for(register int i=1;i&lt;=cnt;i++) &#123; if(!out[i]) &#123; ans++; sccno=i; &#125; &#125; if(ans!=1) &#123; cout&lt;&lt;0; &#125; else &#123; cout&lt;&lt;size[sccno]; &#125;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>洛谷</tag>
        <tag>BZOJ</tag>
        <tag>HAOI</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVa 11324」The Largest Clique]]></title>
    <url>%2F2018%2F08%2F08%2F%E3%80%8CUVa-11324%E3%80%8DThe-Largest-Clique%2F</url>
    <content type="text"><![CDATA[给定一个有向图，找出一个子图使得对于该子图的任意两个点$u$,$v$,$u$可以到达$v$或$v$可以到达$u$,判断这样的最大子图的节点个数。 链接登不了UVa，只能用洛谷的链接惹qwqUVa 11324 题解求出图中的强连通分量，缩点，变成DAG。每一个点给一个权值，权值设为每个强连通分量的结点数。最后用记忆化搜索给出最长路。求最长路时写炸了，输入居然可以决定最长路的总权值 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev;&#125;;edge ed[150001],scc[150001];ll test,tot,num,top,cnt,nc,ec,ans;ll last[150001],sccLast[150001],dfn[150001],low[150001],ins[150001],belong[150001];ll from[150001],to[150001],size[150001],dp[150001];stack&lt;ll&gt;st;inline void addEdge(ll from,ll to)&#123; ed[++tot].to=to; ed[tot].prev=last[from]; last[from]=tot;&#125;inline void addSCC(ll from,ll to)&#123; scc[++tot].to=to; scc[tot].prev=sccLast[from]; sccLast[from]=tot;&#125;inline void tarjan(ll node)&#123; dfn[node]=low[node]=++num; st.push(node),ins[node]=1; ll flag=0,to; for(register int i=last[node];i;i=ed[i].prev) &#123; to=ed[i].to; if(!dfn[to]) &#123; tarjan(to); low[node]=min(low[node],low[to]); &#125; else &#123; if(ins[to]) &#123; low[node]=min(low[node],dfn[to]); &#125; &#125; &#125; if(dfn[node]==low[node]) &#123; cnt++; ll nd; do &#123; nd=st.top(),st.pop(); ins[nd]=0; belong[nd]=cnt; size[cnt]++; &#125; while(node!=nd); &#125;&#125;inline void mergePoint()&#123; tot=0; for(register int i=0;i&lt;ec;i++) &#123; if(belong[from[i]]!=belong[to[i]]) &#123; addSCC(belong[from[i]],belong[to[i]]); &#125; &#125;&#125;inline void search(ll node)&#123; if(dp[node]) &#123; return; &#125; dp[node]=size[node]; ll maxn=0; for(register int i=sccLast[node];i;i=scc[i].prev) &#123; if(!dp[scc[i].to]) &#123; search(scc[i].to); &#125; maxn=max(maxn,dp[scc[i].to]); &#125; dp[node]+=maxn;&#125;int main()&#123; cin&gt;&gt;test; for(register int i=0;i&lt;test;i++) &#123; cin&gt;&gt;nc&gt;&gt;ec; for(register int i=0;i&lt;ec;i++) &#123; cin&gt;&gt;from[i]&gt;&gt;to[i]; addEdge(from[i],to[i]); &#125; for(register int i=1;i&lt;=nc;i++) &#123; if(!dfn[i]) &#123; tarjan(i); &#125; &#125; mergePoint(); for(register int i=1;i&lt;=cnt;i++) &#123; if(!dp[i]) &#123; search(i); ans=max(ans,dp[i]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; tot=num=top=cnt=nc=ec=ans=0; memset(last,0,sizeof(last)); memset(sccLast,0,sizeof(sccLast)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(ins,0,sizeof(ins)); memset(belong,0,sizeof(belong)); memset(from,0,sizeof(from)); memset(to,0,sizeof(to)); memset(size,0,sizeof(size)); memset(dp,0,sizeof(dp)); for(register int i=0;i&lt;150001;i++) &#123; ed[i].prev=ed[i].to=scc[i].prev=scc[i].to=0; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>UVa</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P3128」最大流]]></title>
    <url>%2F2018%2F08%2F08%2F%E3%80%8CLuogu-P3128%E3%80%8D%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[给出一棵树和一些操作，每次操作都将两点间所有经过的点的点权+1，求出点权最大的点的权值。 链接Luogu P3128 题解怎么说呢，一道树上点差分模板题，当然树链剖分也可以做。定义$diff[i]$为点$i$的差分值，那么对于每一次修改的参数$start$和$end$，将$diff[start++,diff[end++,diff[\operatorname{lca}(start,end)—]$。为了不让路线修改蔓延到祖先，把LCA的父节点的差分值-1。最后用DFS求出子树差分数组的和就得到该节点修改后的点权啦。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev; &#125;;ll nc,ec,query,root,from,to;ll depth[500010],anc[500010][31],last[500010],diff[500010],LCA,maxn;edge ed[500010*2];inline void addEdge(ll from,ll to)&#123; ed[++ec].prev=last[from]; ed[ec].to=to; last[from]=ec;&#125;inline void dfs(ll node)&#123; ll son; for(register int i=last[node];i!=0;i=ed[i].prev) &#123; son=ed[i].to; if(!depth[son]) &#123; depth[son]=depth[node]+1; anc[son][0]=node; dfs(son); &#125; &#125;&#125;inline void LCASetup()&#123; depth[1]=1; anc[1][0]=0; dfs(1); for(register int i=1;i&lt;=21;i++) &#123; for(register int j=1;j&lt;=nc;j++) &#123; anc[j][i]=anc[anc[j][i-1]][i-1]; &#125; &#125;&#125;inline ll lca(ll x,ll y)&#123; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; for(register int i=21;i&gt;=0;i--) &#123; if(depth[anc[y][i]]&gt;=depth[x]) &#123; y=anc[y][i]; &#125; &#125; if(x==y) &#123; return x; &#125; for(register int i=21;i&gt;=0;i--) &#123; if(anc[x][i]!=anc[y][i]) &#123; x=anc[x][i]; y=anc[y][i]; &#125; &#125; return anc[x][0];&#125;inline ll ddfs(ll node)&#123; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to==anc[node][0]) &#123; continue; &#125; ddfs(ed[i].to); diff[node]+=diff[ed[i].to]; &#125; maxn=max(maxn,diff[node]);&#125;int main()&#123; scanf("%d%d",&amp;nc,&amp;query); for(register int i=0;i&lt;nc-1;i++) &#123; scanf("%d%d",&amp;from,&amp;to); addEdge(from,to); addEdge(to,from); &#125; LCASetup(); for(register int i=0;i&lt;query;i++) &#123; scanf("%d%d",&amp;from,&amp;to); LCA=lca(from,to); diff[from]++,diff[to]++,diff[LCA]--,diff[anc[LCA][0]]--; &#125; ddfs(1); cout&lt;&lt;maxn;&#125;]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>树上差分</tag>
        <tag>洛谷</tag>
        <tag>树链剖分</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 191C」Fools and Roads]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8CCodeForces-191C%E3%80%8DFools-and-Roads%2F</url>
    <content type="text"><![CDATA[给一棵有根树和一些路线，路线上的边权都+1，求所有边的权值 链接CodeForces 191C 题解这个题目的输出是每一条边所经过的次数，所以想到树上边差分。在差分之后确实是晕了，没有想到好的方法，但是突然想到了DFS求树上前缀和，对于每一条边，只要计算深度小的前缀和-深度大的前缀和即得答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct edge&#123; ll to,prev; &#125;;ll nc,ec,query,root,from,to;ll depth[500010],anc[500010][31],last[500010],diff[500010],prefix[500010],LCA,maxn;ll From[500010],To[500010];edge ed[500010*2];inline void addEdge(ll from,ll to)&#123; ed[++ec].prev=last[from]; ed[ec].to=to; last[from]=ec;&#125;inline void dfs(ll node)&#123; ll son; for(register int i=last[node];i!=0;i=ed[i].prev) &#123; son=ed[i].to; if(!depth[son]) &#123; depth[son]=depth[node]+1; anc[son][0]=node; dfs(son); &#125; &#125;&#125;inline void LCASetup()&#123; depth[1]=1; anc[1][0]=0; dfs(1); for(register int i=1;i&lt;=21;i++) &#123; for(register int j=1;j&lt;=nc;j++) &#123; anc[j][i]=anc[anc[j][i-1]][i-1]; &#125; &#125;&#125;inline ll lca(ll x,ll y)&#123; if(depth[x]&gt;depth[y]) &#123; swap(x,y); &#125; for(register int i=21;i&gt;=0;i--) &#123; if(depth[anc[y][i]]&gt;=depth[x]) &#123; y=anc[y][i]; &#125; &#125; if(x==y) &#123; return x; &#125; for(register int i=21;i&gt;=0;i--) &#123; if(anc[x][i]!=anc[y][i]) &#123; x=anc[x][i]; y=anc[y][i]; &#125; &#125; return anc[x][0];&#125;inline void ddfs(ll node)&#123; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to==anc[node][0]) &#123; continue; &#125; ddfs(ed[i].to); diff[node]+=diff[ed[i].to]; &#125;&#125;inline void dffs(ll node,ll val)&#123; prefix[node]=diff[node]+val; for(register int i=last[node];i;i=ed[i].prev) &#123; if(ed[i].to==anc[node][0]) &#123; continue; &#125; dffs(ed[i].to,prefix[node]); &#125;&#125;int main()&#123; scanf("%d",&amp;nc); for(register int i=0;i&lt;nc-1;i++) &#123; scanf("%d%d",&amp;from,&amp;to); From[i]=from,To[i]=to; addEdge(from,to); addEdge(to,from); &#125; LCASetup(); scanf("%d",&amp;query); for(register int i=0;i&lt;query;i++) &#123; scanf("%d%d",&amp;from,&amp;to); LCA=lca(from,to); diff[from]++,diff[to]++,diff[LCA]-=2; &#125; ddfs(1); dffs(1,0); for(register int i=0;i&lt;nc-1;i++) &#123; if(depth[From[i]]&lt;depth[To[i]]) &#123; swap(From[i],To[i]); &#125; printf("%d ",prefix[From[i]]-prefix[To[i]]); &#125;&#125;]]></content>
      <tags>
        <tag>CodeForces</tag>
        <tag>LCA</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
</search>
